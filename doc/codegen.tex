\documentclass[a4paper,fleqn]{article}

\usepackage{fullpage}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd} % llbracket, rrbracket
%\usepackage{mathtools} % dcases
\usepackage{color}
\usepackage{listings}
\usepackage{url}
\usepackage{microtype}
\usepackage{balance}
\usepackage{mathtools}

\definecolor{myviolet}{rgb}{0.6,0.0,0.65}
\definecolor{myblue}{rgb}{0.1,0.0,0.8}
\definecolor{mygreen}{rgb}{0.1,0.5,0.0}
\definecolor{myred}{rgb}{0.8,0.0,0.0}

\lstdefinelanguage{coq}{
  keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,From,Require,Variable,Variables,Hypothesis,Let,Inline,Eval},
  keywordstyle=\color{myviolet}\ttfamily,
  morekeywords=[2]{match,with,end,Set,Prop,Type,fun,of,let,in,struct,if,is,then,else,as,return,fix,for,leta,letr,letn,letd,letp,nmatch,dmatch,app,rapp},
  keywordstyle=[2]\color{mygreen}\ttfamily,
  morekeywords=[3]{reflexivity},
  keywordstyle=[3]\color{myred}\ttfamily,
  morekeywords=[4]{Monadify,Action,Monomorphization,Return,Bind,Pure,Monadification,Terminate,GenC,Reset},
  keywordstyle=[4]\color{myblue}\ttfamily,
}

% The color of "in" is myviolet for
% Definition c := Eval ... in ...
\lstdefinelanguage{vernacular}{
  keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,From,Require,Variable,Variables,Hypothesis,Let,Inline,Eval,in},
  keywordstyle=\color{myviolet}\ttfamily,
  morekeywords=[2]{match,with,end,Set,Prop,Type,fun,of,let,struct,if,is,then,else,as,return,fix,for,leta,letr,letn,letd,letp,nmatch,dmatch,app,rapp},
  keywordstyle=[2]\color{mygreen}\ttfamily,
  morekeywords=[3]{reflexivity},
  keywordstyle=[3]\color{myred}\ttfamily,
  morekeywords=[4]{Monadify,Action,Monomorphization,Return,Bind,Pure,Monadification,Terminate,GenC,Reset},
  keywordstyle=[4]\color{myblue}\ttfamily,
}

\lstdefinelanguage{AST}{
keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,
From,Require,Variable,Variables,Hypothesis,Let,Inline},
keywordstyle=\color{myviolet}\ttfamily,
morekeywords=[2]{nmatch,dmatch,with,end,leta,letr,letn,letd,letp,letapp,letrapp,letnmatch,letdmatch,letproof,in},
keywordstyle=[2]\color{mygreen}\ttfamily,
morekeywords=[3]{reflexivity},
keywordstyle=[3]\color{myred}\ttfamily,
%morekeywords=[4]{Monadify,Action,Monomorphization,Return,Bind,Pure,Monadification,Terminate,GenC,Reset},
%keywordstyle=[4]\color{myblue}\ttfamily
}

\lstdefinestyle{Cstyle} {language=C,basicstyle=\small\ttfamily}
\lstdefinestyle{OCamlstyle} {language=Caml,basicstyle=\small\ttfamily}
\lstdefinestyle{ASTstyle} {language=AST,basicstyle=\small\ttfamily}
\lstdefinestyle{Vernacularstyle} {language=vernacular,basicstyle=\small\ttfamily}

\def\pipe{\char`\|}
\def\tilde{\char`\~}
\def\tiret{\char`\-}
\def\plus{\char`\+}
\def\myhat{\char`\^}
\def\mystar{\char`\*}
\def\mybs{\char`\\}
\def\placeholder{\char`\_}

\lstset{
  language=coq,
  columns=fullflexible,
  basicstyle=\small\ttfamily,
  identifierstyle=\color{black}\ttfamily,
  commentstyle=\color{myred}\ttfamily,
  morecomment=[n]{(*}{*)},
  morestring=[b][\ttfamily]",
  showstringspaces=false,
  keepspaces,
  literate=
  {->}{$\to$}1
  {forall}{$\forall$}1
  {\\}{\texttt{\mybs}}1
  {>>=}{{$\gg =$}}3
  {=>}{$\Rightarrow$}3
}

\def\coq{\textrm{Coq}}
\def\gallina{\textrm{Gallina}}
\def\ocaml{\textrm{OCaml}}
\def\haskell{\textrm{Haskell}}
\def\scheme{\textrm{Scheme}}
\def\ssreflect{\textrm{SSReflect}}
\def\oeuf{\textrm{\OE uf}}
\def\certicoq{\textrm{CertiCoq}}
\def\codegen{\textrm{Codegen}}

\newcommand{\kwDefinition}{\mbox{\color{myviolet}\ttfamily Definition}}
\newcommand{\kwSection}{\mbox{\color{myviolet}\ttfamily Section}}

\newcommand{\kwlet}{\mbox{\color{mygreen}\ttfamily let}}
\newcommand{\kwin}{\mbox{\color{mygreen}\ttfamily in}}
\newcommand{\kwmatch}{\mbox{\color{mygreen}\ttfamily match}}
\newcommand{\kwas}{\mbox{\color{mygreen}\ttfamily as}}
\newcommand{\kwreturn}{\mbox{\color{mygreen}\ttfamily return}}
\newcommand{\kwwith}{\mbox{\color{mygreen}\ttfamily with}}
\newcommand{\kwend}{\mbox{\color{mygreen}\ttfamily end}}
\newcommand{\kwfix}{\mbox{\color{mygreen}\ttfamily fix}}
\newcommand{\kwfor}{\mbox{\color{mygreen}\ttfamily for}}

\newcommand{\lam}[2]{\lambda #1.\:#2}
\newcommand{\lamT}[3]{\lambda #1\mathord{:}#2.\:#3}
\newcommand{\lamB}[1]{\lambda #1.\:}
\newcommand{\lamTB}[2]{\lambda #1\mathord{:}#2.\:}
\newcommand{\lamM}[3]{\lambda \rep{#1}.\:#3}
\newcommand{\lamTM}[3]{\lambda \rep{#1\mathord{:}#2}.\:#3}

\newcommand{\gassum}[2]{(#1\mathord{:}#2)}
\newcommand{\glodef}[3]{(#1:=#2\mathord{:}#3)}
\newcommand{\glodefB}[2]{(#1:=#2)}
\newcommand{\lassum}[2]{(#1\mathord{:}#2)}
\newcommand{\ldef}[3]{(#1:=#2\mathord{:}#3)}

\newcommand{\prodT}[3]{\forall #1\mathord{:}#2.\:#3}

\newcommand{\letin}[3]{\kwlet\:#1:=#2\:\kwin\:#3}
\newcommand{\letinB}[2]{\kwlet\:#1:=#2\:\kwin}
\newcommand{\letinM}[3]{\kwlet\:\rep{#1:=#2}\:\kwin\:#3}

\newcommand{\omatch}[2]{\kwmatch\:#1\:\kwwith\:{#2}\:\kwend}
\newcommand{\match}[4]{\kwmatch\:#1\:\kwwith\:(#2 \Rightarrow #3)_{#4}\:\kwend}
\newcommand{\matchasinret}[7]{\kwmatch\:#1\:\kwas\:#2\:\kwin\:#3\:\kwreturn\:#4\:\kwwith\:(#5 \Rightarrow #6)_{#7}\:\kwend}

\newcommand{\ofix}[2]{\kwfix\:{#1}\:\kwfor\:{#2}}
\newcommand{\fix}[4]{\kwfix\:(#1 := #2)_{#3}\:\kwfor\:#4}
\newcommand{\fixT}[5]{\kwfix\:(#1:\!#2 := #3)_{#4}\:\kwfor\:#5}

\DeclareMathOperator{\NA}{NA} % number of arguments
\DeclareMathOperator{\NP}{NP} % number of parameters for the inductive type
\DeclareMathOperator{\NI}{NI} % number of indexes for the inductive type
\DeclareMathOperator{\NM}{NM} % number of members for the constructor

\DeclareMathOperator{\Arr}{Arr} % Arr(t) is arity of the inductive type t.
\newcommand{\arr}[1]{\Gamma_{\Arr(#1)}}

\DeclareMathOperator{\FV}{FV}

\newcommand{\tD}{{t^\mathrm{D}}}
\newcommand{\tE}{{t^\mathrm{E}}}
\newcommand{\tL}{{t^\mathrm{L}}}
\newcommand{\tM}{{t^\mathrm{M}}}
\newcommand{\tF}{{t^\mathrm{F}}}
\newcommand{\tC}{{t^\mathrm{C}}}
\newcommand{\tA}{{t^\mathrm{A}}}

\DeclareMathOperator{\merg}{merge}

\newcommand{\BRA}[1]{\llbracket #1 \rrbracket}

\DeclareMathOperator{\genbody}{GENBODY}
\newcommand{\genbodyat}[2]{\genbody^\mathrm{AT}_{#1}\BRA{#2}}
\newcommand{\genbodyan}[1]{\genbody^\mathrm{AN}\BRA{#1}}
\newcommand{\genbodyb}[2]{\genbody^\mathrm{B}_{#1}\BRA{#2}}

\DeclareMathOperator{\genfunop}{GENFUN}
\newcommand{\genfun}[1]{\genfunop\BRA{#1}}
\newcommand{\genfuns}[1]{\genfunop^\mathrm{S}\BRA{#1}}
\newcommand{\genfunm}[1]{\genfunop^\mathrm{M}\BRA{#1}}

\newcommand{\enumentries}[1]{\mathrm{enum\_entries}\BRA{#1}}
\newcommand{\argstructdefs}[1]{\mathrm{arg\_structdefs}\BRA{#1}}
\newcommand{\mainstructdef}[1]{\mathrm{main\_structdef}\BRA{#1}}
\newcommand{\auxstructdef}[2]{\mathrm{aux\_structdef}\BRA{#1}_{#2}}
\newcommand{\forwarddecl}[1]{\mathrm{forward\_decl}\BRA{#1}}
\newcommand{\entryfunctions}[1]{\mathrm{entry\_functions}\BRA{#1}}
\newcommand{\mainfunction}[1]{\mathrm{main\_function}\BRA{#1}}
\newcommand{\auxfunction}[2]{\mathrm{aux\_function}\BRA{#1}_{#2}}
\newcommand{\bodyfunction}[1]{\mathrm{body\_function}\BRA{#1}}
\newcommand{\auxcase}[2]{\mathrm{aux\_case}\BRA{#1}_{#2}}
\newcommand{\maincase}[1]{\mathrm{main\_case}\BRA{#1}}

\DeclareMathOperator{\cvop}{CV}
\newcommand{\cv}[3]{\cvop\BRA{#1\,/\,#2}_{#3}}

\DeclareMathOperator{\TRop}{TR}
\newcommand{\TR}[2]{\TRop\BRA{#1}_{#2}}
\newcommand{\tr}{\mathit{TR}}

\DeclareMathOperator{\RNTop}{RNT}
\newcommand{\RNT}[2]{\RNTop\BRA{#1}_{#2}}

\DeclareMathOperator{\APP}{APP}

\newcommand{\ldq}{\text{``}}
\newcommand{\rdq}{\text{''}}
\newcommand{\dq}[1]{\text{``}#1\text{''}}
\newcommand{\ttlparen}{\texttt{(}}
\newcommand{\ttrparen}{\texttt{)}}
\newcommand{\ttparen}[1]{\texttt{(}#1\texttt{)}}
\newcommand{\ttlbrace}{\texttt{\char '173}}
\newcommand{\ttrbrace}{\texttt{\char '175}}
\newcommand{\ttbrace}[1]{\ttlbrace#1\ttrbrace}
\newcommand{\tteq}{\texttt{=}}
\newcommand{\ttsemi}{\texttt{;}}
\newcommand{\ttcomma}{\texttt{,}}
\newcommand{\ttcolon}{\texttt{:}}
\newcommand{\ttstar}{\texttt{*}}
\newcommand{\ttamp}{\texttt{\&}}

\newcommand{\kwswitch}{\mbox{\color{myviolet}\ttfamily switch}}
\newcommand{\kwbreak}{\mbox{\color{myviolet}\ttfamily break}}
\newcommand{\kwgoto}{\mbox{\color{myviolet}\ttfamily goto}}
\newcommand{\kwstruct}{\mbox{\color{myviolet}\ttfamily struct}}
\newcommand{\kwvoid}{\mbox{\color{myviolet}\ttfamily void}}
\newcommand{\kwint}{\mbox{\color{myviolet}\ttfamily int}}
\newcommand{\kwCreturn}{\mbox{\color{myviolet}\ttfamily return}}
\newcommand{\kwcase}{\mbox{\color{myviolet}\ttfamily case}}
\newcommand{\kwdefault}{\mbox{\color{myviolet}\ttfamily default}}
\newcommand{\kwenum}{\mbox{\color{myviolet}\ttfamily enum}}
\newcommand{\kwstatic}{\mbox{\color{myviolet}\ttfamily static}}

\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\appref}[1]{Appendix~\ref{#1}}

\DeclareMathOperator{\passign}{passign}

\DeclareMathOperator{\fvarsop}{fvars}
\newcommand{\fvars}[1]{\fvarsop\BRA{#1}}
\newcommand{\fvarsd}[1]{\fvarsop'\BRA{#1}}

\DeclareMathOperator{\fargsop}{fargs}
\newcommand{\fargs}[1]{\fargsop\BRA{#1}}
\newcommand{\fargsd}[1]{\fargsop'\BRA{#1}}

\DeclareMathOperator{\Aop}{A}
\DeclareMathOperator{\Bop}{B}
\newcommand{\A}[3]{\Aop_{#1}\BRA{#2\,/\,#3}}
\newcommand{\B}[3]{\Bop_{#1}\BRA{#2\,/\,#3}}

\newcommand{\AbreakEq}[3]{\Aop_{#1}\llbracket \begin{aligned}[t] & #2 \\ & /\, #3 \rrbracket = \end{aligned}}
\newcommand{\BbreakEq}[3]{\Bop_{#1}\llbracket \begin{aligned}[t] & #2 \\ & /\, #3 \rrbracket = \end{aligned}}

\DeclareMathOperator{\Fop}{F}
\newcommand{\F}[1]{\Fop\BRA{#1}}
\DeclareMathOperator{\BRop}{BR}
\newcommand{\BR}[3]{\BRop\BRA{#1}_{#2,#3}}
\DeclareMathOperator{\Eop}{E}
\newcommand{\E}[3]{\Eop\BRA{#1\,/\,#2}_{#3}}

% based on the Coq reference manual, doc/common/macros.tex
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\WF}[2]{\ensuremath{{\mathcal{W\!F}}(#1)[#2]}}
\newcommand{\WFTWOLINES}[2]{\ensuremath{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WT}[4]{\ensuremath{#1[#2] \vdash #3 : #4}}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\substm}[3]{#1\{\overline{#2/#3}\}}

% taken from the Coq reference manual, doc/sphinx/refman-preamble.sty
\newcommand{\case}{\kw{case}}
\newcommand{\Fix}{\kw{Fix}}

\newcommand{\vdashb}{\vdash_{\textrm{b}}}
\newcommand{\vdashf}{\vdash_{\textrm{f}}}

\newcommand{\reltri}{\mathrel{\triangleright}}

\newcommand{\rep}[1]{\overline{#1}}
\newcommand{\repop}[2]{\overline{#1\underbracket[0.4pt][1pt]{#2}}}
\newcommand{\repopi}[3]{\overline{#1\underbracket[0.4pt][1pt]{#2}}^{#3}}
\newcommand{\repi}[2]{\overline{#1}^{#2}}

\title{codegen development memo}

\begin{document}

\maketitle

\section{Notations}\label{sec:notations}

\subsection{Repetition}

\begin{itemize}
  \item We use overline to represent repetition:
    $\repop{x_i+y_i}{<}^{1\leq i \leq n}$ means $x_1+y_1 < \ldots < x_n+y_n$.
  \item We omit the operator part ($\underbracket[0.4pt][1pt]{<}$) when the operator is just a punctuation to separate each term.
    We write $\repi{x_i+y_i}{1\leq i \leq n}$ for $x_1+y_1, \ldots, x_n+y_n$ if comma is appropriate separator for the context.
  \item We omit the range part ($1\leq i \leq n$) and index of metavariables ($i$ of $x_i$ and $y_i$) when the metavariables are sequences of same length.
    We write $\repop{x+y}{<}$ for $x_1+y_1 < \ldots < x_n+y_n$ when $x$ and $y$ are $n$-element sequences.
  \item We omit both the operator and range part if appropriate.
    We write $\rep{x+y}$ for $x_1+y_1, \ldots, x_n+y_n$ if $x$ and $y$ are $n$-element sequences and comma is appropriate separator for the context.
    We use this form in most case.
  \item We use underline to distinguish metavariables which index is added by overline or not.
    We write $\rep{x+\underline{y}}$ for $x_1+y, \ldots, x_n+y$.
  \item We use nested overline to represent multi-dimensional indexes. \\
    $\omatch{t}{\rep{C\:\rep{x}\Rightarrow u}}$ means \\
    $\omatch{t}{C_1\:\rep{x_1}\Rightarrow u_1 \:|\: \ldots \:|\: C_n\:\rep{x_n}\Rightarrow u_n}$ and \\
    $\omatch{t}{C_1\: x_{11}\ldots x_{1m_1} \Rightarrow u_1
                \:|\: \ldots
                \:|\: C_n\: x_{n1}\ldots x_{nm_n} \Rightarrow u_n}$.
  \item Nested overline and underline can be combined. \\
    $\rep{\letinB{f'}{\ofix{\underline{(\rep{f:=t})}}{f}}}$ means \\
    $\letinB{f'_1}{\ofix{\rep{(f:=t)}}{f_1}} ~\ldots~
     \letinB{f'_h}{\ofix{\rep{(f:=t)}}{f_h}}$ and \\
    $\letinB{f'_1}{\ofix{(f_1:=t_1)\ldots(f_n:=t_n)}{f_1}} ~\ldots~
     \letinB{f'_h}{\ofix{(f_1:=t_1)\ldots(f_n:=t_n)}{f_h}}$.
  \item This notation is taken from \cite{steele2017s}.
\end{itemize}

\subsection{Number of Elements}

We use $|x|$ to represent the number of elements: $|x|=n$ if $x$ is an $n$-element sequence, $x_1, \ldots, x_n$.

\subsection{Number of Arguments}

\begin{itemize}
  \item $\NA_t$ is the number of arguments of $t$: \quad $\NA_t=m$ if $t : T_1 \rightarrow \dotsb \rightarrow T_m \rightarrow T_0$ and $T_0$ is an inductive type.
  \item $\NP_I$ is the number of the parameters of the inductive type $I$: \\
    $\NP_I=p$ if $I$ is defined in an inductive definitions $\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$.
  \item $\NI_I$ is the number of the indexes of the inductive type $I$ (the number of arguments without the parameters for the inductive type): \\
    $\NI_I=|\arr{I}|$ where
    $\arr{t}$ is the arity of the inductive type $t$.
    It means $(t : \forall (\Gamma_P; \arr{t}), S)$ is defined in $\Gamma_I$ of $\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$ in the global environment where
    $|\Gamma_P|$ = $p$ and $S$ is a sort.
  \item $\NM_C$ is the number of the members of the constructor $C$ (the number of arguments without the parameters for the inductive type): \\
    $\NM_C=|\Gamma|$ where
    $\Gamma$ is the non-parameter arguments of the constructor $C$.
    It means $(t : \forall (\Gamma_P; \Gamma), S)$ is defined in $\Gamma_C$ of $\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$ in the global environment where
    $|\Gamma_P|$ = $p$ and $S$ is a sort.
\end{itemize}

\subsection{Substitution}
$\subst{t}{x}{u}$ means a term in which $x$ in term $t$ is replaced by $u$.
This notation is taken from the Coq reference manual~\cite{coqrefman8.12.0}.

We use $\substm{t}{x}{u}$ for parallel substituion.

\subsection{Others}

\begin{itemize}
  \item $\FV(t)$ means the free variables of $t$.
\end{itemize}

\section{\gallina{}}\label{sec:gallina}
\subsection{\gallina{} Syntax}\label{sec:gallina-syntax}

\begin{align*}
  t =&\ x & \text{variable} \\
    |&\ c & \text{constant} \\
    |&\ C & \text{constructor} \\
    |&\ T & \text{type} \\
    |&\ \lamT{x}{T}{t}        & \text{abstraction} \\
    |&\ t\:u                  & \text{application} \\
    |&\ \letin{x}{t:T}{u}     & \text{let-in} \\
    |&\ \omatch{t}{\overline{C\:\overline{x}\Rightarrow u}} & \text{conditional} \\
    |&\ \ofix{\overline{f/k{:}T:=t}}{f_j} & \text{fixpoint}
\end{align*}
{\small Note:
\begin{itemize}
  \item $u, a, b$ represents a term as $t$. \\ $y, z,$ and $f$ represent a variable as $x$. \\ $U$ represents a type as $T$.
  \item We write $(\cdots((t\:u_1)\:u_2)\cdots\:u_n)$ as $t\:u_1\ldots u_n$ or $t\:\rep{u}$.
  \item We write $\lamT{x_1}{T_1}{(\ldots (\lamT{x_n}{T_n}{u}) \ldots)}$ as $\lamTM{x}{T}{u}$.
  \item We write $\letin{x_1}{t_1{:}T_1}{(\ldots(\letin{x_n}{t_n{:}T_n}{u})\ldots)}$ as $\letinM{x}{t{:}T}{u}$.
  \item $k$ is an integer. \\ $k_i$ for fixpoint specify the decreasing argument for $f_i$.
  \item If it is unambiguous, we omit type annotations for the sake of simplicity.  We also omit $k_i$ in fixpoints if they are not used.
  \item We omitted the elimination predicate (\kwas-\kwin-\kwreturn{} clause of \kwmatch-expression) in the syntax.
  \item We omitted the dummy parameters (underscores between $C$ and $\overline{x}$) in conditionals.
  \item We consider inductive types and constructor types has no let-in in binders.
  \item We omitted the detail of the types.  Actual \gallina{} permits any \gallina{} term which evaluates to a type.
\end{itemize}}

% {\tiny
% We ignore Var, Meta, Evar because they are not used in complete program.
% Int and Float are considered as constants.
% Prod, Ind and Sort are considered as types.
% Cast is ignored because it can be eliminated immediately.
% CoFix is ignored because lazy-evaluation is not suitable to C.
% Proj is ignored because it is similar to \kwmatch.}

\subsection{\gallina{} Conversion Rules}\label{sec:conversion-rules}

% based on sphinx/language/core/conversion.rst and doc/sphinx/language/core/inductive.rst
\begin{gather*}
  \text{beta:}~
    E[\Gamma] \vdash ((\lam{x}{t})\:u) \reltri \subst{t}{x}{u} \\
  \text{delta-local:}~
    \dfrac{(x:=t) \in \Gamma}{E[\Gamma] \vdash x \reltri t} \\
  \text{delta-global:}~
    \dfrac{(c:=t) \in E}{E[\Gamma] \vdash c \reltri t} \\
  \text{zeta:}~
    E[\Gamma] \vdash \letin{x}{t}{u} \reltri \subst{u}{x}{t} \\
  \text{iota-match:}~
    \dfrac
    {
      E[\Gamma] \vdash C_j\:\overline{a}\:\overline{b} : T \quad
      \text{$|a| = \NP_T$}
    }{
      E[\Gamma] \vdash
      \omatch{(C_j\:\overline{a}\:\overline{b})}{\overline{C\:\overline{x}\Rightarrow t}}
      \reltri
      (\lam{\overline{x_j}}{t_j})\:\overline{b}
    } \\
  \text{iota-fix:}~
    \dfrac{
      u_{k_j} = C\:\overline{a} \quad
      |u| = k_j
    }{
      E[\Gamma] \vdash\; (\ofix{\overline{f/k:=t}}{f_j})\:\overline{u} \reltri\; \substm{t_j}{f}{\ofix{\underline{(\overline{f/k:=t})}}{f}} \: \overline{u}
    } \\
  \text{eta expansion:}~
    \dfrac{\WTEG{t}{\prodT{x}{T}{U}}}{E[\Gamma] \vdash t \reltri \lamT{x}{T}{(t\:x)}}
\end{gather*}
{\small Note:
\begin{itemize}
  \item The rules shown here are reductions, except the eta expansion.
  \item Variables cannot conflict because \coq{} uses de Bruijn's indexes to represent variables.
  \item $E$ is a global environment which is a list of
    global assumptions $\gassum{c}{T}$,
    global definitions $\glodef{c}{t}{T}$, and
    inductive definitions ($\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$).
  \item $\Gamma$ is a local context which is a list of
    local assumptions $\lassum{x}{T}$ and
    local definitions $\ldef{x}{t}{T}$.
    The local assumptions represent variables bounded by outer abstractions, conditionals, and fixpoints.
    The local definitions represent variables bounded by outer let-in.
  \item If it is unambiguous, we omit type annotations in these definitions for the sake of simplicity.
  \item Iota-match reduces $\kwmatch\:\mathtt{@cons\:nat\:1\:nil}\:\kwwith\:(\mathtt{nil} \Rightarrow t_1)\:|\:(\mathtt{cons}\:\mathtt{h}\:\mathtt{t} \Rightarrow t_2)\:\kwend$ to $(\lam{\mathtt{h}}{\lam{\mathtt{t}}{t_2}})\:1\:\mathtt{nil}$
    because \lstinline!list! has one parameter $(\NP_\mathtt{nat}=1)$ and \lstinline!cons! has two members $(\NM_\mathtt{cons}=2)$.
\end{itemize}}

\section{CodeGen}\label{sec:codegen}

\begin{itemize}
\item \gallina-to-\gallina{} Transformations
  \begin{itemize}
  \item Inlining
  \item Strip Cast
  \item Eta Expansion for Functions
  \item V-Normalization
  \item S-Normalization
  \item Type Normalization
  \item Static Argument Normalization
  \item Unused let-in Deletion
  \item Call Site Replacement
  \item Eta Reduction to Expose Fixpoint
  \item Argument Completion
  \item Monomorphism Check
  \item Borrow Check
  \item C Variable Allocation
  \end{itemize}
\item C Code Generation
  \begin{itemize}
  \item C Code Generation
  \end{itemize}
\end{itemize}

\section{\gallina-to-\gallina{} Transformations}\label{sec:gallina-to-gallina-transformations}

We define transformations as a judgement $E[\Gamma] \vdash t \reltri u$.
This means a subterm $t$ is substituted to $u$ where
$E$ and $\Gamma$ are the global environment and the local context of them.

We also use $E[\Gamma] \vdash_K t \reltri u$ to represent transformations restricted with a syntactical context $K$.

$K$ is a single-hole context: a term with a subterm is sustituted with a hole, $[]$.
$K[u]$ is $K$ with the hole is substituted with $u$.

$E[\Gamma] \vdash_K t \reltri u$ is similar to $E[\Gamma] \vdash K[t] \reltri K[u]$ but
$\Gamma$ is the local context of $t$ (not $K[t]$).

Also, we use $E[] \vdash_\$ t \reltri u$ which defines a tranformation of an entire term (not subterm).
(The local context is empty because an entire term has no local context.)

When we define a new constant in a transformation,
We use $E[\Gamma] \vdash t \reltri (E;\glodef{c}{a}{T})[\Gamma] \vdash u$.

\subsection{Inlining}\label{sec:inlining}
\subsection{Strip Cast}\label{sec:strip-cast}
\subsection{Eta Expansion for Functions}\label{sec:eta-expand-funcs}
We apply eta-expansion to functions of top-level functions, fix-bounded functions, and closure generating lambdas.
We consider explicit lambdas are closure generation.
This makes beta-var applicable for partial applications without worrying to expose computation.
(CIC~\cite{coqrefman8.12.0} uses lambdas for match-branches but our syntax uses no lambdas for them.
Thus match-branches doesn't trigger the eta expansion.)

\begin{gather*}
  \text{etaex-top:}~
    \dfrac{
      E[] \vdash t : \prodT{x}{T}{U} \quad
      \text{$t$ is not an abstraction nor fixpoint} \quad
    }{
      E[] \vdash_\$ t \reltri \lamT{x}{T}{(t\:x)}
    } \\
  \text{etaex-fix:}~
    \dfrac{
      \begin{aligned}
        & E[\Gamma] \vdash t_i : \prodT{x}{U_1}{U_2} \quad
          \text{$t_i$ is not an abstraction nor fixpoint} \\
        & K = \ofix{\repi{(f{:}T:=t)}{1\leq l < i} (f_i{:}T_i:=[]) \repi{(f{:}T:=t)}{i < l \leq h}}{f_j}
      \end{aligned}
    }{
        E[\Gamma] \vdash_K t_i \reltri \lamT{x}{U_1}{(t_i\:x)}
    } \\
  \text{etaex-abs:}~
    \dfrac{
      \begin{aligned}
        & E[\Gamma] \vdash t : \prodT{x}{U_1}{U_2} \quad
          \text{$t$ is not an abstraction nor fixpoint} \\
        & K = \lamT{y}{T}{[]}
      \end{aligned}
    }{
      E[\Gamma] \vdash_K t \reltri \lamT{x}{U_1}{(t\:x)}
    }
\end{gather*}

This transformations makes a term in following syntax.
The entire term is represented as $\tD'$.
($\tD$ for functions and $\tE$ for non-function constants.)

\begin{align*}
  \tD =&\ \lamT{x}{T}{\tD'} \\
      |&\ \ofix{\overline{f/k{:}T:=\tD}}{f_j} \\
  \tD' =&\ \tD \\
       |&\ \tE & \text{the type of $\tE$ is an inductive type} \\
  \tE =&\ x \\
    |&\ c \\
    |&\ C \\
    |&\ T \\
    |&\ \tE\:\tE \\
    |&\ \letin{x}{\tE:T}{\tE} \\
    |&\ \omatch{\tE}{\overline{C\:\overline{x}\Rightarrow \tE}} \\
    |&\ \tD \\
\end{align*}

The type of $\tE$ in $\tD'$ is an inductive type because
the eta expansions (etaex-fix and etaex-abs) transform the body of abstraction and fixpoint until its type is not function type.

\subsection{V-Normalization}\label{sec:v-normalization}
\subsubsection{V-Reductions}\label{sec:v-reductions}
\begin{gather*}
  \text{zeta-arg:}~
    \dfrac
    {
      E[\Gamma] \vdash t : T \quad
      \text{$a$ is not an application} \quad
      \text{$t$ is not a variable} \quad
      \text{$y$ is a fresh variable}
    }{
      E[\Gamma] \vdash
      a\:\overline{x}\:t\:\overline{u}
      \reltri
      \letin{y}{t:T}{a\:\overline{x}\:y\:\overline{u}}
    } \\
  \text{zeta-item:}~
    \dfrac
    {
      E[\Gamma] \vdash t : T \quad
      \text{$t$ is not a variable} \quad
      \text{$y$ is a fresh variable}
    }{
      E[\Gamma] \vdash
        \omatch{t}{\overline{C\:\overline{x} \Rightarrow u}}
        \reltri
        \letin{y}{t:T}{\omatch{y}{\overline{C\:\overline{x} \Rightarrow u}}}
    }
\end{gather*}

\subsubsection{V-Normal Form}\label{sec:v-normal-form}
V-normal form restricts \gallina{} terms that (1) application arguments and (2) match items to variables.
\begin{align*}
  t =&\ x~|~c~|~C~|~T~|~\lamT{x}{T}{t}~|~ \letin{x}{t:T}{u} \\
    |&\ \ofix{\overline{f/k{:}T:=t}}{f_j} \\
    |&\ t\:x                               & \leftarrow (1) \\
    |&\ \omatch{x}{\overline{C\:\overline{x} \Rightarrow t}} & \leftarrow (2)
\end{align*}

Since we apply V-reductions for a eta-expanded term,
the result term can be represented in following syntax.

\begin{align*}
  \tD =&\ \lamT{x}{T}{\tD'} \\
      |&\ \ofix{\overline{f/k{:}T:=\tD}}{f_j} \\
  \tD' =&\ \tD \\
       |&\ \tE & \text{the type of $\tE$ is an inductive type} \\
  \tE =&\ x \\
    |&\ c \\
    |&\ C \\
    |&\ T \\
    |&\ \tE\:x & \leftarrow (1) \\
    |&\ \letin{x}{\tE:T}{\tE} \\
    |&\ \omatch{x}{\overline{C\:\overline{x}\Rightarrow \tE}} \leftarrow (2) \\
    |&\ \tD \\
\end{align*}

\subsection{S-Normalization}\label{sec:s-normalization}

\subsubsection{S-Reductions}\label{sec:s-reductions}
\begin{gather*}
  \text{beta-var:}~
    E[\Gamma] \vdash (\lam{x}{t})\:y \reltri \subst{t}{x}{y} \\
  \text{delta-var:}~
    \dfrac{(x:=y) \in \Gamma}{E[\Gamma] \vdash x \reltri y} \\
  \text{delta-fun:}~
     \dfrac
     {
       0 \leq |x| \quad
       0 < |y| \quad
       (f := t\:\overline{x}) \in \Gamma \quad
       \text{$t$ is one of $x, c, C, (\lam{x}{u}), (\ofix{\overline{f/k:=t}}{f_j})$}
     }{
       E[\Gamma] \vdash f\:\overline{y}
                        \reltri
                        t\:\overline{x}\:\overline{y}
     } \\
  \text{zeta-flat:}~
    E[\Gamma] \vdash \letin{y}{(\letin{x}{t_1}{t_2})}{t_0}
                       \reltri
                       \letin{x}{t_1}{(\letin{y}{t_2}{t_0})} \\
  \text{zeta-app:}~
    E[\Gamma] \vdash
     (\letin{y}{t}{u})\:\overline{x}
     \reltri
     \letin{y}{t}{(u\:\overline{x})} \\
  \text{iota-match-var:}~
    \dfrac
    {
      (x:=C_j\:\overline{y}\:\overline{z}:T) \in \Gamma \quad
      |y|=\NP_T
    }{
      E[\Gamma] \vdash
      \omatch{x}{\overline{C\:\overline{x}\Rightarrow t}}
      \reltri
      (\lam{\overline{x_j}}{t_j})\:\overline{z}
    } \\
  \text{iota-fix-var:}~
    \dfrac
    {
      \begin{gathered}
        (x_{k_j} := C\:\overline{y}) \in \Gamma \quad
        \text{$\overline{f'}$ are fresh variables} \\
        E[\Gamma] \vdash (\ofix{\overline{f/k:=t}}{f_j})\:\overline{x} : T \quad
        \text{$T$ is an inductive type}
      \end{gathered}
    }{
        E[\Gamma] \vdash\;
          (\ofix{\overline{f/k:=t}}{f_j})\:\overline{x}
          \reltri
          \letinM{f'}{\ofix{\underline{(\overline{f/k:=t})}}{f}}{\substm{t_j}{f}{f'}} \: \overline{x}
    } \\
  \text{iota-fix-var':}~
    \dfrac
    {
      \begin{gathered}
        (x_{k_j} := C\:\overline{y}) \in \Gamma \quad
        \overline{(f' := \ofix{\underline{(\overline{f/k:=t})}}{f}) \in \underline{\Gamma}} \\
        E[\Gamma] \vdash (\ofix{\overline{f/k:=t}}{f_j})\:\overline{x} : T \quad
        \text{$T$ is an inductive type}
      \end{gathered}
    }{
      E[\Gamma] \vdash
      (\ofix{\overline{f/k:=t}}{f_j})\:\overline{x}
      \reltri
      \substm{t_j}{f}{f'} \:\overline{x}
    } \\
  \text{match-app:}~
    \dfrac
    {
      E[\Gamma] \vdash z : T
    }{
      \begin{aligned}
        E[\Gamma] \vdash\; &
          \kwmatch\:x\:
          \kwas\:x'\:
          \kwin\:I\:\overline{y}\:
          \kwreturn\:{T \rightarrow P\:\overline{y}\:x'}
          \kwwith\:(\overline{{C\: \overline{x}} \Rightarrow {t}})\:
          \kwend\:z \\
        \reltri\; &
          \kwmatch\:x\:
          \kwas\:x'\:
          \kwin\:I\:\overline{y}\:
          \kwreturn\:{P\:\overline{y}\:x'}
          \kwwith\:(\overline{{C\: \overline{x}} \Rightarrow {t\:\underline{z}}})\:
          \kwend
      \end{aligned}
    }
\end{gather*}

{\small Note:
\begin{itemize}
  \item match-app is not convertible
\end{itemize}}

\subsubsection{S-Normal Form}\label{sec:s-normal-form}
S-reductions transform applications to restrict function positions.
\begin{itemize}
  \item beta-var removes an abstraction at the function position of an application.
  \item zeta-app removes a let-in at the function position of an application.
  \item match-app removes a conditional at the function position of an application.
\end{itemize}
Also, types cannot be a function.
We treat multi-arguments application as single application, application is not occur at a function position.
Thus, function position can be variable, constant, construcor, or fixpoint in the S-normal form.

Also, zeta-flat removes a let-in at the binder term of a let-in.

\begin{align*}
  \tD =&\ \lamT{x}{T}{\tD'} \\
      |&\ \ofix{\overline{f/k{:}T:=\tD}}{f_j} \\
  \tD' =&\ \tD \\
       |&\ \tL & \text{the type of $\tL$ is an inductive type} \\
  \tL =&\ \letinM{x}{\tM:T}{\tM} \\
  \tM =&\ \omatch{x}{\overline{C\:\overline{x}\Rightarrow \tL}} \\
      |&\ \tE \\
  \tE =&\ x ~|~ c ~|~ C ~|~ T \\
    |&\ \tF\:\rep{x} & \text{$0 < |x|$} \\
    |&\ \tD \\
  \tF =&\ x ~|~ c ~|~ C ~|~ \ofix{\overline{f/k{:}T:=\tD}}{f_j}
\end{align*}

\subsection{Type Normalization}\label{sec:type-normalization}

We normalize type annotations in the term.

This transformation makes that types contain no variable bounded by let-ins
because such variables are redex of delta reduction.
Thus, this transformation makes Unused let-in Deletion (\secref{sec:let-in-deletion}) more effective.

\subsection{Static Argument Normalization}\label{sec:static-argument-normalization}

We normalize static arguments.
We assume the normalized static arguments have no free variables.

It makes the syntax as follows.

\begin{align*}
  \tD =&\ \lamT{x}{T}{\tD'} \\
      |&\ \ofix{\overline{f/k{:}T:=\tD}}{f_j} \\
  \tD' =&\ \tD \\
       |&\ \tL & \text{the type of $\tL$ is an inductive type} \\
  \tL =&\ \letinM{x}{\tM:T}{\tM} \\
  \tM =&\ \omatch{x}{\overline{C\:\overline{x}\Rightarrow \tL}} \\
      |&\ \tE \\
  \tE =&\ x ~|~ c ~|~ C ~|~ T \\
    |&\ \tF\:\rep{x} & \text{$0 < |x|$} \\
    |&\ \tC\:\rep{\tA} & \text{$0 < |\tA|$} \\
    |&\ \tD \\
  \tF =&\ x ~|~ \ofix{\overline{f/k{:}T:=\tD}}{f_j} \\
  \tC =&\ c ~|~ C \\
  \tA =&\ x ~|~ u & \text{$u$ is a static argument (normal \gallina{} term without free variables)}
\end{align*}

The application in previous section, $\tF\:\rep{x}$, is changed to $\tC\:\rep{\tA}$ for constant and constructor applications.
(Thus, this is not V-normal form.)

Static arguments are defined as follows by default.
\begin{itemize}
  \item non-monomorphic arguments for constant functions.
    (The non-monomorphic argument means an argument which type is a sort or a polymorphic function type,  )
  \item parameters for constructors.
\end{itemize}
The static arguments can be configured with \lstinline!CodeGen Arguments! command.

This transformation makes that static arguments contain no variable bounded by let-ins
because such variables are redex of delta reduction.
Thus, this transformation makes Unused let-in Deletion (\secref{sec:let-in-deletion}) more effective.

\subsection{Unused let-in Deletion}\label{sec:let-in-deletion}

\begin{gather*}
  \text{zeta-del:}~
    \dfrac{
      \text{$x$ does not occur in $u$} \quad \text{$x$ is not linear} \quad \text{$\FV(t)$ does not contain linear variable}
    }{E[\Gamma] \vdash \letin{x}{t}{u}
                       \reltri
                       u
    }
\end{gather*}

\subsection{Call Site Replacement}\label{sec:call-site-replacement}

\begin{gather*}
  \text{replace:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is a constant or constructor} \\
        \text{$a_{|a|}$ is not a variable} \\
        \rep{a} = \merg_t(\rep{x}, \rep{u}) \\
        \text{$\rep{y}$ are fresh variables} \quad
        |x| = |y| \\
        \rep{b} = \merg_t(\rep{y}, \rep{u}) \\
        \text{$c$ is a fresh constant} \\
      \end{gathered}
    }{E[\Gamma] \vdash_K t\:\rep{a}\:\rep{z}
      \reltri
      (E;\glodefB{c}{\lam{\rep{y}}{t\:\rep{b}}})[\Gamma] \vdash c\:\rep{x}\:\rep{z}
    }
\end{gather*}

$K$ is a non-application context to restrict $t\:\rep{a}\:\rep{z}$ is not at a function position of an application.
($K = (\lam{x}{[]})$, $(\letin{x}{[]}{u})$, $(\letin{x}{t}{[]})$, or \ldots but NOT $([]\:u)$.)

$\merg_t(\rep{x}, \rep{u})$ represents a sequence of terms which two sequences of terms are merged according to the static arguments definition of $t$.
The first argument $\rep{x}$ specifies dynamic arguments.
The second argument $\rep{u}$ specifies static arguments.
For example, assuming the 1st and 4th arguments are static for $t$, $\merg_t((x_1, x_2, x_3), (u_1, u_2)) = (u_1, x_1, x_2, u_2, x_3)$.

This transformation removes non-variable arguments from applications.
Thus the result will be V-normal form again.

\begin{align*}
  \tD =&\ \lamT{x}{T}{\tD'} \\
      |&\ \ofix{\overline{f/k{:}T:=\tD}}{f_j} \\
  \tD' =&\ \tD \\
       |&\ \tL & \text{the type of $\tL$ is an inductive type} \\
  \tL =&\ \letinM{x}{\tM:T}{\tM} \\
  \tM =&\ \omatch{x}{\overline{C\:\overline{x}\Rightarrow \tL}} \\
      |&\ \tE \\
  \tE =&\ x ~|~ c ~|~ C ~|~ T \\
    |&\ \tF\:\rep{x} & \text{$0 < |x|$} \\
    |&\ \tD \\
  \tF =&\ x ~|~ c ~|~ C ~|~ \ofix{\overline{f/k{:}T:=\tD}}{f_j}
\end{align*}

\subsection{Eta Reduction to Expose Fixpoint}\label{sec:eta-reduction}

\begin{gather*}
  \text{etared-fix:}~
    \dfrac{
      E[\Gamma] \vdash t : \forall \overline{x{:}T}.\: U \quad
      \text{$\overline{x}$ does not occur in $t$} \quad
      \text{$t$ is a fixpoint}
    }{E[\Gamma] \vdash \lam{\overline{x{:}T}}{t\: \overline{x}}
                       \reltri
                       t
    }
\end{gather*}
{\small Note:
\begin{itemize}
  \item We require the types of arguments of $t$ as $\overline{T}$ to prevent this transfomation changes the type.
  \item The premise ``$t$ is a fixpoint'' guarantees the result is not partial application.
\end{itemize}}

This transformation is intended to remove eta-redexes introduced by static arguments and eta expansion (\secref{sec:eta-expand-funcs}).
For example, assume the standard list concatenation function,
$\textrm{app}: \forall A, \textrm{list}\:A \rightarrow \textrm{list}\:A \rightarrow \textrm{list}\:A$,
is monomorphized to $\textrm{bool}$.

\begin{align*}
  & \textrm{app}\:\textrm{bool} \\
  \reltri_\textrm{inline}\; & (\lam{A}{(\kwfix \ldots)})\:\textrm{bool} \\
  \reltri_\textrm{eta-expansion}\; & \lam{l}{\lam{m}{(\lam{A}{(\kwfix \ldots)})\:\textrm{bool}\:l\:m}} \\
  \reltri_\textrm{V-normalization}\; & \lam{l}{\lam{m}{\letin{T}{\textrm{bool}}{(\lam{A}{(\kwfix \ldots)})\:T\:l\:m}}} \\
  \reltri_\textrm{S-normalization}\; & \lam{l}{\lam{m}{\letin{T}{\textrm{bool}}{(\kwfix \ldots)\:l\:m}}} \\
  \reltri_\textrm{Type-nomalization}\; & \lam{l}{\lam{m}{\letin{T}{\textrm{bool}}{(\kwfix \ldots)\:l\:m}}} & \textrm{(expand $T$ in the \kwfix-term)} \\
  \reltri_\textrm{unused-letin-deletion}\; & \lam{l}{\lam{m}{(\kwfix \ldots)\:l\:m}} \\
  \reltri_\textrm{eta-reduction}\; & (\kwfix \ldots) \\
\end{align*}

The code generator (\secref{sec:c-code-gen}) generates multiple C functions (\secref{sec:genfunm}) from the pre-eta-reduction term, $\lam{l}{\lam{m}{(\kwfix \ldots)\:l\:m}}$.
This eta-reduction avoid this.
The code generator generates single C function (\secref{sec:genfuns}) from post-eta-reduction term, $(\kwfix \ldots)$.

\subsection{Argument Completion}\label{sec:argcomp}
Argument completion removes partial applications by applying eta expansions.

\begin{gather*}
  \text{argcomp-papp:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is not an application} \\
        0 < |x| \\
        E[\Gamma] \vdash t : \forall \rep{(y{:}T)}\:\rep{(z{:}T')}, U \\
        |x| = |y| \\
        \text{$U$ is an inductive type}
      \end{gathered}
    }{E[\Gamma] \vdash
        t\:\rep{x}
        \reltri_K
        \lam{\rep{z{:}T'}}{t\:\rep{x}\:\rep{z}}
    } \\[1em]
  \text{argcomp-cnst-cstr:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is a constant or constructor} \\
        E[\Gamma] \vdash t : \forall \rep{z{:}T}, U \\
        \text{$U$ is an inductive type}
      \end{gathered}
    }{E[\Gamma] \vdash
        t
        \reltri_K
        \lam{\rep{z{:}T}}{t\:\rep{z}}
    }
\end{gather*}

$K$ is a non-application context as in \secref{sec:call-site-replacement}.

This transformation makes the result of an application inductive type.
Also, constants and constructors are always fully applied to arguments.

\begin{align*}
  \tD =&\ \lamT{x}{T}{\tD'} \\
      |&\ \ofix{\overline{f/k{:}T:=\tD}}{f_j} \\
  \tD' =&\ \tD \\
       |&\ \tL & \text{the type of $\tL$ is an inductive type} \\
  \tL =&\ \letinM{x}{\tM:T}{\tM} \\
  \tM =&\ \omatch{x}{\overline{C\:\overline{x}\Rightarrow \tL}} \\
      |&\ \tE \\
  \tE =&\ x \\
    |&\ c ~|~ C & \text{The type of $c$ and $C$ are inductive type} \\
    |&\ \tF\:\rep{x} & \text{$0 < |x|$, the type of $\tF\:\rep{x}$ is inductive type}  \\
    |&\ \tD \\
  \tF =&\ x ~|~ c ~|~ C ~|~ \ofix{\overline{f/k{:}T:=\tD}}{f_j}
\end{align*}

\subsection{Monomorphism Check}\label{sec:check-monomorphism}

We check the transformed term is a monomorphic term.

Although our transformations removes many rank-1 polymorphism,
it still possible to retain polymorphic term.
For example, our transformations don't remove polymorphic recursion unless
the recursion is completely unrolled.

This step checks
(1) all type annotations are inductive or function types without free variables, and
(2) types and sorts doesn't occur at expression.

\begin{align*}
  \tD =&\ \lamT{x}{T}{\tD'} \\
      |&\ \ofix{\overline{f/k{:}T:=\tD}}{f_j} \\
  \tD' =&\ \tD \\
       |&\ \tL & \text{the type of $\tL$ is an inductive type} \\
  \tL =&\ \letinM{x}{\tM:T}{\tM} \\
  \tM =&\ \omatch{x}{\overline{C\:\overline{x}\Rightarrow \tL}} \\
      |&\ \tE \\
  \tE =&\ x ~|~ c ~|~ C & \leftarrow \text{$T$ is removed} \\
    |&\ \tF\:\rep{x} & \text{$0 < |x|$} \\
    |&\ \tD \\
  \tF =&\ x ~|~ c ~|~ C ~|~ \ofix{\overline{f/k{:}T:=\tD}}{f_j}
\end{align*}

\subsection{Borrow Check}\label{sec:borrow-check}

We define two judgements $E[\Gamma'] \vdash t:T~|~B$ and $E[\Gamma'] \vdash t:T~|~(L, B^\text{used}, B^\text{result})$ for borrow check.
$\Gamma'$ is an annotated local context.
It is a list of $\lassum{x^B}{T}$ and $\ldef{x^B}{t}{T}$.
The variable $x$ is annotated with a borrow information $B$.
$B$ is a set of pair of borrow type and linear variable, such as $\{\overline{(T,x)}\}$.
$B^\text{used}$ and $B^\text{result}$ are also borrow information.
$L$ is a set of linear variables.
$T$ is the type of $t$.

We omit $:T$ in a rule which does not use $T$.

The borrow information $B=\{\overline{(T,x)}\}$ represents a linear variable $x_i$ is used via borrow type $T_i$.
$\lassum{x^{\{(T',y)\}}}{T}\in \Gamma'$ represents $x$ may contain a value of type $T'$ which is a (part of) content of the linear variable $y$.

$E[\Gamma'] \vdash t~|~B$ means a function $t$ may use linear variables via borrow $B$.

$E[\Gamma'] \vdash t~|~(L, B^\text{used}, B^\text{result})$ means an expression $t$
(1) consumes linear variables $L$,
(2) may use linear values via borrow $B^\text{used}$,
(3) result value may contain linear values via borrow $B^\text{result}$.

For example, assume linear list \lstinline!lseq!, borrow list \lstinline!bseq! which has constructors \lstinline!bnil! and \lstinline!bcons!,
borrow function \lstinline!borrow : lseq nat -> bseq nat!.
In a code fragment \\
\lstinline!let y := borrow x in match y with bnil => true | bcons h t => false end! contains variables
\lstinline!x : lseq nat!,
\lstinline!y : bseq nat!,
\lstinline!h : nat!, and
\lstinline!t : bseq nat!.
\texttt{y} and \texttt{t} contain a \texttt{bseq nat} value borrowed from \texttt{x}.
It is represented as
$\texttt{y}^{\{(\texttt{bseq nat},\texttt{x})\}}:\text{\texttt{bseq nat}}$ and
$\texttt{t}^{\{(\texttt{bseq nat},\texttt{x})\}}:\text{\texttt{bseq nat}}$.
The type of \texttt{h} is \texttt{nat}.
Since \texttt{nat} is not a borrow type, \texttt{h} lives even after \texttt{x} is consumed.

\begin{gather*}
  \text{borrow-lvar:}~
    \dfrac
    {
      \lassum{x^B}{T} \in \Gamma' \quad \text{$x$ is linear}
    }{
      E[\Gamma'] \vdash x ~|~ (\{x\}, B, B)
    } \\
  \text{borrow-var:}~
    \dfrac
    {
      \lassum{x^B}{T} \in \Gamma' \quad \text{$x$ is not linear}
    }{
      E[\Gamma'] \vdash x ~|~ (\varnothing, B, B)
    } \\
  \text{borrow-constant:}~
    \dfrac
    {
      \text{$c$ is not a borrow function}
    }{
      E[\Gamma'] \vdash c ~|~ (\varnothing, \varnothing, \varnothing)
    } \\
  \text{borrow-constructor:}~
    E[\Gamma'] \vdash C ~|~ (\varnothing, \varnothing, \varnothing) \\
  \text{borrow-letin:}~
    \dfrac
    {
      \begin{gathered}
        E[\Gamma'] \vdash t_1 ~|~ (L_1, B^\text{used}_1, B^\text{result}_1) \\
        E[\Gamma';\ldef{x^{B^\text{result}_1}}{t_1}{T}] \vdash t_2 ~|~ (L_2, B^\text{used}_2, B^\text{result}_2) \\
        L_1 \cap L_2 = \varnothing \\
        \text{$x$ is linear} \rightarrow x \in L_2 \\
        L_1 \cap B^\text{used}_2 = \varnothing
      \end{gathered}
    }{
      E[\Gamma'] \vdash \letin{x}{t_1:T}{t_2} ~|~ (L_1\cup L_2 - \{x\}, B^\text{used}_1\cup B^\text{used}_2 - \{x\}, B^\text{result}_2 - \{x\})
    } \\
  \text{borrow-match:}~
    \dfrac{
      \begin{gathered}
        E[\Gamma'] \vdash y ~|~(L_\text{item}, B^\text{used}_\text{item}, B^\text{result}_\text{item}) \\
        B_{ij} = B^\text{result}_\text{item} ~\text{filtered with the type of $x_{ij}$} \\
        \overline{\Gamma' = \overline{\lassum{x^{B}}{T}}} \\
        \overline{\underline{E}[\underline{\Gamma'} ; \Gamma'] \vdash t ~|~(L, B^\text{used}, B^\text{result})} \\
        % M stands for member (of constructor).
        % F stands for free variable.
        \overline{L^\text{M} = L \cap \{\overline{x}\}} \quad
        \overline{L^\text{F} = L - \{\overline{x}\}} \\
        \overline{L^\text{M} = \{ z ~|~ z \in \{\overline{x}\} ~\wedge~ \text{$z$ is linear} \}} \\
        \bigwedge_i L^\text{F}_1 = L^\text{F}_i \quad
        L_\text{item} \cap L^{F}_1 = \varnothing \\
        \overline{{B'}^\text{used} = B^\text{used} - \{\overline{x}\}} \quad
        \overline{{B'}^\text{result} = B^\text{result} - \{\overline{x}\}} \\
        B^\text{used} = \bigcup_i {B'}^\text{used}_i \quad
        B^\text{result} = \bigcup_i {B'}^\text{result}_i \quad
        L_\text{item} \cap B^\text{used} = \varnothing \\
      \end{gathered}
    }{
      E[\Gamma'] \vdash \omatch{y}{\overline{C\: \overline{x} \Rightarrow t}} ~|~ (L_\text{item} \cup L^\text{F}_1, B^\text{used}_\text{item} \cup B^\text{used}, B^\text{result})
    } \\
  \text{borrow-var-app:}~
    \dfrac{
      \begin{gathered}
        \lassum{f^{B}}{T'} \in \Gamma' \quad
        \APP(\Gamma', B, \overline{x}, T, L, B^\text{used}, B^\text{result})
      \end{gathered}
    }{
      E[\Gamma'] \vdash f\:\overline{x} : T ~|~ (L, B^\text{used}, B^\text{result})
    } \\
  \text{borrow-constant-app:}~
    \dfrac{
      \begin{gathered}
        \text{$c$ is not a borrow function} \quad
        \APP(\Gamma', \varnothing, \overline{x}, T, L, B^\text{used}, B^\text{result})
      \end{gathered}
    }{
      E[\Gamma'] \vdash c\:\overline{x} : T ~|~ (L, B^\text{used}, B^\text{result})
    } \\
  \text{borrow-constructor-app:}~
    \dfrac{
      \APP(\Gamma', \varnothing, \overline{x}, T, L, B^\text{used}, B^\text{result})
    }{
      E[\Gamma'] \vdash C\: \overline{x} : T ~|~ (L, B^\text{used}, B^\text{result})
    } \\
  \text{borrow-fix-app:}~
    \dfrac{
      \begin{gathered}
        E[\Gamma'] \vdash \ofix{\overline{f:=t}}{f_j} ~|~ B \quad
        \APP(\Gamma', B, \overline{x}, T, L, B^\text{used}, B^\text{result})
      \end{gathered}
    }{
      E[\Gamma'] \vdash (\ofix{\overline{f:=t}}{f_j})\:\overline{x} : T ~|~ (L, B^\text{used}, B^\text{result})
    } \\
  \text{borrow-borrow:}~
    \dfrac{
      \begin{gathered}
        \text{$c$ is a borrow function} \\
        E[\Gamma'] \vdash c : T^\text{arg} \rightarrow T^\text{result} \quad
        \text{$T^\text{arg}$ is a linear type} \quad
        \text{$T^\text{result}$ is a borrow type} \\
        \text{$T^\text{result}$ does not contain function} \\
        \text{$\{\overline{T}\}$ is a set of borrow types contained in $T^\text{result}$} \\
        B = \{\overline{(T,\underline{x})}\}
      \end{gathered}
    }{
      E[\Gamma'] \vdash c\:x ~|~ (\varnothing, B, B)
    } \\
  \text{borrow-fix-clo:}~
    \dfrac{
      E[\Gamma'] \vdash \ofix{\overline{f:=t}}{f_j} ~|~ B
    }{
      E[\Gamma'] \vdash \ofix{\overline{f:=t}}{f_j} ~|~ (\varnothing, B, B)
    } \\
  \text{borrow-abs-clo:}~
    \dfrac{
      E[\Gamma'] \vdash \lam{x}{t} ~|~ B
    }{
      E[\Gamma'] \vdash \lam{x}{t} ~|~ (\varnothing, B, B)
    } \\
\end{gather*}

\begin{gather*}
  \text{borrow-abs-fun:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is not an abstraction} \\
        \text{$t$ is not a fixpoint} \\
        E[\Gamma';\overline{\lassum{x^\varnothing}{T}}] \vdash t : T ~|~ (L,B^\text{used},B^\text{result}) \\
        \{ z | z \in \{\overline{x}\} \wedge \text{$z$ is linear} \} = L \\
        B' = (B^\text{used} - \{\overline{x}\}) ~\text{filtered with the type of $T$} \\
      \end{gathered}
    }{
      E[\Gamma'] \vdash \lam{\overline{x{:}T}}{t} ~|~ B'
    } \\
  \text{borrow-abs-fix:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is a fixpoint} \\
        E[\Gamma';\overline{\lassum{x^\varnothing}{T}}] \vdash t ~|~ B \\
        \forall z \in \{\overline{x}\}~ \text{$z$ is not linear} \\
      \end{gathered}
    }{
      E[\Gamma'] \vdash \lam{\overline{x{:}T}}{t} ~|~ B
    } \\
  \text{borrow-fix-fun:}~
    \dfrac{
      \begin{gathered}
        E[\Gamma';\overline{\lassum{f^\varnothing}{T}}] \vdash t_i ~|~ B_i \\
        B = \bigcup_i B_i
      \end{gathered}
    }{
      E[\Gamma'] \vdash \ofix{\overline{f{:}T:=t}}{f_j} ~|~ B
    }
\end{gather*}

\begin{align*}
  &\APP(\Gamma', B, \overline{x}, T, L, B^\text{used}, B^\text{result}) \\
  &= 1 \leq n \\
  &~\wedge \forall 1 \leq i \leq n, \forall 1 \leq j \leq n, (i \neq j \rightarrow \neg (x_i = x_j \wedge \text{$x_i$ is linear})) \\
  &~\wedge L = \{ x_i | 1 \leq i \leq n \wedge \text{$x_i$ is linear} \} \\
  &~\wedge B^\text{used} = B \cup \{ B' | 1 \leq i \leq n \wedge \lassum{x_i^{B'}}{T'} \in \Gamma' \} \\
  &~\wedge B^\text{result} = B^\text{used} ~\text{filtered with the type $T$} \\
  &~\wedge B^\text{used} \cap L = \varnothing \\
  &\text{where} \quad n = |x|
\end{align*}

We mix borrow information and set of variables in set-operations.
Assume $L=\{x_1,\ldots,x_n\}$ and $B=\{(T_1,y_1),\ldots,(T_m,y_m)\}$.

\begin{align*}
  B \cap L = L \cap B &= \{(T_i,y_i) \in B ~|~ 1\leq i\leq m,~ y_i \in L \} \\
  B - L &= \{(T_i,y_i) \in B ~|~ 1\leq i\leq m,~ y_i \not\in L \}
\end{align*}

{\small Note:
\begin{itemize}
  \item borrow-fix-fun annotates $f_1^\varnothing \ldots f_n^\varnothing$.
    This is not correct because $f_1\ldots f_n$ may refer borrowed values via free variables in
    $\ofix{\overline{f{:}T:=t}}{f_j}$.
    However, it is harmless because corresponding linear value cannot be consumed in the fix-term.
\end{itemize}}

\subsection{C Variable Allocation}\label{sec:cvaralloc}

\begin{align*}
  x :&\ \mbox{\gallina{} variable} \\
  v :&\ \mbox{C variable} \\
  V =&\ \mathit{empty} ~|~ x \mapsto v ~|~ V;V
\end{align*}

\begin{itemize}
  \item $\cv{t}{x_1\ldots x_n}{V}$ is the variable mapping of the variables declared in $t$.
  \item $x_1\ldots x_n$ are arguments for $t$.
  \item $V$ is the variable mapping for variables declared outside.
\end{itemize}
\[
  \cv{t}{x_1\ldots x_n}{V} =
  \begin{cases}
    empty                                             & (t = x) \vee (t = c) \vee (t = C) \vee (t = T) \\
    \cv{u}{}{V; M}; M                                & (t = \lam{x}{u}) \wedge (n = 0) \quad \text{where}~M = x\mapsto v \\
    \cv{u}{x_2\ldots x_n}{V; M}; M                    & (t = \lam{x}{u}) \wedge (n > 0) \quad \text{where}~M = x\mapsto V(x_1) \\
    \cv{u}{x_0\:x_1\ldots x_n}V                        & t = u\:x_0 \\
    \cv{t_1}{}{V}; \cv{t_2}{x_1\ldots x_n}{V; M}; M    & t = \letin{x}{t_1}{t_2} \quad \text{where}~M = x\mapsto v \\
    \begin{aligned}[t]
      (&\cv{t_1}{x_1\ldots x_n}{V;M_1};\ldots; \\
       &\cv{t_h}{x_1\ldots x_n}{V;M_h}; \\
       &M_1;\ldots;M_h)
    \end{aligned} &                                   \begin{aligned}[t]
                                                        &t = \match{x}{C_i}{\lambda y_{i1}\ldots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\ldots h} \\
                                                        &\text{where}~M_i = y_{i1}\mapsto v_{i1}; \ldots; y_{i\NM_{C_i}}\mapsto v_{i\NM_{C_i}}
                                                      \end{aligned} \\
    \cv{t_1}{}{V;M}; \ldots; \cv{t_h}{}{V;M}; M &    \begin{aligned}[t]
                                                        &t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
                                                        &\text{where}~M = f_1\mapsto v_1;\ldots; f_h\mapsto v_h
                                                      \end{aligned}
  \end{cases}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$v, v_i, v_{ij}$ are fresh C variables}
  \end{aligned}
\]
{\small Note: \quad We consider \gallina{} variables unique.}

\section{C Code Generation}\label{sec:c-code-gen}
\subsection{The \gallina{} Subset For C Code Generation}\label{sec:gallinasubsetforcgen}
\begin{gather*}
  E[\Gamma] \vdashb x \qquad
  E[\Gamma] \vdashb c \qquad
  E[\Gamma] \vdashb C \\
  \dfrac{
    E[\Gamma] \vdashb t \quad
    E[\Gamma] \vdash x : T \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashb t\:x
  } \\
  \dfrac{
    E[\Gamma] \vdashb t \quad
    E[\Gamma;\ldef{x}{t}{T}] \vdashb u \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashb \letin{x}{t:T}{u}
  } \\
  \dfrac{
    \begin{gathered}
      E[\Gamma] \vdash x:T \quad
      \text{$T$ is a non-dependent inductive type with $p$ parameters:}~I\:u_1\ldots u_p \\
      E[] \vdash C_i\:u_1\ldots u_p: T_{i1} \rightarrow \dotsb \rightarrow T_{i\NM_{C_i}} \rightarrow T \quad
      \text{$T_{ij}$ are non-dependent inductive types} \\
      E[\Gamma;\lassum{y_{i1}}{T_{i1}};\ldots;\lassum{y_{i\NM_{C_i}}}{T_{i\NM_{C_i}}}] \vdashb t_i
    \end{gathered}
  }{
    E[\Gamma] \vdashb \match{x}{C_i}{\lambda y_{i1}\ldots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\ldots h}
  } \\
  \dfrac{
    E[\Gamma;\lassum{x}{T}] \vdashb t \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashb \lamT{x}{T}{t}
  } \\
  \dfrac{
    E[\Gamma] \vdashf \fix{f_i:T_i}{t_i}{i=1\ldots h}{f_j}
  }{
    E[\Gamma] \vdashb \fix{f_i:T_i}{t_i}{i=1\ldots h}{f_j}
  } \\
  \\
  \dfrac{
    E[\Gamma] \vdash t : T \quad
    \text{$T$ is a non-dependent inductive type} \quad
    E[\Gamma] \vdashb t
  }{
    E[\Gamma] \vdashf t
  } \\
  \dfrac{
    E[\Gamma;\lassum{x}{T}] \vdashf t \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashf \lamT{x}{T}{t}
  } \\
  \dfrac{
    E[\Gamma;\lassum{f_1}{T_1};\ldots;\lassum{f_h}{T_h}] \vdashf t_i
  }{
    E[\Gamma] \vdashf \fix{f_i:T_i}{t_i}{i=1\ldots h}{f_j}
  }
\end{gather*}

\subsection{Detection of Inlinable Fixpoints}\label{sec:inlinable-fixpoint-detection}
We detect inlinable fixpoints.
``Inlinable fixpoint'' means a fixpoint, $\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_j}$,
which all application to $f_i$ is located at the tail positions of $f_1\ldots f_h$.
In this case, the continuation of the applications to $f_1\ldots f_h$
in $\letin{x}{(\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_j})\;x_1\ldots x_n}{u}$
are always $\letin{x}{\Box}{u}$.
Thus, we can translate the tail positions of $f_1\ldots f_h$ to
(1) assignments to the arguments of $f_i$ and $\kwgoto{}\;f_i$ for application to $f_i$ and
(2) assignment to $x$ and $\kwgoto{}\;u$ otherwise.
This translation is equivalent to inlining a recursive function, which means generating a loop at a non-tail position.

$\TR{t}{n}$ is the first element of $\RNT{t}{n}$.
$(R,N,T) = \RNT{t}{n}$ classify variables in $t$ assuming that it is called with $n$ arguments as $t\:x_1\ldots x_n$:
\begin{align*}
  R &: \text{tail-recursive fixpoint bounded functions that do not need to be real functions} \\
  N &: \text{free variables at non-tail positions of $t$} \\
  T &: \text{free variables at tail positions of $t$}
\end{align*}
``tail position'' is extended to the function position of the application at a tail position. \\
$R$ distinguishes fixpoint bounded functions translatable without actual functions (but with \kwgoto{}) or not.
\[ \TR{t}{n} = R \quad \text{where}\quad (R,N,T) = \RNT{t}{n} \]
\begin{align*}
  &\RNT{t}{n} = \\
  &\begin{cases}
    (\varnothing, \varnothing, \{x\})             & t = x \\
    (\varnothing, \varnothing, \varnothing)         & (t = c) \vee (t = C) \\
    (R, N \cup \{x\}, T)         & t = u\:x \quad \text{where}\quad (R,N,T) = \RNT{u}{n+1} \\
    (R_1 \cup R_2, N_1 \cup T_1 \cup N_2 - \{x\}, T_2 - \{x\})        &
      \begin{aligned}[t]
        & t = \letin{x}{t_1}{t_2} \\
        & \text{where}\quad (R_1,N_1,T_1) = \RNT{t_1}{0} \quad (R_2,N_2,T_2) = \RNT{t_2}{n}
      \end{aligned} \\
    \bigl(\bigcup_{i=1}^h R_i, \bigcup_{i=1}^h N_i, \bigcup_{i=1}^h T_i \bigr)         &
      \begin{aligned}[t]
        & t = \match{x}{C_i}{t_i}{i=1\ldots h} \\
        & \text{where}~(R_i, N_i, T_i) = \RNT{t_i}{n+\NM_{C_i}}
      \end{aligned} \\
    (R, N-\{x\}, T - \{x\})                                           & (t = \lam{x}{u}) \wedge (n > 0) \quad \text{where}\quad  (R, N, T) = \RNT{u}{n-1} \\
    (R, (N \cup T) - \{x\}, \varnothing)                             & (t = \lam{x}{u}) \wedge (n = 0) \quad \text{where}\quad  (R, N, T) = \RNT{u}{\NA_u} \quad \text{(closure)} \\
    \begin{aligned}[t]
      \bigl( & \textstyle\bigcup_{i=1}^h R_i \cup \{f_1,\dotsc, f_h\}, \\
             & \textstyle\bigcup_{i=1}^h N_i - \{f_1,\dotsc, f_h\}, \\
             & \textstyle\bigcup_{i=1}^h T_i - \{f_1,\dotsc, f_h\} \bigr)
    \end{aligned} &
      \begin{aligned}[t]
        & (t = \fix{f_i}{t_i}{i=1\ldots h}{f_j}) \\
        & {} \wedge (n = \NA_t) \wedge \bigl(\textstyle\bigcup_{i=1}^h N_i \cap \{f_1,\dotsc, f_h\} = \varnothing\bigr) \\
        & \text{where}\quad (R_i, N_i, T_i) = \RNT{t_i}{\NA_{t_i}}
      \end{aligned} \\
    \begin{aligned}[t]
      \bigl( & \textstyle\bigcup_{i=1}^h R_i, \\
             & \textstyle\bigcup_{i=1}^h (N_i \cup T_i) - \{f_1,\dotsc, f_h\}, \\
             & \varnothing \bigr)
    \end{aligned} &
      \begin{aligned}[t]
        & (t = \fix{f_i}{t_i}{i=1\ldots h}{f_j}) \quad \text{(real function, maybe closure)} \\
        & {} \wedge \neg \bigl((n = \NA_t) \wedge \bigl(\textstyle\bigcup_{i=1}^h N_i \cap \{f_1,\dotsc, f_h\} = \varnothing\bigr)\bigr) \\
        & \text{where}\quad (R_i, N_i, T_i) = \RNT{t_i}{\NA_{t_i}}
      \end{aligned}
  \end{cases}
\end{align*}
{\small Note:
\begin{itemize}
  \item The variables in $t$ are unique.
    \codegen{} uses de Bruijn's indexes for $N$ and $T$;
    the variables renamed by \secref{sec:cvaralloc} for $R$.
  \item $x$ of $\match{x}{C_i}{t_i}{i=1\ldots h}$ is not counted because $x$ is not a function and does not affect the final result.
\end{itemize}}

\subsection{Top-Level Functions Detection}\label{sec:top-level-function-detection}
If a fixpoint needs recursive call in C, we need a real C function for it.
\codegen{} detects such fixpoints by simulating $A_K$ and $B_K$ in \secref{sec:AK} and \secref{sec:BK} to collect application of fixpoint-bounded functions.

\subsection{Outer-Variable}\label{sec:outer-variable}

\subsection{Translation to C for a Non-Tail Position}\label{sec:AK}
$\A{K}{t}{x_1\ldots x_n}$ generates C code for $t\:x_1\ldots x_n$ in a non-tail position.
The result expression is passed to $K$. \\
$K(e) = \dq{v = e\ttsemi}$ in simple situations.
\begin{align*}
  &\A{K}{x}{} = K(\dq{x}) \\
  &\A{K}{x}{x_1\ldots x_n} =
      \begin{aligned}[t] \ldq & {\passign(\fvarsd{x}, x_1 \ldots x_n)} \\ & \kwgoto\:\mathtt{entry\_}x\ttsemi \rdq \end{aligned}
    && \begin{aligned}[t] & (n > 0) \wedge \text{$x$ is bounded by a fixpoint} \wedge {} \\ & x \in \tr \end{aligned} \\
  &\A{K}{x}{x_1\ldots x_n} = K(\dq{x\ttparen{y_1\ttcomma\dotsc\ttcomma y_o\ttcomma x_1\ttcomma\dotsc\ttcomma  x_n}})
    && \begin{aligned}[t] & (n > 0) \wedge \text{$x$ is bounded by a fixpoint} \wedge {} \\ & x \not\in \tr \end{aligned} \\
  &\A{K}{c}{x_1\ldots x_n} = K(\dq{c\ttparen{x_1\ttcomma\dotsc\ttcomma x_n}})                                   && n \geq 0 \\
  &\A{K}{C}{x_1\ldots x_n} = K(\dq{C\ttparen{x_1\ttcomma\dotsc\ttcomma x_n}})                                   && n \geq 0 \\
  &\A{K}{t\:x_0}{x_1\ldots x_n} = \A{K}{t}{x_0\:x_1\ldots x_n} \\
  &\A{K}{\letin{x}{t_1}{t_2}}{x_1\ldots x_n} =
      \begin{aligned}[t] \ldq & \A{K'}{t_1}{} \\ & \A{K}{t_2}{x_1\ldots x_n} \rdq \end{aligned}
    && \text{where}\quad K'(e) = \dq{x\:\tteq\:e\ttsemi} \\
  &\A{K}{\lam{x}{t}}{x_1\:x_2\ldots x_n} = \A{K}{t}{x_2\ldots x_n}                                  && \text{($x$ and $x_1$ are mapped to the same C variable)} \\
  &\AbreakEq{K}{\match{x}{C_i}{\lambda y_{i1}\ldots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\ldots h}}{x_1\ldots x_n} && \text{where}\quad x : T \\
     & \quad\begin{alignedat}{2}
       \ldq & \kwswitch\:\ttparen{\mathit{swfunc}_T\ttparen{x}}\:\ttlbrace \\
            & \cdots \\
            & \mathit{caselabel}_{C_i}\ttcolon\quad
              \begin{aligned}[t]
              & y_{i1}\:\tteq\:\mathit{get\_member}_{C_i1}(x)\ttsemi \:\ldots\ttsemi \\
              & y_{i\NM_{C_i}}\:\tteq\:\mathit{get\_member}_{C_i\NM_{C_i}}(x)\ttsemi \\
              & \mathit{linear\_dealloc}_{T}(x)\ttsemi \\
              & {\A{K}{t_i}{x_1\ldots x_n}} \\
              & \kwbreak\ttsemi
              \end{aligned} \\
            & \cdots \\
            & \ttrbrace\rdq
       \end{alignedat} \\
  &\A{K}{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}{x_1\ldots x_n} =                   && f_j \in \tr \\
     & \quad\begin{alignedat}[t]{2}
       \ldq & \passign(\fvars{t_j}, x_1\ldots x_n) \\
            & {\genbodyat{K'}{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}} \\
            & \mathtt{exit\_}f_j\ttcolon \rdq
       \end{alignedat} &&
               \begin{alignedat}[t]{1}
                  & \text{where} \\
                  & K'(e) =
                    \begin{cases}
                    K(e) & \text{$K(e)$ contains \kwgoto}  \\
                    \begin{aligned}[t]
                      \ldq & K(e) \\
                           & \kwgoto\:\mathtt{exit\_}f_j\ttsemi \rdq
                    \end{aligned} & \text{otherwise}
                  \end{cases}
                \end{alignedat} \\
  &\A{K}{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}{x_1\ldots x_n} =                      && f_j \not\in \tr \\
     & \quad\begin{alignedat}[t]{2}
       \ldq & K(f_j\ttparen{y_1\ttcomma\dotsc\ttcomma y_o\ttcomma x_1\ttcomma\dotsc\ttcomma x_n})                  \\
            & \kwgoto\:\mathtt{skip\_}f_j\ttsemi                                    \\
            & {\genbodyan{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}}                          \\
            & \mathtt{skip\_}f_j\ttcolon \rdq
       \end{alignedat}
\end{align*}
{\small Note:
\begin{itemize}
  \item $\dq{\cdots}$ means a string.
    A string can contain characters in typewriter font and expressions starting in italic or roman font.
    The former is preserved as-is.
    The latter embeds the value of the expression (with name translation from \gallina{} to C).
  \item \gallina{} types, constants, and constructors have corresponding (user-configurable) C names and they are implicitly translated.
    \gallina{} variables are translated by the mapping defined in \secref{sec:cvaralloc}.
  \item $\tr = \TR{t}{n}$ where the translating function is defined as \kwDefinition~$c := t$ and $t$ is an $n$-arguments function.
  \item $\mathit{swfunc}_T, \mathit{caselabel}_{C_i}$, and $\mathit{get\_member}_{C_i j}$ are defined by a user to translate \kwmatch-expressions for the inductive type $T$.
  \item $\passign(y_1\ldots y_n, x_1\ldots x_n)$ is a parallel assignment. It is translated to a sequence of assignments to assign $x_1\ldots x_n$ into $y_1\ldots y_n$.  It may require temporary variables.
  \item $y_1,\dotsc,y_o$ are the outer variables of the fixpoint.
  \item We do not define $\A{K}{\lam{x}{t}}{}$ because we do not support closures yet.
  \item Actual \codegen{} generates $\genbodyan{}$ in a different position to avoid the label $\mathtt{skip\_}f_j$ and $\kwgoto\:\mathtt{skip\_}f_j\ttsemi$.
  \item $\mathit{linear\_dealloc}_{T}(x)$ is the deallocation function for the linear type $T$.  It is empty for unrestricted types.
\end{itemize}}

\subsection{Translation to C for a Tail Position}\label{sec:BK}
$\B{K}{t}{x_1\ldots x_n}$ generates C code for $t\:x_1\ldots x_n$ in a tail position.
The result expression is passed to $K$. \\
$K(e) = \dq{\kwCreturn\:e\ttsemi}$ in simple situations.
\begin{align*}
  &\B{K}{x}{} = K(\dq{x}) \\
  &\B{K}{x}{x_1\ldots x_n} = \begin{aligned}[t] \ldq & {\passign(\fvarsd{x}, x_1\ldots x_n)} \\ & \kwgoto\:\mathtt{entry\_}x\ttsemi \rdq \end{aligned}
    && (n > 0) \wedge \text{$x$ is bounded by a fixpoint} \\
  &\B{K}{c}{x_1\ldots x_n} = K(\dq{c\ttparen{x_1\ttcomma\dotsc\ttcomma x_n}})                                   && n \geq 0 \\
  &\B{K}{C}{x_1\ldots x_n} = K(\dq{C\ttparen{x_1\ttcomma\dotsc\ttcomma x_n}})                                   && n \geq 0 \\
  &\B{K}{t\:x_0}{x_1\ldots x_n} = \B{K}{t}{x_0\:x_1\ldots x_n} \\
  &\B{K}{\letin{x}{t_1}{t_2}}{x_1\ldots x_n} =
      \begin{aligned}[t] \ldq & \A{K'}{t_1}{} \\ & \B{K}{t_2}{x_1\ldots x_n} \rdq \end{aligned}
    && \text{where}\quad K'(e) = \dq{x\:\tteq\:e\ttsemi} \\
  &\B{K}{\lam{x}{t}}{x_1\:x_2\ldots x_n} = \B{K}{t}{x_2\ldots x_n}                                 && \text{($x$ and $x_1$ are mapped to the same C variable)} \\
  &\BbreakEq{K}{\match{x}{C_i}{\lambda y_{i1}\ldots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\ldots h}}{x_1\ldots x_n} && \text{where}\quad x : T \\
     & \quad\begin{alignedat}{2}
       \ldq & \kwswitch\:\ttparen{\mathit{swfunc}_T\ttparen{x}}\:\ttlbrace \\
            & \cdots \\
            & \mathit{caselabel}_{C_i}\ttcolon\quad
              \begin{aligned}[t]
                & y_{i1}\:\tteq\:\mathit{get\_member}_{C_i1}(x)\ttsemi \:\ldots\ttsemi \\
                & y_{i\NM_{C_i}}\:\tteq\:\mathit{get\_member}_{C_i\NM_{C_i}}(x)\ttsemi \\
                & \mathit{linear\_dealloc}_{T}(x)\ttsemi \\
                & {\B{K}{t_i}{x_1\ldots x_n}}
              \end{aligned} \\
            & \cdots \\
            & \ttrbrace\rdq
     \end{alignedat} \\
  &\B{K}{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}{x_1\ldots x_n} =       \\
     & \quad\begin{alignedat}{2}
       \ldq & {\passign(\fvars{t_j}, x_1\ldots x_n)} \\
            & {\genbodyb{K}{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}} \rdq
       \end{alignedat}
\end{align*}
{\small Note:
\begin{itemize}
  \item We do not define $\B{K}{\lam{x}{t}}{}$ because a tail position cannot be a function after the argument completion.
\end{itemize}}

\subsection{Auxiliary Functions for Translation to C}\label{sec:aux-function}
\[
  \fvars{t} =
  \begin{cases}
    \dq{x;\:\fvars{u}} & t = \lam{x}{u} \\
    \fvars{t_j}       & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
    \dq{}             & \text{otherwise}
  \end{cases}
\]
\[
  \fvarsd{f_i} = \fvars{t_i} \quad \text{for functions bounded by $\fix{f_i}{t_i}{i=1\ldots h}{f_j}$}
\]
\[
  \genbodyat{K}{t} =
  \begin{cases}
    \genbodyat{K}{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyat{K}{t_i}} & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
    \quad \text{for}~i=j, 1,\dotsc, (j-1), (j+1),\dotsc, h \\
    \A{K}{t}{}                            & \text{otherwise}
  \end{cases}
\]
\[
  \genbodyan{t} =
  \begin{cases}
    \genbodyan{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyan{t_i}} & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
    \quad \text{for}~i=1,\dotsc, h \\
    \B{K}{t}{}                            & \begin{aligned}[t]
                                            & \text{otherwise} \\
                                            & \text{where} \\
                                            & \quad t:T \\
                                            & \quad K(e) = \dq{\texttt{*($T$*)ret = $e$; \kwCreturn;}}
                                            \end{aligned}
  \end{cases}
\]
\[
  \genbodyb{K}{t} =
  \begin{cases}
    \genbodyb{K}{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyb{K}{t_i}} & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
    \quad \text{for}~i=j, 1,\dotsc, (j-1), (j+1),\dotsc, h \\
    \B{K}{t}{}                            & \text{otherwise}
  \end{cases}
\]
{\small Note:
\begin{itemize}
  \item $\fvarsop$ and $\fvarsop'$ returns a list of variables: $x_1;\ldots;x_n;$.  For simplicity, we omit ``$;$'' if not ambiguous.
  \item $\dq{g(i)}~\text{for}~i=j_1,\dotsc,j_n$ means $\dq{g(j_1)\:\ldots\:g(j_n)}$.
\end{itemize}}


\subsection{Translation for a Top-Level Function which is Translated to Multiple C Functions}\label{sec:genfunm}
$\genfunm{c}$ translates the function (constant) $c$ with one or more auxiliary functions.
We assume $c$ is defined as \kwDefinition~$c := t.$
The auxiliary functions $f_1 \ldots f_n$ are fixpoint bounded functions in $t$ which are invoked as functions.
We assume the types of them:
\begin{align*}
  c &: T_{01} \rightarrow \dotsb \rightarrow T_{0m_0} \rightarrow T_{00} \\
  f_i &: T_{i1} \rightarrow \dotsb \rightarrow T_{im_i} \rightarrow T_{i0} && i = 1\ldots n
\end{align*}
\[ \text{where} \quad \text{$T_{i0}$ are inductive types ($i=0\ldots n$)} \]
The formal arguments of $c$ are $x_{01}\ldots x_{0m_0} = \fvars{t}$ and
the formal arguments of $f_i$ are $x_{i1}\ldots x_{im_i} = \fvarsd{f_i}$.

$f_i$ invocation in C needs extra arguments, $y_{i1}\mathord{:}U_{i1} \ldots y_{io_i}\mathord{:}U_{io_i}$, addition to the actual arguments in \gallina{} application because the free variables of the fixpoint should also be passed.
If the free variables contain a function bounded by an outer fixpoint, the function itself is not passed but the free variables of the outer fixpoint are also passed.
We iterate it until no fixpoint functions.

\begin{alignat*}{2}
  \genfunm{c} &= \ldq && \enumentries{c}~\argstructdefs{c}~\forwarddecl{c}~\entryfunctions{c}~\bodyfunction{c} \rdq
\end{alignat*}
\[ \enumentries{c} = \dq{\kwenum\:\mathtt{enum\_func\_}c\:\ttbrace{ \mathtt{func\_}c\ttcomma \mathtt{func\_}f_1\ttcomma \dotsc\ttcomma \mathtt{func\_}f_n }\ttsemi} \]
\[ \argstructdefs{c} = \dq{\mainstructdef{c}\:\auxstructdef{c}{1} \ldots \auxstructdef{c}{n}} \]
\[ \mainstructdef{c} = \dq{\kwstruct\:\mathtt{arg\_}c\:\ttbrace{\:T_{01}\:\mathtt{arg}1\ttsemi \ldots\ttsemi\: T_{0m_0}\:\mathtt{arg}m_0\ttsemi\:}\ttsemi} \]
\[ \auxstructdef{c}{i} = \dq{\kwstruct\:\mathtt{arg\_}f_i\:\ttbrace{\:U_{i1}\:\mathtt{outer}1\ttsemi \ldots\ttsemi\: U_{io_i}\:\mathtt{outer}o_i\ttsemi\:T_{i1}\:\mathtt{arg}1\ttsemi \ldots\ttsemi\: T_{im_i}\:\mathtt{arg}m_i\ttsemi\:}\ttsemi} \]
\[ \forwarddecl{c} = \dq{\kwstatic\:\kwvoid\:\mathtt{body\_function\_}c\ttparen{\kwenum\:\mathtt{enum\_func\_}c\:\mathtt{g}\ttcomma \kwvoid\:\mathtt{\ttstar arg}\ttcomma \kwvoid\:\mathtt{\ttstar ret}}\ttsemi} \]
\[ \entryfunctions{c} = \dq{\mainfunction{c}\:\auxfunction{c}{1} \ldots \auxfunction{c}{n}} \]
\begin{alignat*}{2}
  \mainfunction{c} &= \ldq && \kwstatic\:T_{00}\:c\ttparen{T_{01}\:x_{01}\ttcomma\dotsc\ttcomma\, T_{0m_0}\:x_{0m_0}}\:\ttlbrace \\
  & && \quad \kwstruct\:\mathtt{arg\_}c\:\mathtt{arg}\:\tteq\:\ttbrace{ x_{01}\ttcomma\dotsc\ttcomma\, x_{0m_0} }\ttsemi\:T_{00}\:\mathtt{ret}\ttsemi \\
  & && \quad \mathtt{body\_function\_}c\ttparen{\mathtt{func\_}c\ttcomma \ttamp\mathtt{arg}\ttcomma \ttamp\mathtt{ret}}\ttsemi \kwCreturn\:\mathtt{ret}\ttsemi \\
  & && \ttrbrace \rdq
\end{alignat*}
\begin{alignat*}{2}
  \auxfunction{c}{i} &= \ldq && \kwstatic\:T_{i0}\:f_i\ttparen{U_{i1}\:y_{i1}\ttcomma\dotsc\ttcomma U_{io_i}\:y_{io_i}\ttcomma T_{i1}\:x_{i1}\ttcomma\dotsc\ttcomma T_{im_i}\:x_{im_i}}\:\ttlbrace \\
  & && \quad \kwstruct\:\mathtt{arg\_}f_i\:\mathtt{arg}\:\tteq\:\ttbrace{ y_{i1}\ttcomma\dotsc\ttcomma y_{io_i}\ttcomma x_{i1}\ttcomma\dotsc\ttcomma x_{im_i} }\ttsemi\:T_{i0}\:\mathtt{ret}\ttsemi\\
  & && \quad \mathtt{body\_function\_}c\ttparen{\mathtt{func\_}f_i\ttcomma \ttamp\mathtt{arg}\ttcomma \ttamp\mathtt{ret}}\ttsemi\:\kwCreturn\:\mathtt{ret}\ttsemi \\
  & && \ttrbrace \rdq
\end{alignat*}
\begin{alignat*}{2}
  \bodyfunction{c} &= \ldq
    && \kwstatic\:\kwvoid\:\mathtt{body\_function\_}c\ttparen{\kwenum\:\mathtt{enum\_func\_}c\:\mathtt{g}\ttcomma \kwvoid\:\ttstar\mathtt{arg}\ttcomma \kwvoid\:\ttstar\mathtt{ret}}\:\ttlbrace \\
  & && \quad \mathit{decls} \\
  & && \quad \kwswitch\:\ttparen{\mathtt{g}}\:\ttbrace{\:\auxcase{c}{1} \ldots \auxcase{c}{n}\:\maincase{c}\:} \\
  & && \quad {\genbodyb{K}{t}} \\
  & && \ttrbrace \rdq
\end{alignat*}
\begin{align*}
  \auxcase{c}{i} = \ldq & \kwcase\:\mathtt{func\_}f_i\ttcolon \\
  & y_{i1}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{outer}1\ttsemi \ldots\ttsemi\:y_{io_i}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{outer}o_i\ttsemi \\
  & x_{i1}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}1\ttsemi \ldots\ttsemi\:x_{im_i}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}m_i\ttsemi \\
  & \kwgoto\:\mathtt{entry\_}f_i\ttsemi \rdq
\end{align*}
\begin{align*}
  \maincase{c} = \ldq & \kwdefault\ttcolon\ttsemi \\
  & x_{01}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}c\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}1\ttsemi \ldots\ttsemi\:x_{0m_0}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}c\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}m_0\ttsemi \rdq
\end{align*}
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$\mathit{decls}$ is local variable declarations for variables used in $\genbodyb{K}{t}$.} \\
    & K(e) = \dq{\ttstar\ttparen{T_{00}\ttstar}\texttt{ret}\:\tteq\:e\ttsemi \kwCreturn\ttsemi}
  \end{aligned}
\]

\subsection{Translation for a Top-Level Function which is Translated to a Single C Function}\label{sec:genfuns}
$\genfuns{c}$ translates the function (constant) $c$ to a single C function.
\[
  \genfuns{c} = \dq{\kwstatic\:T_0\:c\ttparen{\fargsd{t}}\:\ttbrace{\:\mathit{decls}\:\genbodyb{K}{t}\:}}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$c$ is defined as \kwDefinition~$c : T_1 \rightarrow \dotsb \rightarrow T_n \rightarrow T_0 := t.$} \\
    & \text{$T_0$ is an inductive type} \\
    & \text{$\mathit{decls}$ is local variable declarations for variables used in $\genbodyb{K}{t}$ excluding $\fargs{t}$.} \\
    & K(e) = \dq{\kwCreturn\:e\ttsemi} \\
    & \fargs{t} =
      \begin{cases}
        \dq{T\:x\ttcomma\:\fargs{u}}      & t = \lamT{x}{T}{u} \\
        \fargs{t_j}       & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
        \dq{}    & \text{otherwise}
      \end{cases} \\
    & \fargsd{t} = \fargs{t}~\text{without the trailing comma}
  \end{aligned}
\]

\subsection{Translation for Top-Level Function}\label{sec:genfun}
\[
  \genfun{c} =
  \begin{cases}
    \genfunm{c} & \text{$t$ needs multiple functions} \\
    \genfuns{c} & \text{otherwise}
  \end{cases}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$c$ is defined as \kwDefinition~$c := t.$}
  \end{aligned}
\]

\section{Verification of \gallina-to-\gallina{} Transformations}\label{sec:verification-of-gallina-to-gallina-transformations}

\codegen{} verifies each step of the \gallina-to-\gallina{} transformations.

Since all transformations except match-app are convertible,
\codegen{} checks convertibility of such transformations.

Assuming $L = (\match{x}{C_i\: x_{i1}\ldots x_{i\NM_{C_i}}}{t_i}{i=1\ldots h}\: z)$ and \\
$R = (\match{x}{C_i\: x_{i1}\ldots x_{i\NM_{C_i}}}{t_i\:z}{i=1\ldots h})$,
match-app transformation is $L \reltri R$.
The match-app redex, $L$, is a subterm of a whole function.
The function is $K[L]$ for some context $K$.
Free variables in $L$ and $R$ are bounded by $K$.

\codegen{} verifies match-app transformation by proving $L = R$ internally.
The proof term is not visible from a user.

\codegen{} does not verify $K[L] = K[R]$ because
(1) this verification does not add big guarantee over above because we know same context $K$ is used in LHS and RHS,
(2) induction is required if $x$ is a decreasing argument of fixpoint in $K$ and it is difficult to automate.

\bibliographystyle{plain}
\bibliography{base}

\end{document}
\endinput
