\documentclass[a4paper,fleqn]{article}

\usepackage{fullpage}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd} % llbracket, rrbracket
%\usepackage{mathtools} % dcases
\usepackage{color}
\usepackage{listings}
\usepackage{url}
\usepackage{microtype}
\usepackage{balance}

\definecolor{myviolet}{rgb}{0.6,0.0,0.65}
\definecolor{myblue}{rgb}{0.1,0.0,0.8}
\definecolor{mygreen}{rgb}{0.1,0.5,0.0}
\definecolor{myred}{rgb}{0.8,0.0,0.0}

\lstdefinelanguage{coq}{
  keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,From,Require,Variable,Variables,Hypothesis,Let,Inline,Eval},
  keywordstyle=\color{myviolet}\ttfamily,
  morekeywords=[2]{match,with,end,Set,Prop,Type,fun,of,let,in,struct,if,is,then,else,as,return,fix,for,leta,letr,letn,letd,letp,nmatch,dmatch,app,rapp},
  keywordstyle=[2]\color{mygreen}\ttfamily,
  morekeywords=[3]{reflexivity},
  keywordstyle=[3]\color{myred}\ttfamily,
  morekeywords=[4]{Monadify,Action,Monomorphization,Return,Bind,Pure,Monadification,Terminate,GenC,Reset},
  keywordstyle=[4]\color{myblue}\ttfamily,
}

% The color of "in" is myviolet for
% Definition c := Eval ... in ...
\lstdefinelanguage{vernacular}{
  keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,From,Require,Variable,Variables,Hypothesis,Let,Inline,Eval,in},
  keywordstyle=\color{myviolet}\ttfamily,
  morekeywords=[2]{match,with,end,Set,Prop,Type,fun,of,let,struct,if,is,then,else,as,return,fix,for,leta,letr,letn,letd,letp,nmatch,dmatch,app,rapp},
  keywordstyle=[2]\color{mygreen}\ttfamily,
  morekeywords=[3]{reflexivity},
  keywordstyle=[3]\color{myred}\ttfamily,
  morekeywords=[4]{Monadify,Action,Monomorphization,Return,Bind,Pure,Monadification,Terminate,GenC,Reset},
  keywordstyle=[4]\color{myblue}\ttfamily,
}

\lstdefinelanguage{AST}{
keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,
From,Require,Variable,Variables,Hypothesis,Let,Inline},
keywordstyle=\color{myviolet}\ttfamily,
morekeywords=[2]{nmatch,dmatch,with,end,leta,letr,letn,letd,letp,letapp,letrapp,letnmatch,letdmatch,letproof,in},
keywordstyle=[2]\color{mygreen}\ttfamily,
morekeywords=[3]{reflexivity},
keywordstyle=[3]\color{myred}\ttfamily,
%morekeywords=[4]{Monadify,Action,Monomorphization,Return,Bind,Pure,Monadification,Terminate,GenC,Reset},
%keywordstyle=[4]\color{myblue}\ttfamily
}

\lstdefinestyle{Cstyle} {language=C,basicstyle=\small\ttfamily}
\lstdefinestyle{OCamlstyle} {language=Caml,basicstyle=\small\ttfamily}
\lstdefinestyle{ASTstyle} {language=AST,basicstyle=\small\ttfamily}
\lstdefinestyle{Vernacularstyle} {language=vernacular,basicstyle=\small\ttfamily}

\def\pipe{\char`\|}
\def\tilde{\char`\~}
\def\tiret{\char`\-}
\def\plus{\char`\+}
\def\myhat{\char`\^}
\def\mystar{\char`\*}
\def\mybs{\char`\\}
\def\placeholder{\char`\_}

\lstset{
  language=coq,
  columns=fullflexible,
  basicstyle=\small\ttfamily,
  identifierstyle=\color{black}\ttfamily,
  commentstyle=\color{myred}\ttfamily,
  morecomment=[n]{(*}{*)},
  morestring=[b][\ttfamily]",
  showstringspaces=false,
  keepspaces,
  literate=
  {->}{$\to$}1
  {forall}{$\forall$}1
  {\\}{\texttt{\mybs}}1
  {>>=}{$\gg =$}3
  {=>}{$\Rightarrow$}3
}

\def\coq{\textrm{Coq}}
\def\gallina{\textrm{Gallina}}
\def\ocaml{\textrm{OCaml}}
\def\haskell{\textrm{Haskell}}
\def\scheme{\textrm{Scheme}}
\def\ssreflect{\textrm{SSReflect}}
\def\oeuf{\textrm{\OE uf}}
\def\certicoq{\textrm{CertiCoq}}
\def\codegen{\textrm{Codegen}}

\newcommand{\kwDefinition}{\mbox{\color{myviolet}\ttfamily Definition}}
\newcommand{\kwSection}{\mbox{\color{myviolet}\ttfamily Section}}

\newcommand{\kwlet}{\mbox{\color{mygreen}\ttfamily let}}
\newcommand{\kwin}{\mbox{\color{mygreen}\ttfamily in}}
\newcommand{\kwmatch}{\mbox{\color{mygreen}\ttfamily match}}
\newcommand{\kwas}{\mbox{\color{mygreen}\ttfamily as}}
\newcommand{\kwreturn}{\mbox{\color{mygreen}\ttfamily return}}
\newcommand{\kwwith}{\mbox{\color{mygreen}\ttfamily with}}
\newcommand{\kwend}{\mbox{\color{mygreen}\ttfamily end}}
\newcommand{\kwfix}{\mbox{\color{mygreen}\ttfamily fix}}
\newcommand{\kwfor}{\mbox{\color{mygreen}\ttfamily for}}

\newcommand{\lam}[2]{\lambda #1.\:#2}
\newcommand{\lamT}[3]{\lambda #1\mathord{:}#2.\:#3}
\newcommand{\lamB}[1]{\lambda #1.\:}
\newcommand{\lamTB}[2]{\lambda #1\mathord{:}#2.\:}

\newcommand{\gassum}[2]{(#1\mathord{:}#2)}
\newcommand{\glodef}[3]{(#1:=#2\mathord{:}#3)}
\newcommand{\lassum}[2]{(#1\mathord{:}#2)}
\newcommand{\ldef}[3]{(#1:=#2\mathord{:}#3)}

\newcommand{\prodT}[3]{\forall #1\mathord{:}#2.\:#3}

\newcommand{\letin}[3]{\kwlet\:#1:=#2\:\kwin\:#3}
\newcommand{\letinB}[2]{\kwlet\:#1:=#2\:\kwin}

\newcommand{\match}[4]{\kwmatch\:#1\:\kwwith\:(#2 \Rightarrow #3)_{#4}\:\kwend}

\newcommand{\fix}[4]{\kwfix\:(#1 := #2)_{#3}\:\kwfor\:#4}
\newcommand{\fixT}[5]{\kwfix\:(#1:\!#2 := #3)_{#4}\:\kwfor\:#5}

\DeclareMathOperator{\NA}{NA}
\DeclareMathOperator{\NP}{NP}
\DeclareMathOperator{\NM}{NM}

\newcommand{\BRA}[1]{\llbracket #1 \rrbracket}

\DeclareMathOperator{\genbody}{GENBODY}
\newcommand{\genbodyat}[2]{\genbody^\mathrm{AT}_{#1}\BRA{#2}}
\newcommand{\genbodyan}[1]{\genbody^\mathrm{AN}\BRA{#1}}
\newcommand{\genbodyb}[2]{\genbody^\mathrm{B}_{#1}\BRA{#2}}

\DeclareMathOperator{\genfunop}{GENFUN}
\newcommand{\genfun}[1]{\genfunop\BRA{#1}}
\newcommand{\genfuns}[1]{\genfunop^\mathrm{S}\BRA{#1}}
\newcommand{\genfunm}[1]{\genfunop^\mathrm{M}\BRA{#1}}

\newcommand{\enumentries}[1]{\mathrm{enum\_entries}\BRA{#1}}
\newcommand{\argstructdefs}[1]{\mathrm{arg\_structdefs}\BRA{#1}}
\newcommand{\mainstructdef}[1]{\mathrm{main\_structdef}\BRA{#1}}
\newcommand{\auxstructdef}[2]{\mathrm{aux\_structdef}\BRA{#1}_{#2}}
\newcommand{\forwarddecl}[1]{\mathrm{forward\_decl}\BRA{#1}}
\newcommand{\entryfunctions}[1]{\mathrm{entry\_functions}\BRA{#1}}
\newcommand{\mainfunction}[1]{\mathrm{main\_function}\BRA{#1}}
\newcommand{\auxfunction}[2]{\mathrm{aux\_function}\BRA{#1}_{#2}}
\newcommand{\bodyfunction}[1]{\mathrm{body\_function}\BRA{#1}}
\newcommand{\auxcase}[2]{\mathrm{aux\_case}\BRA{#1}_{#2}}
\newcommand{\maincase}[1]{\mathrm{main\_case}\BRA{#1}}

\DeclareMathOperator{\cvop}{CV}
\newcommand{\cv}[3]{\cvop\BRA{#1\,/\,#2}_{#3}}

\DeclareMathOperator{\TRop}{TR}
\newcommand{\TR}[2]{\TRop\BRA{#1}_{#2}}
\newcommand{\tr}{\mathit{TR}}

\DeclareMathOperator{\RNTop}{RNT}
\newcommand{\RNT}[2]{\RNTop\BRA{#1}_{#2}}

\newcommand{\ldq}{\text{``}}
\newcommand{\rdq}{\text{''}}
\newcommand{\dq}[1]{\text{``}#1\text{''}}
\newcommand{\ttlparen}{\texttt{(}}
\newcommand{\ttrparen}{\texttt{)}}
\newcommand{\ttparen}[1]{\texttt{(}#1\texttt{)}}
\newcommand{\ttlbrace}{\texttt{\char '173}}
\newcommand{\ttrbrace}{\texttt{\char '175}}
\newcommand{\ttbrace}[1]{\ttlbrace#1\ttrbrace}
\newcommand{\tteq}{\texttt{=}}
\newcommand{\ttsemi}{\texttt{;}}
\newcommand{\ttcomma}{\texttt{,}}
\newcommand{\ttcolon}{\texttt{:}}
\newcommand{\ttstar}{\texttt{*}}
\newcommand{\ttamp}{\texttt{\&}}

\newcommand{\kwswitch}{\mbox{\color{myviolet}\ttfamily switch}}
\newcommand{\kwbreak}{\mbox{\color{myviolet}\ttfamily break}}
\newcommand{\kwgoto}{\mbox{\color{myviolet}\ttfamily goto}}
\newcommand{\kwstruct}{\mbox{\color{myviolet}\ttfamily struct}}
\newcommand{\kwvoid}{\mbox{\color{myviolet}\ttfamily void}}
\newcommand{\kwint}{\mbox{\color{myviolet}\ttfamily int}}
\newcommand{\kwCreturn}{\mbox{\color{myviolet}\ttfamily return}}
\newcommand{\kwcase}{\mbox{\color{myviolet}\ttfamily case}}
\newcommand{\kwdefault}{\mbox{\color{myviolet}\ttfamily default}}
\newcommand{\kwenum}{\mbox{\color{myviolet}\ttfamily enum}}
\newcommand{\kwstatic}{\mbox{\color{myviolet}\ttfamily static}}

\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\appref}[1]{Appendix~\ref{#1}}

\DeclareMathOperator{\passign}{passign}

\DeclareMathOperator{\fvarsop}{fvars}
\newcommand{\fvars}[1]{\fvarsop\BRA{#1}}
\newcommand{\fvarsd}[1]{\fvarsop'\BRA{#1}}

\DeclareMathOperator{\fargsop}{fargs}
\newcommand{\fargs}[1]{\fargsop\BRA{#1}}
\newcommand{\fargsd}[1]{\fargsop'\BRA{#1}}

\DeclareMathOperator{\Aop}{A}
\DeclareMathOperator{\Bop}{B}
\newcommand{\A}[3]{\Aop_{#1}\BRA{#2\,/\,#3}}
\newcommand{\B}[3]{\Bop_{#1}\BRA{#2\,/\,#3}}

\newcommand{\AbreakEq}[3]{\Aop_{#1}\llbracket \begin{aligned}[t] & #2 \\ & /\, #3 \rrbracket = \end{aligned}}
\newcommand{\BbreakEq}[3]{\Bop_{#1}\llbracket \begin{aligned}[t] & #2 \\ & /\, #3 \rrbracket = \end{aligned}}

\DeclareMathOperator{\Fop}{F}
\newcommand{\F}[1]{\Fop\BRA{#1}}
\DeclareMathOperator{\BRop}{BR}
\newcommand{\BR}[3]{\BRop\BRA{#1}_{#2,#3}}
\DeclareMathOperator{\Eop}{E}
\newcommand{\E}[3]{\Eop\BRA{#1\,/\,#2}_{#3}}

% based on the Coq reference manual, doc/common/macros.tex
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\WF}[2]{\ensuremath{{\mathcal{W\!F}}(#1)[#2]}}
\newcommand{\WFTWOLINES}[2]{\ensuremath{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WT}[4]{\ensuremath{#1[#2] \vdash #3 : #4}}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\subst}[3]{#1\{#2/#3\}}

% taken from the Coq reference manual, doc/sphinx/refman-preamble.sty
\newcommand{\case}{\kw{case}}
\newcommand{\Fix}{\kw{Fix}}

\newcommand{\vdashb}{\vdash_{\textrm{b}}}
\newcommand{\vdashf}{\vdash_{\textrm{f}}}

\newcommand{\reltri}{\mathrel{\triangleright}}

\begin{document}

\section{\gallina{}}\label{sec:gallina}
\subsection{\gallina{} Syntax}\label{sec:gallina-syntax}

\begin{align*}
  t =&\ x & \text{variable} \\
    |&\ c & \text{constant} \\
    |&\ C & \text{constructor} \\
    |&\ T & \text{type} \\
    |&\ \lamT{x}{T}{t}        & \text{abstraction} \\
    |&\ t\:u                  & \text{application} \\
    |&\ \letin{x}{t:T}{u}     & \text{let-in} \\
    |&\ \match{t_0}{C_i}{t_i}{i=1\dots h} & \text{conditional} \\
    |&\ \fixT{f_i/k_i}{T_i}{t_i}{i=1\dots h}{f_j} & \text{fixpoint}
\end{align*}
\raggedright
{\small Note:
\begin{itemize}
  \item $u$ represents a term as $t$. \\ $y, z,$ and $f$ represent a variable as $x$. \\ $U$ represents a type as $T$.
  \item We write $(\cdots((t\:u_1)\:u_2)\cdots\:u_n)$ as $t\:u_1\dots u_n$.
  \item $k$ is an integer. \\ $k_i$ for fixpoint specify the decreasing argument for $f_i$.
  \item If it is unambiguous, we omit type annotations for the sake of simplicity.  We also omit $k_i$ in fixpoints if they are not used.
  \item We omitted the elimination predicate (\kwas-\kwin-\kwreturn{} clause of \kwmatch-expression).  It is not used in reductions.
  \item \kwmatch-branches $t_i$ are functions that take the constructor members (constructor arguments without inductive type parameters).
    This formalism is taken from CIC~\cite{coqrefman8.12.0}.
  \item We omitted the detail of the types.  Actual \gallina{} permits any \gallina{} term which evaluates to a type.
\end{itemize}}
% {\tiny
% We ignore Var, Meta, Evar because they are not used in complete program.
% Int and Float are considered as constants.
% Prod, Ind and Sort are considered as types.
% Cast is ignored because it can be eliminated immediately.
% CoFix is ignored because lazy-evaluation is not suitable to C.
% Proj is ignored because it is similar to \kwmatch.}

\subsection{\gallina{} Conversion Rules}\label{sec:conversion-rules}

% based on sphinx/language/core/conversion.rst and doc/sphinx/language/core/inductive.rst
\begin{gather*}
  \text{beta:}~
    E[\Gamma] \vdash ((\lam{x}{t})\:u) \reltri \subst{t}{x}{u} \\
  \text{delta-local:}~
    \dfrac{(x:=t) \in \Gamma}{E[\Gamma] \vdash x \reltri t} \\
  \text{delta-global:}~
    \dfrac{(c:=t) \in E}{E[\Gamma] \vdash c \reltri t} \\
  \text{zeta:}~
    E[\Gamma] \vdash \letin{x}{t}{u} \reltri \subst{u}{x}{t} \\
  \text{iota-match:}~
    \dfrac
    {
      E[\Gamma] \vdash C_j\:u_1\ldots u_{p+m} : T \quad
      \text{$p$ is the number of parameters of the inductive type $T$}
    }{
      E[\Gamma] \vdash
      \match{(C_j\:u_1\ldots u_{p+m})}{C_i}{t_i}{i=1\dots h}
      \reltri
      t_j\:u_{p+1}\ldots u_{p+m}
    } \\
  \text{iota-fix:}~
    \dfrac{
      u_{k_j} = C\:u'_1\ldots u'_m
    }{
      \begin{aligned}
        E[\Gamma] \vdash\; &
          (\fix{f_i/k_i}{t_i}{i=1\dots h}{f_j})\:u_1 \dots u_{k_j} \\
        \reltri\; &
          \subst{t_j}{f_k}{\fix{f_i/k_i}{t_i}{i=1\dots h}{f_k}}_{k=1\dots h} \:u_1 \dots u_{k_j}
      \end{aligned}
    } \\
  \text{eta expansion:}~
    \dfrac{\WTEG{t}{\prodT{x}{T}{U}}}{E[\Gamma] \vdash t \reltri \lamT{x}{T}{(t\:x)}}
\end{gather*}
\raggedright
{\small Note:
\begin{itemize}
  \item The rules shown here are reductions, except the eta expansion.
  \item $\subst{t}{x}{u}$ means a term in which $x$ in term $t$ is replaced by $u$.
    This notation is taken from the Coq reference manual~\cite{coqrefman8.12.0}.
  \item Variables cannot conflict because \coq{} uses de Bruijn's indexes to represent variables.
  \item $E$ is a global environment which is a list of
    global assumptions $\gassum{c}{T}$,
    global definitions $\glodef{c}{t}{T}$, and
    inductive definitions ($\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$).
  \item $\Gamma$ is a local context which is a list of
    local assumptions $\lassum{x}{T}$ and
    local definitions $\ldef{x}{t}{T}$.
    The local assumptions represent variables bounded by outer abstractions and fixpoints.
    The local definitions represent variables bounded by outer let-in.
  \item If it is unambiguous, we omit type annotations in these definitions for the sake of simplicity.
  \item Iota-match reduces $\kwmatch\:\mathtt{@cons\:nat\:1\:nil}\:\kwwith\:(\mathtt{nil} \Rightarrow t_1)\:(\mathtt{cons} \Rightarrow t_2)\:\kwend$ to $t_2\:1\:\mathtt{nil}$
    because \lstinline!list! has one parameter $(p=1)$ and \lstinline!cons! has two members $(m=2)$.
\end{itemize}}

\section{CodeGen}\label{sec:codegen}

\begin{itemize}
\item Convertible Transformations
  \begin{itemize}
  \item Inlining
  \item Strip Cast
  \item V-Normalization
  \item S-Normalization
  \item Type Normalization
  \item Static Argument Normalization
  \item Unused let-in Deletion
  \item Call Site Replacement
  \item Argument Completion
  \item C Variable Allocation
  \end{itemize}
\item C Code Generation
  \begin{itemize}
  \item Linearity Check
  \item C Code Generation
  \end{itemize}
\end{itemize}

\section{Convertible Transformations}\label{sec:convertible-transformations}

\subsection{Inlining}\label{sec:inlining}
\subsection{Strip Cast}\label{sec:strip-cast}
\subsection{V-Normalization}\label{sec:v-normalization}
\subsubsection{V-Reductions}\label{sec:v-reductions}
\begin{gather*}
  \text{zeta-arg:}~
    \dfrac
    {
      E[\Gamma] \vdash t_i : T_i \quad
      \text{$t_0$ is not an application} \quad
      \text{$t_i$ is not a variable} \quad
      \text{$x_i$ is a fresh variable}
    }{
      E[\Gamma] \vdash
      t_0\:x_1 \ldots x_{i-1}\:t_i\:t_{i+1} \ldots t_n
      \reltri
      \letin{x_i}{t_i:T_i}{t_0\:x_1 \ldots x_{i-1}\:x_i\:t_{i+1} \ldots t_n}
    } \\
  \text{zeta-item:}~
    \dfrac
    {
      E[\Gamma] \vdash t_0 : T_0 \quad
      \text{$t_0$ is not a variable} \quad
      \text{$x_0$ is a fresh variable}
    }{
      \begin{aligned}
      E[\Gamma] \vdash\; &
        \match{t_0}{C_i}{t_i}{i=1\dots h} \\
      \reltri\; &
        \letin{x_0}{t_0:T_0}{\match{x_0}{C_i}{t_i}{i=1\dots h}}
      \end{aligned}
    }
\end{gather*}

\subsubsection{V-Normal Form}\label{sec:v-normal-form}
V-normal form restricts \gallina{} terms that (1) application arguments and (2) match items to variables.
\begin{align*}
  t =&\ x~|~c~|~C~|~T~|~\lamT{x}{T}{t}~|~ \letin{x}{t:T}{u} \\
    |&\ \fixT{f_i/k_i}{T_i}{t_i}{i=1\dots h}{f_j} \\
    |&\ t\:x                               & \leftarrow (1) \\
    |&\ \match{x}{C_i}{t_i}{i=1\dots h} & \leftarrow (2)
\end{align*}

\subsection{S-Normalization}\label{sec:s-normalization}
\begin{gather*}
  \text{beta-var:}~
    \dfrac{
      0 < n \quad
      E[\Gamma] \vdash (\lam{x}{t})\:y_1\dots y_n : T \quad
      \text{$T$ is an inductive type}
    }{
      E[\Gamma] \vdash (\lam{x}{t})\:y_1\dots y_n \reltri \subst{t}{x}{y_1}\:y_2\dots y_n
    } \\
  \text{delta-var:}~
    \dfrac{(x:=y) \in \Gamma}{E[\Gamma] \vdash x \reltri y} \\
  \text{delta-fun:}~
     \dfrac
     {
       0 \leq p \quad
       0 < q \quad
       (f := t\:x_1\ldots x_p) \in \Gamma \quad
       \text{$t$ is one of $x, c, C, \lam{x}{u}, \fix{f_i/k_i}{t_i}{i=1\dots h}{f_j}$}
     }{
       E[\Gamma] \vdash f\:y_1\ldots y_q
                        \reltri
                        t\:x_1\ldots x_p\:y_1\dots y_q
     } \\
  \text{zeta-flat:}~
    E[\Gamma] \vdash \letin{y}{(\letin{x}{t_1}{t_2})}{t_0}
                       \reltri
                       \letin{x}{t_1}{(\letin{y}{t_2}{t_0})} \\
  \text{zeta-app:}~
    E[\Gamma] \vdash
     (\letin{x_0}{t}{u})\:x_1\ldots x_n
     \reltri
     \letin{x_0}{t}{(u\:x_1\ldots x_n)} \\
  \text{iota-match-var:}~
    \dfrac
    {
      (x:=C_j\:y_1\ldots y_{p+m}:T) \in \Gamma \quad
      \text{$p$ is the number of parameters of the inductive type $T$}
    }{
      E[\Gamma] \vdash
      \match{x}{C_i}{t_i}{i=1\dots h}
      \reltri
      t_j\:y_{p+1}\ldots y_{p+m}
    } \\
  \text{iota-fix-var:}~
    \dfrac
    {
      \begin{gathered}
        (x_{k_j} := C\:y_1\ldots y_m) \in \Gamma \quad
        \text{$f'_1\dots f'_h$ are fresh variables} \\
        E[\Gamma] \vdash (\fix{f_i/k_i}{t_i}{i=1\dots h}{f_j})\:x_1\ldots x_n : T \quad
        \text{$T$ is an inductive type}
      \end{gathered}
    }{
      \begin{aligned}
        E[\Gamma] \vdash\; &
          (\fix{f_i/k_i}{t_i}{i=1\dots h}{f_j})\:x_1\ldots x_n \\
        \reltri\; &
          \begin{aligned}[t]
          & \letinB{f'_1}{\fix{f_i/k_i}{t_i}{i=1\dots h}{f_1}} ~\dots \\
          & \letinB{f'_h}{\fix{f_i/k_i}{t_i}{i=1\dots h}{f_h}} \\
          & \subst{t_j}{f_k}{f'_k}_{k=1\dots h} \:x_1 \dots x_n
          \end{aligned}
      \end{aligned}
    } \\
  \text{iota-fix-var':}~
    \dfrac
    {
      \begin{gathered}
        (x_{k_j} := C\:y_1\ldots y_m) \in \Gamma \\
        (f'_1 := \fix{f_i/k_i}{t_i}{i=1\dots h}{f_1}) \in \Gamma ~\dots~
        (f'_h := \fix{f_i/k_i}{t_i}{i=1\dots h}{f_h}) \in \Gamma \\
        E[\Gamma] \vdash (\fix{f_i/k_i}{t_i}{i=1\dots h}{f_j})\:x_1\ldots x_n : T \quad
        \text{$T$ is an inductive type}
      \end{gathered}
    }{
      E[\Gamma] \vdash
      (\fix{f_i/k_i}{t_i}{i=1\dots h}{f_j})\:x_1\ldots x_n
      \reltri
      \subst{t_j}{f_k}{f'_k}_{k=1\dots h} \:x_1 \dots x_n
    }
\end{gather*}

\subsection{Type Normalization}\label{sec:type-normalization}
\subsection{Static Argument Normalization}\label{sec:static-argument-normalization}
\subsection{Unused let-in Deletion}\label{sec:let-in-deletion}
\begin{gather*}
  \text{zeta-del:}~
    \dfrac{
      \text{$x$ does not occur in $u$}
    }{E[\Gamma] \vdash \letin{x}{t}{u}
                       \reltri
                       u
    }
\end{gather*}

\subsection{Call Site Replacement}\label{sec:call-site-replacement}

\subsection{Argument Completion}\label{sec:argcomp}
\raggedright
\begin{itemize}
  \item $\F{t}$ considers t to be a top-level function or a closure-generating expression.  $\Fop$ transforms $t$ to be a nested abstraction expression that takes all arguments.
    Fixpoint expressions are allowed outside or between the abstractions.
  \item $\BR{t}{m}{q}$ transforms a branch of a match expression into a nested abstraction expression that takes constructor members.
    Fixpoint expressions are not allowed.
  \item $\E{t}{x_1\dots x_p}{q}$ is a term convertible with $t\:x_1\dots x_p$ that does not contain a partial application.
    $\E{t}{x_1\dots x_p}{q}$ traverses $t$ while tracking the arguments for $t$ to find closure-generating expressions.
    The number of arguments given to $t$ is $p+q$.
    The first $p$ arguments are $x_1\dots x_p$ and they can be the argument of beta-var redex.
    The last $q$ arguments cannot be the argument of beta-var redex.
\end{itemize}
\[
  \F{t} =
  \begin{cases}
    \lam{x}{\F{u}} & t = \lam{x}{u} \\
    \fix{f_i}{\F{t_i}}{i=1\dots h}{f_j}  & t = \fix{f_i}{t_i}{i=1\dots h}{f_j} \\
    \lambda x_1\dots\lamB{x_m}\E{t}{x_1\dots x_m}{0}        & \text{otherwise} \quad \text{(eta expansion)}
  \end{cases}
\]
\[ \quad\text{where} \quad
  \begin{aligned}[t]
    & t : T_1 \rightarrow \dots \rightarrow T_m \rightarrow T_0 \\
    & \text{$T_0$ is an inductive type} \\
    & \text{$x_1\dots x_m$ are fresh variables}
  \end{aligned}
\]
\[
  \BR{t}{m}{q} =
  \begin{cases}
    \E{t}{}{q}    & m = 0 \\
    \lam{x}{\BR{u}{m-1}{q}} & (m > 0) \wedge (t = \lam{x}{u}) \\
    \lambda x_1\dots\lamB{x_m}\E{t}{x_1\dots x_m}{q}        & \text{otherwise} \quad \text{(eta expansion)}
  \end{cases}
\]
\[ \quad\text{where} \quad
  \begin{aligned}[t]
    & \text{$x_1\dots x_m$ are fresh variables}
  \end{aligned}
\]
\[
  \E{t}{x_1\dots x_p}{q} =
  \begin{cases}
    x                                                                                                 & (t = x) \wedge (p = q = 0) \\
    x\:x_1\dots x_p                                                                                    & (t = x) \wedge \neg (p = q = 0) \wedge (r = 0) \\
    \F{x\:x_1\dots x_p}                                                                                 & (t = x) \wedge \neg (p = q = 0) \wedge (r > 0) \\
    t\:x_1\dots x_p                                                                                    & ((t = c) \vee (t = C)) \wedge (r = 0) \\
    \F{t\:x_1\dots x_p}                                                                                 & ((t = c) \vee (t = C)) \wedge (r > 0) \\
    \F{t}                                                                                              & (t = \lam{x}{u}) \wedge (p = q = 0) \\
    \E{\subst{u}{x}{x_1}}{x_2\dots x_p}{q}                                                             & (t = \lam{x}{u}) \wedge (p > 0) \wedge (r = 0) \quad \text{(beta-var)} \\
    (\lam{x}{\E{u}{}{p+q-1}})\:x_1\dots x_p                                                             & (t = \lam{x}{u}) \wedge (\begin{aligned}[t]
                                                                                                                                & ((p = 0) \wedge (q > 0)) \:\vee \\
                                                                                                                                & ((p > 0) \wedge (r > 0)))
                                                                                                                                \end{aligned} \\
    \E{u}{x_0\:x_1\dots x_p}{q}                                                                & t = u\:x_0 \\
    \letin{x}{\E{t_1}{}{0}}{\E{t_2}{x_1\dots x_p}{q}}                                                            & t = \letin{x}{t_1}{t_2} \quad \text{(zeta-app)} \\
    \match{x}{C_i}{\BR{t_i}{\NM_{C_i}}{p+q}}{i=1\dots h}\:x_1\dots x_p                                   & t = \match{x}{C_i}{t_i}{i=1\dots h} \\
    (\fix{f_i}{\F{t_i}}{i=1\dots h}{f_j})\:x_1\dots x_p                                             & t = \fix{f_i}{t_i}{i=1\dots h}{f_j}
  \end{cases}
\]
\[ \quad\text{where} \quad
  \begin{aligned}[t]
    & t : T_1 \rightarrow \dots \rightarrow T_p \rightarrow
          T_{p+1} \rightarrow \dots \rightarrow T_{p+q} \rightarrow
          T_{p+q+1} \rightarrow \dots \rightarrow T_{p+q+r} \rightarrow T_0 \\
    & \text{$T_0$ is an inductive type} \\
  \end{aligned}
\]
\raggedright
{\small Note: \quad This transformation assumes $t$ is not dependently typed: no type terms and no dependent \kwmatch-expressions.}

\subsection{C Variable Allocation}\label{sec:cvaralloc}

\begin{align*}
  x :&\ \mbox{\gallina{} variable} \\
  v :&\ \mbox{C variable} \\
  V =&\ \mathit{empty} ~|~ x \mapsto v ~|~ V;V
\end{align*}

\raggedright
$\cv{t}{x_1\dots x_n}{V}$ is the variable mapping of the variables declared in $t$. \\
$x_1\dots x_n$ are arguments for $t$.
$V$ is the variable mapping for variables declared outside.
\[
  \cv{t}{x_1\dots x_n}{V} =
  \begin{cases}
    empty                                             & (t = x) \vee (t = c) \vee (t = C) \vee (t = T) \\
    \cv{u}{}{V; M}; M                                & (t = \lam{x}{u}) \wedge (n = 0) \quad \text{where}~M = x\mapsto v \\
    \cv{u}{x_2\dots x_n}{V; M}; M                    & (t = \lam{x}{u}) \wedge (n > 0) \quad \text{where}~M = x\mapsto V(x_1) \\
    \cv{u}{x_0\:x_1\dots x_n}V                        & t = u\:x_0 \\
    \cv{t_1}{}{V}; \cv{t_2}{x_1\dots x_n}{V; M}; M    & t = \letin{x}{t_1}{t_2} \quad \text{where}~M = x\mapsto v \\
    \begin{aligned}[t]
      (&\cv{t_1}{x_1\dots x_n}{V;M_1};\dots; \\
       &\cv{t_h}{x_1\dots x_n}{V;M_h}; \\
       &M_1;\dots;M_h)
    \end{aligned} &                                   \begin{aligned}[t]
                                                        &t = \match{x}{C_i}{\lambda y_{i1}\dots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\dots h} \\
                                                        &\text{where}~M_i = y_{i1}\mapsto v_{i1}; \dots; y_{i\NM_{C_i}}\mapsto v_{i\NM_{C_i}}
                                                      \end{aligned} \\
    \cv{t_1}{}{V;M}; \dots; \cv{t_h}{}{V;M}; M &    \begin{aligned}[t]
                                                        &t = \fix{f_i}{t_i}{i=1\dots h}{f_j} \\
                                                        &\text{where}~M = f_1\mapsto v_1;\dots; f_h\mapsto v_h
                                                      \end{aligned}
  \end{cases}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$v, v_i, v_{ij}$ are fresh C variables}
  \end{aligned}
\]
\raggedright
{\small Note: \quad We consider \gallina{} variables unique.}

\section{C Code Generation}\label{sec:c-code-gen}
\subsection{The \gallina{} Subset For C Code Generation}\label{sec:gallinasubsetforcgen}
\raggedright
\begin{gather*}
  E[\Gamma] \vdashb x \qquad
  E[\Gamma] \vdashb c \qquad
  E[\Gamma] \vdashb C \\
  \dfrac{
    E[\Gamma] \vdashb t \quad
    E[\Gamma] \vdash x : T \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashb t\:x
  } \\
  \dfrac{
    E[\Gamma] \vdashb t \quad
    E[\Gamma::\ldef{x}{t}{T}] \vdashb u \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashb \letin{x}{t:T}{u}
  } \\
  \dfrac{
    \begin{gathered}
      E[\Gamma] \vdash x:T \quad
      \text{$T$ is a non-dependent inductive type with $p$ parameters:}~I\:u_1\dots u_p \\
      E[] \vdash C_i\:u_1\dots u_p: T_{i1} \rightarrow \dots \rightarrow T_{i\NM_{C_i}} \rightarrow T \quad
      \text{$T_{ij}$ are non-dependent inductive types} \\
      E[\Gamma::\lassum{y_{i1}}{T_{i1}}::\dots::\lassum{y_{i\NM_{C_i}}}{T_{i\NM_{C_i}}}] \vdashb t_i
    \end{gathered}
  }{
    E[\Gamma] \vdashb \match{x}{C_i}{\lambda y_{i1}\dots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\dots h}
  } \\
  \dfrac{
    E[\Gamma::\lassum{x}{T}] \vdashb t \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashb \lamT{x}{T}{t}
  } \\
  \dfrac{
    E[\Gamma] \vdashf \fix{f_i:T_i}{t_i}{i=1\dots h}{f_j}
  }{
    E[\Gamma] \vdashb \fix{f_i:T_i}{t_i}{i=1\dots h}{f_j}
  } \\
  \\
  \dfrac{
    E[\Gamma] \vdash t : T \quad
    \text{$T$ is a non-dependent inductive type} \quad
    E[\Gamma] \vdashb t
  }{
    E[\Gamma] \vdashf t
  } \\
  \dfrac{
    E[\Gamma::\lassum{x}{T}] \vdashf t \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashf \lamT{x}{T}{t}
  } \\
  \dfrac{
    E[\Gamma::\lassum{f_1}{T_1}::\dots::\lassum{f_h}{T_h}] \vdashf t_i
  }{
    E[\Gamma] \vdashf \fix{f_i:T_i}{t_i}{i=1\dots h}{f_j}
  }
\end{gather*}

\subsection{Translation to C for a Non-Tail Position}\label{sec:AK}
\raggedright
$\A{K}{t}{x_1\dots x_n}$ generates C code for $t\:x_1\dots x_n$ in a non-tail position.
The result expression is passed to $K$. \\
$K(e) = \dq{v = e\ttsemi}$ in simple situations.
\begin{align*}
  &\A{K}{x}{} = K(\dq{x}) \\
  &\A{K}{x}{x_1\dots x_n} =
      \begin{aligned}[t] \ldq & {\passign(\fvarsd{x}, x_1 \dots x_n)} \\ & \kwgoto\:\mathtt{entry\_}x\ttsemi \rdq \end{aligned}
    && \begin{aligned}[t] & (n > 0) \wedge \text{$x$ is bounded by a fixpoint} \:\wedge \\ & x \in \tr \end{aligned} \\
  &\A{K}{x}{x_1\dots x_n} = K(\dq{x\ttparen{y_1,\dots,y_o,x_1,\dots, x_n}})
    && \begin{aligned}[t] & (n > 0) \wedge \text{$x$ is bounded by a fixpoint} \:\wedge \\ & x \not\in \tr \end{aligned} \\
  &\A{K}{c}{x_1\dots x_n} = K(\dq{c\ttparen{x_1,\dots, x_n}})                                   && n \geq 0 \\
  &\A{K}{C}{x_1\dots x_n} = K(\dq{C\ttparen{x_1,\dots, x_n}})                                   && n \geq 0 \\
  &\A{K}{t\:x_0}{x_1\dots x_n} = \A{K}{t}{x_0\:x_1\dots x_n} \\
  &\A{K}{\letin{x}{t_1}{t_2}}{x_1\dots x_n} =
      \begin{aligned}[t] \ldq & \A{K'}{t_1}{} \\ & \A{K}{t_2}{x_1\dots x_n} \rdq \end{aligned}
    && \text{where}\quad K'(e) = \dq{x\:\tteq\:e\ttsemi} \\
  &\A{K}{\lam{x}{t}}{x_1\:x_2\dots x_n} = \A{K}{t}{x_2\dots x_n}                                  && \text{($x$ and $x_1$ are mapped to the same C variable)} \\
  &\AbreakEq{K}{\match{x}{C_i}{\lambda y_{i1}\dots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\dots h}}{x_1\dots x_n} && \text{where}\quad x : T \\
     & \quad\begin{alignedat}{2}
       \text{``} & \kwswitch\:\ttparen{\mathit{swfunc}_T\ttparen{x}}\:\ttlbrace \\
                 & \dots \\
                 & \mathit{caselabel}_{C_i}\ttcolon\quad
                   \begin{aligned}[t]
                   & y_{i1}\:\tteq\:\mathit{get\_member}_{C_i1}(x)\ttsemi \:\dots\ttsemi \\
                   & y_{i\NM_{C_i}}\:\tteq\:\mathit{get\_member}_{C_i\NM_{C_i}}(x)\ttsemi \\
                   & {\A{K}{t_i}{x_1\dots x_n}} \\
                   & \kwbreak\ttsemi
                   \end{aligned} \\
                 & \dots \\
                 & \ttrbrace\text{''}
       \end{alignedat} \\
  &\A{K}{\fix{f_i}{t_i}{i=1\dots h}{f_j}}{x_1\dots x_n} =                   && f_j \in \tr \\
     & \quad\begin{alignedat}[t]{2}
       \text{``} & \passign(\fvars{t_j}, x_1\dots x_n) \\
                 & {\genbodyat{K'}{\fix{f_i}{t_i}{i=1\dots h}{f_j}}} \\
                 & \mathtt{exit\_}f_j\ttcolon \text{''}
       \end{alignedat} &&
               \begin{alignedat}[t]{1}
                  & \text{where} \\
                  & K'(e) =
                    \begin{cases}
                    K(e) & \text{$K(e)$ contains \kwgoto}  \\
                    \begin{aligned}[t]
                      \ldq & K(e) \\
                           & \kwgoto\:\mathtt{exit\_}f_j\ttsemi \rdq
                    \end{aligned} & \text{otherwise}
                  \end{cases}
                \end{alignedat} \\
  &\A{K}{\fix{f_i}{t_i}{i=1\dots h}{f_j}}{x_1\dots x_n} =                      && f_j \not\in \tr \\
     & \quad\begin{alignedat}[t]{2}
       \text{``} & K(f_j\ttparen{y_1,\dots,y_o,x_1\dots, x_n})                  \\
                 & \kwgoto\:\mathtt{skip\_}f_j\ttsemi                                    \\
                 & {\genbodyan{\fix{f_i}{t_i}{i=1\dots h}{f_j}}}                          \\
                 & \mathtt{skip\_}f_j\ttcolon \text{''}
       \end{alignedat}
\end{align*}
{\small Note:
\begin{itemize}
  \item $\dq{\dots}$ means a string.
    A string can contain characters in typewriter font and expressions starting in italic or roman font.
    The former is preserved as-is.
    The latter embeds the value of the expression (with name translation from \gallina{} to C).
  \item \gallina{} types, constants, and constructors have corresponding (user-configurable) C names and they are implicitly translated.
    \gallina{} variables are translated by the mapping defined in \secref{sec:cvaralloc}.
  \item $\tr = \TR{t}{n}$ where the translating function is defined as \kwDefinition~$c := t$ and $t$ is an $n$-arguments function.
  \item $\NM_C$ is the number of the members of the constructor $C$ (the number of arguments without the parameters for the inductive type): \\
    $\NM_C=m$ if $C : T_1 \rightarrow \dots \rightarrow T_p \rightarrow T_{p+1} \rightarrow \dots \rightarrow T_{p+m} \rightarrow T_0$ and $T_0$ is an inductive type which has $p$ parameters.
  \item $\mathit{swfunc}_T, \mathit{caselabel}_{C_i}$, and $\mathit{get\_member}_{C_i j}$ are defined by a user to translate \kwmatch-expressions for the inductive type $T$.
  \item $\passign(y_1\dots y_n, x_1\dots x_n)$ is a parallel assignment. It is translated to a sequence of assignments to assign $x_1\dots x_n$ into $y_1\dots y_n$.  It may require temporary variables.
  \item $y_1,\dots,y_o$ are the outer variables of the fixpoint.
  \item We do not define $\A{K}{\lam{x}{t}}{}$ because we do not support closures yet.
  \item Actual \codegen{} generates $\genbodyan{}$ in a different position to avoid the label $\mathtt{skip\_}f_j$ and $\kwgoto\:\mathtt{skip\_}f_j\ttsemi$.
\end{itemize}}

\subsection{Translation to C for a Tail Position}\label{sec:BK}
\raggedright
$\B{K}{t}{x_1\dots x_n}$ generates C code for $t\:x_1\dots x_n$ in a tail position.
The result expression is passed to $K$. \\
$K(e) = \dq{\kwCreturn\:e\ttsemi}$ in simple situations.
\begin{align*}
  &\B{K}{x}{} = K(\dq{x}) \\
  &\B{K}{x}{x_1\dots x_n} = \begin{aligned}[t] \ldq & {\passign(\fvarsd{x}, x_1\dots x_n)} \\ & \kwgoto\:\mathtt{entry\_}x\ttsemi \rdq \end{aligned}
    && (n > 0) \wedge \text{$x$ is bounded by a fixpoint} \\
  &\B{K}{c}{x_1\dots x_n} = K(\dq{c\ttparen{x_1,\dots, x_n}})                                   && n \geq 0 \\
  &\B{K}{C}{x_1\dots x_n} = K(\dq{C\ttparen{x_1,\dots, x_n}})                                   && n \geq 0 \\
  &\B{K}{t\:x_0}{x_1\dots x_n} = \B{K}{t}{x_0\:x_1\dots x_n} \\
  &\B{K}{\letin{x}{t_1}{t_2}}{x_1\dots x_n} =
      \begin{aligned}[t] \ldq & \A{K'}{t_1}{} \\ & \B{K}{t_2}{x_1\dots x_n} \rdq \end{aligned}
    && \text{where}\quad K'(e) = \dq{x\:\tteq\:e\ttsemi} \\
  &\B{K}{\lam{x}{t}}{x_1\:x_2\dots x_n} = \B{K}{t}{x_2\dots x_n}                                 && \text{($x$ and $x_1$ are mapped to the same C variable)} \\
  &\BbreakEq{K}{\match{x}{C_i}{\lambda y_{i1}\dots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\dots h}}{x_1\dots x_n} && \text{where}\quad x : T \\
     & \quad\begin{alignedat}{2}
       \text{``} & \kwswitch\:\ttparen{\mathit{swfunc}_T\ttparen{x}}\:\ttlbrace \\
                 & \dots \\
                 & \mathit{caselabel}_{C_i}\ttcolon\quad
                   \begin{aligned}[t]
                     & y_{i1}\:\tteq\:\mathit{get\_member}_{C_i1}(x)\ttsemi \:\dots\ttsemi \\
                     & y_{i\NM_{C_i}}\:\tteq\:\mathit{get\_member}_{C_i\NM_{C_i}}(x)\ttsemi \\
                     & {\B{K}{t_i}{x_1\dots x_n}}
                   \end{aligned} \\
                 & \dots \\
                 & \ttrbrace\text{''}
     \end{alignedat} \\
  &\B{K}{\fix{f_i}{t_i}{i=1\dots h}{f_j}}{x_1\dots x_n} =       \\
     & \quad\begin{alignedat}{2}
       \text{``} & {\passign(\fvars{t_j}, x_1\dots x_n)} \\
                 & {\genbodyb{K}{\fix{f_i}{t_i}{i=1\dots h}{f_j}}} \text{''}
       \end{alignedat}
\end{align*}
{\small Note: \quad We do not define $\B{K}{\lam{x}{t}}{}$ because a tail position cannot be a function after the argument completion.}

\subsection{Auxiliary Functions for Translation to C}\label{sec:aux-function}
\raggedright
\[
  \fvars{t} =
  \begin{cases}
    \dq{x;\:\fvars{u}} & t = \lam{x}{u} \\
    \fvars{t_j}       & t = \fix{f_i}{t_i}{i=1\dots h}{f_j} \\
    \dq{}             & \text{otherwise}
  \end{cases}
\]
\[
  \fvarsd{f_i} = \fvars{t_i} \quad \text{for functions bounded by $\fix{f_i}{t_i}{i=1\dots h}{f_j}$}
\]
\[
  \genbodyat{K}{t} =
  \begin{cases}
    \genbodyat{K}{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyat{K}{t_i}} & t = \fix{f_i}{t_i}{i=1\dots h}{f_j} \\
    \quad \text{for}~i=j, 1,\dots, (j-1), (j+1),\dots, h \\
    \A{K}{t}{}                            & \text{otherwise}
  \end{cases}
\]
\[
  \genbodyan{t} =
  \begin{cases}
    \genbodyan{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyan{t_i}} & t = \fix{f_i}{t_i}{i=1\dots h}{f_j} \\
    \quad \text{for}~i=1,\dots, h \\
    \B{K}{t}{}                            & \begin{aligned}[t]
                                            & \text{otherwise} \\
                                            & \text{where} \\
                                            & \quad t:T \\
                                            & \quad K(e) = \dq{\texttt{*($T$*)ret = $e$; \kwCreturn;}}
                                            \end{aligned}
  \end{cases}
\]
\[
  \genbodyb{K}{t} =
  \begin{cases}
    \genbodyb{K}{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyb{K}{t_i}} & t = \fix{f_i}{t_i}{i=1\dots h}{f_j} \\
    \quad \text{for}~i=j, 1,\dots, (j-1), (j+1),\dots, h \\
    \B{K}{t}{}                            & \text{otherwise}
  \end{cases}
\]
{\small Note:
\begin{itemize}
  \item $\fvarsop$ and $\fvarsop'$ returns a list of variables: $x_1;\dots;x_n;$.  For simplicity, we omit ``$;$'' if not ambiguous.
  \item $\dq{g(i)}~\text{for}~i=j_1,\dots,j_n$ means $\dq{g(j_1)\:\dots\:g(j_n)}$.
\end{itemize}}

\subsection{Detection of Tail Recursive Fixpoint Bounded Functions}\label{sec:tailrec-fixpoint-detection}
\raggedright
$\TR{t}{n}$ is the first element of $\RNT{t}{n}$.

$(R,N,T) = \RNT{t}{n}$ classify variables in $t$ assuming that it is called with $n$ arguments as $t\:x_1\dots x_n$:
\begin{align*}
  R &: \text{tail-recursive fixpoint bounded functions that do not need to be real functions} \\
  N &: \text{free variables at non-tail positions of $t$} \\
  T &: \text{free variables at tail positions of $t$}
\end{align*}
``tail position'' is extended to the function position of the application at a tail position. \\
$R$ distinguishes fixpoint bounded functions translatable without actual functions (but with \kwgoto{}) or not.
\[ \TR{t}{n} = R \quad \text{where}\quad (R,N,T) = \RNT{t}{n} \]
\begin{align*}
  &\RNT{t}{n} = \\
  &\begin{cases}
    (\varnothing, \varnothing, \{x\})             & t = x \\
    (\varnothing, \varnothing, \varnothing)         & (t = c) \vee (t = C) \\
    (R, N \cup \{x\}, T)         & t = u\:x \quad \text{where}\quad (R,N,T) = \RNT{u}{n+1} \\
    (R_1 \cup R_2, N_1 \cup T_1 \cup N_2 - \{x\}, T_2 - \{x\})        &
      \begin{aligned}[t]
        & t = \letin{x}{t_1}{t_2} \\
        & \text{where}\quad (R_1,N_1,T_1) = \RNT{t_1}{0} \quad (R_2,N_2,T_2) = \RNT{t_2}{n}
      \end{aligned} \\
    \bigl(\bigcup_{i=1}^h R_i, \bigcup_{i=1}^h N_i, \bigcup_{i=1}^h T_i \bigr)         &
      \begin{aligned}[t]
        & t = \match{x}{C_i}{t_i}{i=1\dots h} \\
        & \text{where}~(R_i, N_i, T_i) = \RNT{t_i}{\NM_{C_i}+n}
      \end{aligned} \\
    (R, N-\{x\}, T - \{x\})                                           & (t = \lam{x}{u}) \wedge (n > 0) \quad \text{where}\quad  (R, N, T) = \RNT{u}{n-1} \\
    (R, (N \cup T) - \{x\}, \varnothing)                             & (t = \lam{x}{u}) \wedge (n = 0) \quad \text{where}\quad  (R, N, T) = \RNT{u}{\NA_u} \quad \text{(closure)} \\
    \begin{aligned}[t]
      \bigl( & \textstyle\bigcup_{i=1}^h R_i \cup \{f_1,\dots, f_h\}, \\
             & \textstyle\bigcup_{i=1}^h N_i - \{f_1,\dots, f_h\}, \\
             & \textstyle\bigcup_{i=1}^h T_i - \{f_1,\dots, f_h\} \bigr)
    \end{aligned} &
      \begin{aligned}[t]
        & (t = \fix{f_i}{t_i}{i=1\dots h}{f_j}) \:\wedge \\
        & (n = \NA_t) \wedge \bigl(\textstyle\bigcup_{i=1}^h N_i \cap \{f_1,\dots, f_h\} = \varnothing\bigr) \\
        & \text{where}\quad (R_i, N_i, T_i) = \RNT{t_i}{\NA_{t_i}}
      \end{aligned} \\
    \begin{aligned}[t]
      \bigl( & \textstyle\bigcup_{i=1}^h R_i, \\
             & \textstyle\bigcup_{i=1}^h (N_i \cup T_i) - \{f_1,\dots, f_h\}, \\
             & \varnothing \bigr)
    \end{aligned} &
      \begin{aligned}[t]
        & (t = \fix{f_i}{t_i}{i=1\dots h}{f_j}) \wedge \quad \text{(real function, maybe closure)} \\
        & \neg ((n = \NA_t) \wedge \bigl(\textstyle\bigcup_{i=1}^h N_i \cap \{f_1,\dots, f_h\} = \varnothing\bigr)) \\
        & \text{where}\quad (R_i, N_i, T_i) = \RNT{t_i}{\NA_{t_i}}
      \end{aligned}
  \end{cases}
\end{align*}
{\small Note:
\begin{itemize}
  \item $\NA_t$ is the number of arguments of $t$: \quad $\NA_t=m$ if $t : T_1 \rightarrow \dots \rightarrow T_m \rightarrow T_0$ and $T_0$ is an inductive type.
  \item The variables in $t$ are unique.
    \codegen{} uses de Bruijn's indexes for $N$ and $T$;
    the variables renamed by \secref{sec:cvaralloc} for $R$.
\end{itemize}}

\subsection{Translation for a Top-Level Function which is Translated to Multiple C Functions}\label{sec:genfunm}
\raggedright
$\genfunm{c}$ translates the function (constant) $c$ with one or more auxiliary functions.
We assume $c$ is defined as \kwDefinition~$c := t.$
The auxiliary functions $f_1 \dots f_n$ are fixpoint bounded functions in $t$ which are invoked as functions.
We assume the types of them:
\begin{align*}
  c &: T_{01} \rightarrow \dots \rightarrow T_{0m_0} \rightarrow T_{00} \\
  f_i &: T_{i1} \rightarrow \dots \rightarrow T_{im_i} \rightarrow T_{i0} && i = 1\dots n
\end{align*}
\[ \text{where} \quad \text{$T_{i0}$ are inductive types ($i=0\dots n$)} \]
The formal arguments of $c$ are $x_{01}\dots x_{0m_0} = \fvars{t}$ and
the formal arguments of $f_i$ are $x_{i1}\dots x_{im_i} = \fvarsd{f_i}$.

$f_i$ invocation in C needs extra arguments, $y_{i1}:U_{i1} \dots y_{io_i}:U_{io_i}$, addition to the actual arguments in \gallina{} application because the free variables of the fixpoint should also be passed.
If the free variables contain a function bounded by an outer fixpoint, the function itself is not passed but the free variables of the outer fixpoint are also passed.
We iterate it until no fixpoint functions.

\begin{alignat*}{2}
  \genfunm{c} &= \text{``} && \enumentries{c}~\argstructdefs{c}~\forwarddecl{c}~\entryfunctions{c}~\bodyfunction{c} \text{''}
\end{alignat*}
\[ \enumentries{c} = \dq{\kwenum\:\mathtt{enum\_func\_}c\:\ttbrace{ \mathtt{func\_}c\ttcomma \mathtt{func\_}f_1\ttcomma \dots\ttcomma \mathtt{func\_}f_n }\ttsemi} \]
\[ \argstructdefs{c} = \dq{\mainstructdef{c}\:\auxstructdef{c}{1} \dots \auxstructdef{c}{n}} \]
\[ \mainstructdef{c} = \dq{\kwstruct\:\mathtt{arg\_}c\:\ttbrace{\:T_{01}\:\mathtt{arg}1\ttsemi \dots T_{0m_0}\:\mathtt{arg}m_0\ttsemi\:}\ttsemi} \]
\[ \auxstructdef{c}{i} = \dq{\kwstruct\:\mathtt{arg\_}f_i\:\ttbrace{\:U_{i1}\:\mathtt{outer}1\ttsemi \dots U_{io_i}\:\mathtt{outer}o_i\ttsemi\:T_{i1}\:\mathtt{arg}1\ttsemi \dots T_{im_i}\:\mathtt{arg}m_i\ttsemi\:}\ttsemi} \]
\[ \forwarddecl{c} = \dq{\kwstatic\:\kwvoid\:\mathtt{body\_function\_}c\ttparen{\kwenum\:\mathtt{enum\_func\_}c\:\mathtt{g}\ttcomma \kwvoid\:\mathtt{\ttstar arg}\ttcomma \kwvoid\:\mathtt{\ttstar ret}}\ttsemi} \]
\[ \entryfunctions{c} = \dq{\mainfunction{c}\:\auxfunction{c}{1} \dots \auxfunction{c}{n}} \]
\begin{alignat*}{2}
  \mainfunction{c} &= \text{``} && \kwstatic\:T_{00}\:c\ttparen{T_{01}\:x_{01}\ttcomma\dots\ttcomma T_{0m_0}\:x_{0m_0}}\:\ttlbrace \\
  & && \quad \kwstruct\:\mathtt{arg\_}c\:\mathtt{arg}\:\tteq\:\ttbrace{ x_{01}\ttcomma\dots\ttcomma x_{0m_0} }\ttsemi\:T_{00}\:\mathtt{ret}\ttsemi \\
  & && \quad \mathtt{body\_function\_}c\ttparen{\mathtt{func\_}c\ttcomma \ttamp\mathtt{arg}\ttcomma \ttamp\mathtt{ret}}\ttsemi \kwCreturn\:\mathtt{ret}\ttsemi \\
  & && \ttrbrace \text{''}
\end{alignat*}
\begin{alignat*}{2}
  \auxfunction{c}{i} &= \text{``} && \kwstatic\:T_{i0}\:f_i\ttparen{U_{i1}\:y_{i1}\ttcomma\dots\ttcomma U_{io_i}\:y_{io_i}\ttcomma T_{i1}\:x_{i1}\ttcomma\dots\ttcomma T_{im_i}\:x_{im_i}}\:\ttlbrace \\
  & && \quad \kwstruct\:\mathtt{arg\_}f_i\:\mathtt{arg}\:\tteq\:\ttbrace{ y_{i1}\ttcomma\dots\ttcomma y_{io_i}\ttcomma x_{i1}\ttcomma\dots\ttcomma x_{im_i} }\ttsemi\:T_{i0}\:\mathtt{ret}\ttsemi\\
  & && \quad \mathtt{body\_function\_}c\ttparen{\mathtt{func\_}f_i\ttcomma \ttamp\mathtt{arg}\ttcomma \ttamp\mathtt{ret}}\ttsemi\:\kwCreturn\:\mathtt{ret}\ttsemi \\
  & && \ttrbrace \text{''}
\end{alignat*}
\begin{alignat*}{2}
  \bodyfunction{c} &= \text{``}
    && \kwstatic\:\kwvoid\:\mathtt{body\_function\_}c\ttparen{\kwenum\:\mathtt{enum\_func\_}c\:\mathtt{g}\ttcomma \kwvoid\:\ttstar\mathtt{arg}\ttcomma \kwvoid\:\ttstar\mathtt{ret}}\:\ttlbrace \\
  & && \quad \mathit{decls} \\
  & && \quad \kwswitch\:\ttparen{\mathtt{g}}\:\ttbrace{\:\auxcase{c}{1} \dots \auxcase{c}{n}\:\maincase{c}\:} \\
  & && \quad {\genbodyb{K}{t}} \\
  & && \ttrbrace \text{''}
\end{alignat*}
\begin{align*}
  \auxcase{c}{i} = \text{``} & \kwcase\:\mathtt{func\_}f_i\ttcolon \\
  & y_{i1}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{outer}1\ttsemi \dots\ttsemi\:y_{io_i}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{outer}o_i\ttsemi \\
  & x_{i1}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}1\ttsemi \dots\ttsemi\:x_{im_i}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}m_i\ttsemi \\
  & \kwgoto\:\mathtt{entry\_}f_i\ttsemi \text{''}
\end{align*}
\begin{align*}
  \maincase{c} = \text{``} & \kwdefault\ttcolon\ttsemi \\
  & x_{01}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}c\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}1\ttsemi \dots\ttsemi\:x_{0m_0}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}c\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}m_0\ttsemi \text{''}
\end{align*}
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$\mathit{decls}$ is local variable declarations for variables used in $\genbodyb{K}{t}$.} \\
    & K(e) = \dq{\ttstar\ttparen{T_{00}\ttstar}\texttt{ret}\:\tteq\:e\ttsemi \kwCreturn\ttsemi}
  \end{aligned}
\]

\subsection{Translation for a Top-Level Function which is Translated to a Single C Function}\label{sec:genfuns}
\raggedright
$\genfuns{c}$ translates the function (constant) $c$ to a single C function.
\[
  \genfuns{c} = \dq{\kwstatic\:T_0\:c\ttparen{\fargsd{t}}\:\ttbrace{\:\mathit{decls}\:\genbodyb{K}{t}\:}}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$c$ is defined as \kwDefinition~$c : T_1 \rightarrow \dots \rightarrow T_n \rightarrow T_0 := t.$} \\
    & \text{$T_0$ is an inductive type} \\
    & \text{$\mathit{decls}$ is local variable declarations for variables used in $\genbodyb{K}{t}$ excluding $\fargs{t}$.} \\
    & K(e) = \dq{\kwCreturn\:e\ttsemi} \\
    & \fargs{t} =
      \begin{cases}
        \dq{T\:x\ttcomma\:\fargs{u}}      & t = \lamT{x}{T}{u} \\
        \fargs{t_j}       & t = \fix{f_i}{t_i}{i=1\dots h}{f_j} \\
        \dq{}    & \text{otherwise}
      \end{cases} \\
    & \fargsd{t} = \fargs{t}~\text{without the trailing comma}
  \end{aligned}
\]

\subsection{Translation for Top-Level Function}\label{sec:genfun}
\raggedright
\[
  \genfun{c} =
  \begin{cases}
    \genfunm{c} & \text{$t$ needs multiple functions} \\
    \genfuns{c} & \text{otherwise}
  \end{cases}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$c$ is defined as \kwDefinition~$c := t.$}
  \end{aligned}
\]

\bibliographystyle{plain}
\bibliography{base}

\end{document}
\endinput
