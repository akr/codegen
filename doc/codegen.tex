\documentclass[a4paper,fleqn]{article}

\usepackage{fullpage}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd} % llbracket, rrbracket
%\usepackage{mathtools} % dcases
\usepackage{color}
\usepackage{listings}
\usepackage{url}
\usepackage{microtype}
\usepackage{balance}

\definecolor{myviolet}{rgb}{0.6,0.0,0.65}
\definecolor{myblue}{rgb}{0.1,0.0,0.8}
\definecolor{mygreen}{rgb}{0.1,0.5,0.0}
\definecolor{myred}{rgb}{0.8,0.0,0.0}

\lstdefinelanguage{coq}{
  keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,From,Require,Variable,Variables,Hypothesis,Let,Inline,Eval},
  keywordstyle=\color{myviolet}\ttfamily,
  morekeywords=[2]{match,with,end,Set,Prop,Type,fun,of,let,in,struct,if,is,then,else,as,return,fix,for,leta,letr,letn,letd,letp,nmatch,dmatch,app,rapp},
  keywordstyle=[2]\color{mygreen}\ttfamily,
  morekeywords=[3]{reflexivity},
  keywordstyle=[3]\color{myred}\ttfamily,
  morekeywords=[4]{Monadify,Action,Monomorphization,Return,Bind,Pure,Monadification,Terminate,GenC,Reset},
  keywordstyle=[4]\color{myblue}\ttfamily,
}

% The color of "in" is myviolet for
% Definition c := Eval ... in ...
\lstdefinelanguage{vernacular}{
  keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,From,Require,Variable,Variables,Hypothesis,Let,Inline,Eval,in},
  keywordstyle=\color{myviolet}\ttfamily,
  morekeywords=[2]{match,with,end,Set,Prop,Type,fun,of,let,struct,if,is,then,else,as,return,fix,for,leta,letr,letn,letd,letp,nmatch,dmatch,app,rapp},
  keywordstyle=[2]\color{mygreen}\ttfamily,
  morekeywords=[3]{reflexivity},
  keywordstyle=[3]\color{myred}\ttfamily,
  morekeywords=[4]{Monadify,Action,Monomorphization,Return,Bind,Pure,Monadification,Terminate,GenC,Reset},
  keywordstyle=[4]\color{myblue}\ttfamily,
}

\lstdefinelanguage{AST}{
keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,
From,Require,Variable,Variables,Hypothesis,Let,Inline},
keywordstyle=\color{myviolet}\ttfamily,
morekeywords=[2]{nmatch,dmatch,with,end,leta,letr,letn,letd,letp,letapp,letrapp,letnmatch,letdmatch,letproof,in},
keywordstyle=[2]\color{mygreen}\ttfamily,
morekeywords=[3]{reflexivity},
keywordstyle=[3]\color{myred}\ttfamily,
%morekeywords=[4]{Monadify,Action,Monomorphization,Return,Bind,Pure,Monadification,Terminate,GenC,Reset},
%keywordstyle=[4]\color{myblue}\ttfamily
}

\lstdefinestyle{Cstyle} {language=C,basicstyle=\small\ttfamily}
\lstdefinestyle{OCamlstyle} {language=Caml,basicstyle=\small\ttfamily}
\lstdefinestyle{ASTstyle} {language=AST,basicstyle=\small\ttfamily}
\lstdefinestyle{Vernacularstyle} {language=vernacular,basicstyle=\small\ttfamily}

\def\pipe{\char`\|}
\def\tilde{\char`\~}
\def\tiret{\char`\-}
\def\plus{\char`\+}
\def\myhat{\char`\^}
\def\mystar{\char`\*}
\def\mybs{\char`\\}
\def\placeholder{\char`\_}

\lstset{
  language=coq,
  columns=fullflexible,
  basicstyle=\small\ttfamily,
  identifierstyle=\color{black}\ttfamily,
  commentstyle=\color{myred}\ttfamily,
  morecomment=[n]{(*}{*)},
  morestring=[b][\ttfamily]",
  showstringspaces=false,
  keepspaces,
  literate=
  {->}{$\to$}1
  {forall}{$\forall$}1
  {\\}{\texttt{\mybs}}1
  {>>=}{{$\gg =$}}3
  {=>}{$\Rightarrow$}3
}

\def\coq{\textrm{Coq}}
\def\gallina{\textrm{Gallina}}
\def\ocaml{\textrm{OCaml}}
\def\haskell{\textrm{Haskell}}
\def\scheme{\textrm{Scheme}}
\def\ssreflect{\textrm{SSReflect}}
\def\oeuf{\textrm{\OE uf}}
\def\certicoq{\textrm{CertiCoq}}
\def\codegen{\textrm{Codegen}}

\newcommand{\kwDefinition}{\mbox{\color{myviolet}\ttfamily Definition}}
\newcommand{\kwSection}{\mbox{\color{myviolet}\ttfamily Section}}

\newcommand{\kwlet}{\mbox{\color{mygreen}\ttfamily let}}
\newcommand{\kwin}{\mbox{\color{mygreen}\ttfamily in}}
\newcommand{\kwmatch}{\mbox{\color{mygreen}\ttfamily match}}
\newcommand{\kwas}{\mbox{\color{mygreen}\ttfamily as}}
\newcommand{\kwreturn}{\mbox{\color{mygreen}\ttfamily return}}
\newcommand{\kwwith}{\mbox{\color{mygreen}\ttfamily with}}
\newcommand{\kwend}{\mbox{\color{mygreen}\ttfamily end}}
\newcommand{\kwfix}{\mbox{\color{mygreen}\ttfamily fix}}
\newcommand{\kwfor}{\mbox{\color{mygreen}\ttfamily for}}

\newcommand{\lam}[2]{\lambda #1.\:#2}
\newcommand{\lamT}[3]{\lambda #1\mathord{:}#2.\:#3}
\newcommand{\lamB}[1]{\lambda #1.\:}
\newcommand{\lamTB}[2]{\lambda #1\mathord{:}#2.\:}

\newcommand{\gassum}[2]{(#1\mathord{:}#2)}
\newcommand{\glodef}[3]{(#1:=#2\mathord{:}#3)}
\newcommand{\lassum}[2]{(#1\mathord{:}#2)}
\newcommand{\ldef}[3]{(#1:=#2\mathord{:}#3)}

\newcommand{\prodT}[3]{\forall #1\mathord{:}#2.\:#3}

\newcommand{\letin}[3]{\kwlet\:#1:=#2\:\kwin\:#3}
\newcommand{\letinB}[2]{\kwlet\:#1:=#2\:\kwin}

\newcommand{\match}[4]{\kwmatch\:#1\:\kwwith\:(#2 \Rightarrow #3)_{#4}\:\kwend}
\newcommand{\matchasinret}[7]{\kwmatch\:#1\:\kwas\:#2\:\kwin\:#3\:\kwreturn\:#4\:\kwwith\:(#5 \Rightarrow #6)_{#7}\:\kwend}

\newcommand{\fix}[4]{\kwfix\:(#1 := #2)_{#3}\:\kwfor\:#4}
\newcommand{\fixT}[5]{\kwfix\:(#1:\!#2 := #3)_{#4}\:\kwfor\:#5}

\DeclareMathOperator{\NA}{NA} % number of arguments
\DeclareMathOperator{\NP}{NP} % number of parameters for the inductive type
\DeclareMathOperator{\NI}{NI} % number of indexes for the inductive type
\DeclareMathOperator{\NM}{NM} % number of members for the constructor

\DeclareMathOperator{\FV}{FV}

\newcommand{\BRA}[1]{\llbracket #1 \rrbracket}

\DeclareMathOperator{\genbody}{GENBODY}
\newcommand{\genbodyat}[2]{\genbody^\mathrm{AT}_{#1}\BRA{#2}}
\newcommand{\genbodyan}[1]{\genbody^\mathrm{AN}\BRA{#1}}
\newcommand{\genbodyb}[2]{\genbody^\mathrm{B}_{#1}\BRA{#2}}

\DeclareMathOperator{\genfunop}{GENFUN}
\newcommand{\genfun}[1]{\genfunop\BRA{#1}}
\newcommand{\genfuns}[1]{\genfunop^\mathrm{S}\BRA{#1}}
\newcommand{\genfunm}[1]{\genfunop^\mathrm{M}\BRA{#1}}

\newcommand{\enumentries}[1]{\mathrm{enum\_entries}\BRA{#1}}
\newcommand{\argstructdefs}[1]{\mathrm{arg\_structdefs}\BRA{#1}}
\newcommand{\mainstructdef}[1]{\mathrm{main\_structdef}\BRA{#1}}
\newcommand{\auxstructdef}[2]{\mathrm{aux\_structdef}\BRA{#1}_{#2}}
\newcommand{\forwarddecl}[1]{\mathrm{forward\_decl}\BRA{#1}}
\newcommand{\entryfunctions}[1]{\mathrm{entry\_functions}\BRA{#1}}
\newcommand{\mainfunction}[1]{\mathrm{main\_function}\BRA{#1}}
\newcommand{\auxfunction}[2]{\mathrm{aux\_function}\BRA{#1}_{#2}}
\newcommand{\bodyfunction}[1]{\mathrm{body\_function}\BRA{#1}}
\newcommand{\auxcase}[2]{\mathrm{aux\_case}\BRA{#1}_{#2}}
\newcommand{\maincase}[1]{\mathrm{main\_case}\BRA{#1}}

\DeclareMathOperator{\cvop}{CV}
\newcommand{\cv}[3]{\cvop\BRA{#1\,/\,#2}_{#3}}

\DeclareMathOperator{\TRop}{TR}
\newcommand{\TR}[2]{\TRop\BRA{#1}_{#2}}
\newcommand{\tr}{\mathit{TR}}

\DeclareMathOperator{\RNTop}{RNT}
\newcommand{\RNT}[2]{\RNTop\BRA{#1}_{#2}}

\DeclareMathOperator{\APP}{APP}

\newcommand{\ldq}{\text{``}}
\newcommand{\rdq}{\text{''}}
\newcommand{\dq}[1]{\text{``}#1\text{''}}
\newcommand{\ttlparen}{\texttt{(}}
\newcommand{\ttrparen}{\texttt{)}}
\newcommand{\ttparen}[1]{\texttt{(}#1\texttt{)}}
\newcommand{\ttlbrace}{\texttt{\char '173}}
\newcommand{\ttrbrace}{\texttt{\char '175}}
\newcommand{\ttbrace}[1]{\ttlbrace#1\ttrbrace}
\newcommand{\tteq}{\texttt{=}}
\newcommand{\ttsemi}{\texttt{;}}
\newcommand{\ttcomma}{\texttt{,}}
\newcommand{\ttcolon}{\texttt{:}}
\newcommand{\ttstar}{\texttt{*}}
\newcommand{\ttamp}{\texttt{\&}}

\newcommand{\kwswitch}{\mbox{\color{myviolet}\ttfamily switch}}
\newcommand{\kwbreak}{\mbox{\color{myviolet}\ttfamily break}}
\newcommand{\kwgoto}{\mbox{\color{myviolet}\ttfamily goto}}
\newcommand{\kwstruct}{\mbox{\color{myviolet}\ttfamily struct}}
\newcommand{\kwvoid}{\mbox{\color{myviolet}\ttfamily void}}
\newcommand{\kwint}{\mbox{\color{myviolet}\ttfamily int}}
\newcommand{\kwCreturn}{\mbox{\color{myviolet}\ttfamily return}}
\newcommand{\kwcase}{\mbox{\color{myviolet}\ttfamily case}}
\newcommand{\kwdefault}{\mbox{\color{myviolet}\ttfamily default}}
\newcommand{\kwenum}{\mbox{\color{myviolet}\ttfamily enum}}
\newcommand{\kwstatic}{\mbox{\color{myviolet}\ttfamily static}}

\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\appref}[1]{Appendix~\ref{#1}}

\DeclareMathOperator{\passign}{passign}

\DeclareMathOperator{\fvarsop}{fvars}
\newcommand{\fvars}[1]{\fvarsop\BRA{#1}}
\newcommand{\fvarsd}[1]{\fvarsop'\BRA{#1}}

\DeclareMathOperator{\fargsop}{fargs}
\newcommand{\fargs}[1]{\fargsop\BRA{#1}}
\newcommand{\fargsd}[1]{\fargsop'\BRA{#1}}

\DeclareMathOperator{\Aop}{A}
\DeclareMathOperator{\Bop}{B}
\newcommand{\A}[3]{\Aop_{#1}\BRA{#2\,/\,#3}}
\newcommand{\B}[3]{\Bop_{#1}\BRA{#2\,/\,#3}}

\newcommand{\AbreakEq}[3]{\Aop_{#1}\llbracket \begin{aligned}[t] & #2 \\ & /\, #3 \rrbracket = \end{aligned}}
\newcommand{\BbreakEq}[3]{\Bop_{#1}\llbracket \begin{aligned}[t] & #2 \\ & /\, #3 \rrbracket = \end{aligned}}

\DeclareMathOperator{\Fop}{F}
\newcommand{\F}[1]{\Fop\BRA{#1}}
\DeclareMathOperator{\BRop}{BR}
\newcommand{\BR}[3]{\BRop\BRA{#1}_{#2,#3}}
\DeclareMathOperator{\Eop}{E}
\newcommand{\E}[3]{\Eop\BRA{#1\,/\,#2}_{#3}}

% based on the Coq reference manual, doc/common/macros.tex
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\WF}[2]{\ensuremath{{\mathcal{W\!F}}(#1)[#2]}}
\newcommand{\WFTWOLINES}[2]{\ensuremath{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WT}[4]{\ensuremath{#1[#2] \vdash #3 : #4}}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\subst}[3]{#1\{#2/#3\}}

% taken from the Coq reference manual, doc/sphinx/refman-preamble.sty
\newcommand{\case}{\kw{case}}
\newcommand{\Fix}{\kw{Fix}}

\newcommand{\vdashb}{\vdash_{\textrm{b}}}
\newcommand{\vdashf}{\vdash_{\textrm{f}}}

\newcommand{\reltri}{\mathrel{\triangleright}}

\title{codegen development memo}

\begin{document}

\maketitle

\section{\gallina{}}\label{sec:gallina}
\subsection{\gallina{} Syntax}\label{sec:gallina-syntax}

\begin{align*}
  t =&\ x & \text{variable} \\
    |&\ c & \text{constant} \\
    |&\ C & \text{constructor} \\
    |&\ T & \text{type} \\
    |&\ \lamT{x}{T}{t}        & \text{abstraction} \\
    |&\ t\:u                  & \text{application} \\
    |&\ \letin{x}{t:T}{u}     & \text{let-in} \\
    |&\ \match{t_0}{C_i}{t_i}{i=1\ldots h} & \text{conditional} \\
    |&\ \fixT{f_i/k_i}{T_i}{t_i}{i=1\ldots h}{f_j} & \text{fixpoint}
\end{align*}
{\small Note:
\begin{itemize}
  \item $u$ represents a term as $t$. \\ $y, z,$ and $f$ represent a variable as $x$. \\ $U$ represents a type as $T$.
  \item We write $(\cdots((t\:u_1)\:u_2)\cdots\:u_n)$ as $t\:u_1\ldots u_n$.
  \item $k$ is an integer. \\ $k_i$ for fixpoint specify the decreasing argument for $f_i$.
  \item If it is unambiguous, we omit type annotations for the sake of simplicity.  We also omit $k_i$ in fixpoints if they are not used.
  \item We omitted the elimination predicate (\kwas-\kwin-\kwreturn{} clause of \kwmatch-expression).  It is not used in reductions.
  \item \kwmatch-branches $t_i$ are functions that take the constructor members (constructor arguments without inductive type parameters).
    This formalism is taken from CIC~\cite{coqrefman8.12.0}.
  \item We omitted the detail of the types.  Actual \gallina{} permits any \gallina{} term which evaluates to a type.
\end{itemize}}

% {\tiny
% We ignore Var, Meta, Evar because they are not used in complete program.
% Int and Float are considered as constants.
% Prod, Ind and Sort are considered as types.
% Cast is ignored because it can be eliminated immediately.
% CoFix is ignored because lazy-evaluation is not suitable to C.
% Proj is ignored because it is similar to \kwmatch.}

\subsection{\gallina{} Conversion Rules}\label{sec:conversion-rules}

% based on sphinx/language/core/conversion.rst and doc/sphinx/language/core/inductive.rst
\begin{gather*}
  \text{beta:}~
    E[\Gamma] \vdash ((\lam{x}{t})\:u) \reltri \subst{t}{x}{u} \\
  \text{delta-local:}~
    \dfrac{(x:=t) \in \Gamma}{E[\Gamma] \vdash x \reltri t} \\
  \text{delta-global:}~
    \dfrac{(c:=t) \in E}{E[\Gamma] \vdash c \reltri t} \\
  \text{zeta:}~
    E[\Gamma] \vdash \letin{x}{t}{u} \reltri \subst{u}{x}{t} \\
  \text{iota-match:}~
    \dfrac
    {
      E[\Gamma] \vdash C_j\:u_1\ldots u_{p+m} : T \quad
      \text{$p$ is the number of parameters of the inductive type $T$}
    }{
      E[\Gamma] \vdash
      \match{(C_j\:u_1\ldots u_{p+m})}{C_i}{t_i}{i=1\ldots h}
      \reltri
      t_j\:u_{p+1}\ldots u_{p+m}
    } \\
  \text{iota-fix:}~
    \dfrac{
      u_{k_j} = C\:u'_1\ldots u'_m
    }{
      \begin{aligned}
        E[\Gamma] \vdash\; &
          (\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_j})\:u_1 \ldots u_{k_j} \\
        \reltri\; &
          \subst{t_j}{f_k}{\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_k}}_{k=1\ldots h} \:u_1 \ldots u_{k_j}
      \end{aligned}
    } \\
  \text{eta expansion:}~
    \dfrac{\WTEG{t}{\prodT{x}{T}{U}}}{E[\Gamma] \vdash t \reltri \lamT{x}{T}{(t\:x)}}
\end{gather*}
{\small Note:
\begin{itemize}
  \item The rules shown here are reductions, except the eta expansion.
  \item $\subst{t}{x}{u}$ means a term in which $x$ in term $t$ is replaced by $u$.
    This notation is taken from the Coq reference manual~\cite{coqrefman8.12.0}.
  \item Variables cannot conflict because \coq{} uses de Bruijn's indexes to represent variables.
  \item $E$ is a global environment which is a list of
    global assumptions $\gassum{c}{T}$,
    global definitions $\glodef{c}{t}{T}$, and
    inductive definitions ($\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$).
  \item $\Gamma$ is a local context which is a list of
    local assumptions $\lassum{x}{T}$ and
    local definitions $\ldef{x}{t}{T}$.
    The local assumptions represent variables bounded by outer abstractions and fixpoints.
    The local definitions represent variables bounded by outer let-in.
  \item If it is unambiguous, we omit type annotations in these definitions for the sake of simplicity.
  \item Iota-match reduces $\kwmatch\:\mathtt{@cons\:nat\:1\:nil}\:\kwwith\:(\mathtt{nil} \Rightarrow t_1)\:(\mathtt{cons} \Rightarrow t_2)\:\kwend$ to $t_2\:1\:\mathtt{nil}$
    because \lstinline!list! has one parameter $(p=1)$ and \lstinline!cons! has two members $(m=2)$.
\end{itemize}}

\section{CodeGen}\label{sec:codegen}

\begin{itemize}
\item Convertible Transformations
  \begin{itemize}
  \item Inlining
  \item Strip Cast
  \item Eta Expansion for Functions
  \item V-Normalization
  \item S-Normalization
  \item Type Normalization
  \item Static Argument Normalization
  \item Unused let-in Deletion
  \item Call Site Replacement
  \item Argument Completion
  \item Move Match Argument
  \item Borrow Check
  \item C Variable Allocation
  \end{itemize}
\item C Code Generation
  \begin{itemize}
  \item C Code Generation
  \end{itemize}
\end{itemize}

\section{Convertible Transformations}\label{sec:convertible-transformations}

\subsection{Inlining}\label{sec:inlining}
\subsection{Strip Cast}\label{sec:strip-cast}
\subsection{Eta Expansion for Functions}\label{sec:eta-expand-funcs}
We apply eta-expansion to functions of top-level functions, fix-bounded functions, and closure generating lambdas.
We consider explicit lambdas are closure generation.
(Lambdas for match-branches are implicit and we don't consider them as closure generation.)
This makes beta-var applicable for partial applications without worrying to expose computation.

\subsection{V-Normalization}\label{sec:v-normalization}
\subsubsection{V-Reductions}\label{sec:v-reductions}
\begin{gather*}
  \text{zeta-arg:}~
    \dfrac
    {
      E[\Gamma] \vdash t_i : T_i \quad
      \text{$t_0$ is not an application} \quad
      \text{$t_i$ is not a variable} \quad
      \text{$x_i$ is a fresh variable}
    }{
      E[\Gamma] \vdash
      t_0\:x_1 \ldots x_{i-1}\:t_i\:t_{i+1} \ldots t_n
      \reltri
      \letin{x_i}{t_i:T_i}{t_0\:x_1 \ldots x_{i-1}\:x_i\:t_{i+1} \ldots t_n}
    } \\
  \text{zeta-item:}~
    \dfrac
    {
      E[\Gamma] \vdash t_0 : T_0 \quad
      \text{$t_0$ is not a variable} \quad
      \text{$x_0$ is a fresh variable}
    }{
      \begin{aligned}
      E[\Gamma] \vdash\; &
        \match{t_0}{C_i}{t_i}{i=1\ldots h} \\
      \reltri\; &
        \letin{x_0}{t_0:T_0}{\match{x_0}{C_i}{t_i}{i=1\ldots h}}
      \end{aligned}
    }
\end{gather*}

\subsubsection{V-Normal Form}\label{sec:v-normal-form}
V-normal form restricts \gallina{} terms that (1) application arguments and (2) match items to variables.
\begin{align*}
  t =&\ x~|~c~|~C~|~T~|~\lamT{x}{T}{t}~|~ \letin{x}{t:T}{u} \\
    |&\ \fixT{f_i/k_i}{T_i}{t_i}{i=1\ldots h}{f_j} \\
    |&\ t\:x                               & \leftarrow (1) \\
    |&\ \match{x}{C_i}{t_i}{i=1\ldots h} & \leftarrow (2)
\end{align*}

\subsection{S-Normalization}\label{sec:s-normalization}
\begin{gather*}
  \text{beta-var:}~
    E[\Gamma] \vdash (\lam{x}{t})\:y \reltri \subst{t}{x}{y} \\
  \text{delta-var:}~
    \dfrac{(x:=y) \in \Gamma}{E[\Gamma] \vdash x \reltri y} \\
  \text{delta-fun:}~
     \dfrac
     {
       0 \leq p \quad
       0 < q \quad
       (f := t\:x_1\ldots x_p) \in \Gamma \quad
       \text{$t$ is one of $x, c, C, \lam{x}{u}, \fix{f_i/k_i}{t_i}{i=1\ldots h}{f_j}$}
     }{
       E[\Gamma] \vdash f\:y_1\ldots y_q
                        \reltri
                        t\:x_1\ldots x_p\:y_1\ldots y_q
     } \\
  \text{zeta-flat:}~
    E[\Gamma] \vdash \letin{y}{(\letin{x}{t_1}{t_2})}{t_0}
                       \reltri
                       \letin{x}{t_1}{(\letin{y}{t_2}{t_0})} \\
  \text{zeta-app:}~
    E[\Gamma] \vdash
     (\letin{x_0}{t}{u})\:x_1\ldots x_n
     \reltri
     \letin{x_0}{t}{(u\:x_1\ldots x_n)} \\
  \text{iota-match-var:}~
    \dfrac
    {
      (x:=C_j\:y_1\ldots y_{p+m}:T) \in \Gamma \quad
      \text{$p$ is the number of parameters of the inductive type $T$}
    }{
      E[\Gamma] \vdash
      \match{x}{C_i}{t_i}{i=1\ldots h}
      \reltri
      t_j\:y_{p+1}\ldots y_{p+m}
    } \\
  \text{iota-fix-var:}~
    \dfrac
    {
      \begin{gathered}
        (x_{k_j} := C\:y_1\ldots y_m) \in \Gamma \quad
        \text{$f'_1\ldots f'_h$ are fresh variables} \\
        E[\Gamma] \vdash (\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_j})\:x_1\ldots x_n : T \quad
        \text{$T$ is an inductive type}
      \end{gathered}
    }{
      \begin{aligned}
        E[\Gamma] \vdash\; &
          (\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_j})\:x_1\ldots x_n \\
        \reltri\; &
          \begin{aligned}[t]
          & \letinB{f'_1}{\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_1}} ~\ldots \\
          & \letinB{f'_h}{\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_h}} \\
          & \subst{t_j}{f_k}{f'_k}_{k=1\ldots h} \:x_1 \ldots x_n
          \end{aligned}
      \end{aligned}
    } \\
  \text{iota-fix-var':}~
    \dfrac
    {
      \begin{gathered}
        (x_{k_j} := C\:y_1\ldots y_m) \in \Gamma \\
        (f'_1 := \fix{f_i/k_i}{t_i}{i=1\ldots h}{f_1}) \in \Gamma ~\ldots~
        (f'_h := \fix{f_i/k_i}{t_i}{i=1\ldots h}{f_h}) \in \Gamma \\
        E[\Gamma] \vdash (\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_j})\:x_1\ldots x_n : T \quad
        \text{$T$ is an inductive type}
      \end{gathered}
    }{
      E[\Gamma] \vdash
      (\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_j})\:x_1\ldots x_n
      \reltri
      \subst{t_j}{f_k}{f'_k}_{k=1\ldots h} \:x_1 \ldots x_n
    }
\end{gather*}

\subsection{Type Normalization}\label{sec:type-normalization}
\subsection{Static Argument Normalization}\label{sec:static-argument-normalization}
\subsection{Unused let-in Deletion}\label{sec:let-in-deletion}
\begin{gather*}
  \text{zeta-del:}~
    \dfrac{
      \text{$x$ does not occur in $u$} \quad \text{$x$ is not linear} \quad \text{$\FV(t)$ does not contain linear variable}
    }{E[\Gamma] \vdash \letin{x}{t}{u}
                       \reltri
                       u
    }
\end{gather*}
{\small Note:
\begin{itemize}
  \item $\FV(t)$ means the free variables of $t$.
\end{itemize}}

\subsection{Call Site Replacement}\label{sec:call-site-replacement}

\subsection{Argument Completion}\label{sec:argcomp}
Argument completion removes partial applications by applying eta expansions.
\begin{itemize}
  \item $\F{t}$ considers t to be a top-level function or a closure-generating expression.  $\Fop$ transforms $t$ to be a nested abstraction expression that takes all arguments.
    Fixpoint expressions are allowed outside or between the abstractions.
  \item $\BR{t}{m}{q}$ transforms a branch of a match expression into a nested abstraction expression that takes constructor members.
    Fixpoint expressions are not allowed.
  \item $\E{t}{x_1\ldots x_p}{q}$ is a term convertible with $t\:x_1\ldots x_p$ that does not contain a partial application.
    $\E{t}{x_1\ldots x_p}{q}$ traverses $t$ while tracking the arguments for $t$ to find closure-generating expressions.
    The number of arguments given to $t$ is $p+q$.
    The first $p$ arguments are $x_1\ldots x_p$ and they can be the argument of beta-var redex.
    The last $q$ arguments cannot be the argument of beta-var redex.
\end{itemize}
\[
  \F{t} =
  \begin{cases}
    \lam{x}{\F{u}} & t = \lam{x}{u} \\
    \fix{f_i}{\F{t_i}}{i=1\ldots h}{f_j}  & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
    \lambda x_1\ldots\lamB{x_m}\E{t}{x_1\ldots x_m}{0}        & \text{otherwise} \quad \text{(eta expansion)}
  \end{cases}
\]
\[ \quad\text{where} \quad
  \begin{aligned}[t]
    & t : T_1 \rightarrow \dotsb \rightarrow T_m \rightarrow T_0 \\
    & \text{$T_0$ is an inductive type} \\
    & \text{$x_1\ldots x_m$ are fresh variables}
  \end{aligned}
\]
\[
  \BR{t}{m}{q} =
  \begin{cases}
    \E{t}{}{q}    & m = 0 \\
    \lam{x}{\BR{u}{m-1}{q}} & (m > 0) \wedge (t = \lam{x}{u}) \\
    \lambda x_1\ldots\lamB{x_m}\E{t}{x_1\ldots x_m}{q}        & \text{otherwise} \quad \text{(eta expansion)}
  \end{cases}
\]
\[ \quad\text{where} \quad
  \begin{aligned}[t]
    & \text{$x_1\ldots x_m$ are fresh variables}
  \end{aligned}
\]
\[
  \E{t}{x_1\ldots x_p}{q} =
  \begin{cases}
    x                                                                                                 & (t = x) \wedge (p = q = 0) \\
    x\:x_1\ldots x_p                                                                                    & (t = x) \wedge \neg (p = q = 0) \wedge (r = 0) \\
    \F{x\:x_1\ldots x_p}                                                                                 & (t = x) \wedge \neg (p = q = 0) \wedge (r > 0) \\
    t\:x_1\ldots x_p                                                                                    & ((t = c) \vee (t = C)) \wedge (r = 0) \\
    \F{t\:x_1\ldots x_p}                                                                                 & ((t = c) \vee (t = C)) \wedge (r > 0) \\
    \E{\subst{u}{x}{x_1}}{x_2\ldots x_p}{q}                                                             & (t = \lam{x}{u}) \wedge (p > 0) \quad \text{(beta-var)} \\
    \F{t}                                                                                              & (t = \lam{x}{u}) \wedge (p = 0) \\
    \E{u}{x_0\:x_1\ldots x_p}{q}                                                                & t = u\:x_0 \\
    \letin{x}{\E{t_1}{}{0}}{\E{t_2}{x_1\ldots x_p}{q}}                                                            & t = \letin{x}{t_1}{t_2} \quad \text{(zeta-app)} \\
    \match{x}{C_i}{\BR{t_i}{\NM_{C_i}}{p+q}}{i=1\ldots h}\:x_1\ldots x_p                                   & t = \match{x}{C_i}{t_i}{i=1\ldots h} \\
    (\fix{f_i}{\F{t_i}}{i=1\ldots h}{f_j})\:x_1\ldots x_p                                             & (t = \fix{f_i}{t_i}{i=1\ldots h}{f_j}) \wedge (r = 0) \\
    \F{t\:x_1\ldots x_p}                                             & (t = \fix{f_i}{t_i}{i=1\ldots h}{f_j}) \wedge (r > 0)
  \end{cases}
\]
\[ \quad\text{where} \quad
  \begin{aligned}[t]
    & t : T_1 \rightarrow \dotsb \rightarrow T_p \rightarrow
          T_{p+1} \rightarrow \dotsb \rightarrow T_{p+q} \rightarrow
          T_{p+q+1} \rightarrow \dotsb \rightarrow T_{p+q+r} \rightarrow T_0 \\
    & \text{$T_0$ is an inductive type} \\
  \end{aligned}
\]
{\small Note:
\begin{itemize}
  \item This transformation assumes $t$ is not dependently typed: no type terms and no dependent \kwmatch-expressions.
  \item $\NM_C$ is the number of the members of the constructor $C$ (the number of arguments without the parameters for the inductive type): \\
    $\NM_C=m$ if $C : T_1 \rightarrow \dotsb \rightarrow T_p \rightarrow T_{p+1} \rightarrow \dotsb \rightarrow T_{p+m} \rightarrow T_0$ and $T_0$ is an inductive type which has $p$ parameters.
\end{itemize}}

\subsection{Move Match Argument}\label{sec:move-match-argument}

\begin{gather*}
  \text{match-app:}~
    \dfrac
    {
      E[\Gamma] \vdash z : T
    }{
      \begin{aligned}
        E[\Gamma] \vdash\; &
          \kwmatch\:x\:
          \kwas\:x'\:
          \kwin\:I\:\_\ldots \_\:y_1\ldots y_{\NI_I}\:
          \kwreturn\:{T \rightarrow P\:y_1\ldots y_{\NI_I}\:x'}\\
          & \kwwith\:({C_i\: x_{i1}\ldots x_{i\NM_{C_i}}} \Rightarrow {t_i})_{i=1\ldots h}\:
          \kwend\:z \\
        \reltri\; &
          \kwmatch\:x\:
          \kwas\:x'\:
          \kwin\:I\:\_\ldots \_\:y_1\ldots y_{\NI_I}\:
          \kwreturn\:{P\:y_1\ldots y_{\NI_I}\:x'}\\
          & \kwwith\:({C_i\: x_{i1}\ldots x_{i\NM_{C_i}}} \Rightarrow {t_i\:z})_{i=1\ldots h}\:
          \kwend
      \end{aligned}
    }
\end{gather*}

beta-var and zeta-app are also applied.

{\small Note:
\begin{itemize}
  \item match-app is not convertible
  \item $\NI_I$ is the number of the indexes of the inductive type $I$ (the number of arguments without the parameters for the inductive type): \\
    $\NI_I=m$ if $I : T_1 \rightarrow \dotsb \rightarrow T_p \rightarrow T_{p+1} \rightarrow \dotsb \rightarrow T_{p+m} \rightarrow S$ and $S$ is a sort.
\end{itemize}}

\subsection{Borrow Check}\label{sec:borrow-check}

We define two judgements $E[\Gamma'] \vdash t:T~|~B$ and $E[\Gamma'] \vdash t:T~|~(L, B^\text{used}, B^\text{result})$ for borrow check.
$\Gamma'$ is an annotated local context.
It is a list of $\lassum{x^B}{T}$ or $\ldef{x^B}{t}{T}$.
The variable $x$ is annotated with a borrow information $B$.
$B$ is a set of pair of borrow type and linear variable, such as $\{(T_1,x_1),\ldots\}$.
$B^\text{used}$ and $B^\text{result}$ are also borrow information.
$L$ is a set of linear variables.
$T$ is the type of $t$.

We omit $:T$ in a rule which does not use $T$.

The borrow information $B=\{(T_1,x_1),\ldots\}$ represents a linear variable $x_i$ is used via borrow type $T_i$.
$\lassum{x^{\{(T',y)\}}}{T}\in \Gamma'$ represents $x$ may contain a value of type $T'$ which is a (part of) content of the linear variable $y$.

$E[\Gamma'] \vdash t~|~B$ means a function $t$ may use linear variables via borrow $B$.

$E[\Gamma'] \vdash t~|~(L, B^\text{used}, B^\text{result})$ means an expression $t$
(1) consumes linear variables $L$,
(2) may use linear values via borrow $B^\text{used}$,
(3) result value may contain linear values via borrow $B^\text{result}$.

For example, assume linear list \lstinline!lseq!, borrow list \lstinline!bseq! which has constructors \lstinline!bnil! and \lstinline!bcons!,
borrow function \lstinline!borrow : lseq nat -> bseq nat!.
In a code fragment \\
\lstinline!let y := borrow x in match y with bnil => true | bcons h t => false end! contains variables
\lstinline!x : lseq nat!,
\lstinline!y : bseq nat!,
\lstinline!h : nat!, and
\lstinline!t : bseq nat!.
\texttt{y} and \texttt{t} contain a \texttt{bseq nat} value borrowed from \texttt{x}.
It is represented as
$\texttt{y}^{\{(\texttt{bseq nat},\texttt{x})\}}:\text{\texttt{bseq nat}}$ and
$\texttt{t}^{\{(\texttt{bseq nat},\texttt{x})\}}:\text{\texttt{bseq nat}}$.
The type of \texttt{h} is \texttt{nat}.
Since \texttt{nat} is not a borrow type, \texttt{h} lives even after \texttt{x} is consumed.

\begin{gather*}
  \text{borrow-lvar:}~
    \dfrac
    {
      \lassum{x^B}{T} \in \Gamma' \quad \text{$x$ is linear}
    }{
      E[\Gamma'] \vdash x ~|~ (\{x\}, B, B)
    } \\
  \text{borrow-var:}~
    \dfrac
    {
      \lassum{x^B}{T} \in \Gamma' \quad \text{$x$ is not linear}
    }{
      E[\Gamma'] \vdash x ~|~ (\varnothing, B, B)
    } \\
  \text{borrow-constant:}~
    \dfrac
    {
      \text{$c$ is not a borrow function}
    }{
      E[\Gamma'] \vdash c ~|~ (\varnothing, \varnothing, \varnothing)
    } \\
  \text{borrow-constructor:}~
    E[\Gamma'] \vdash C ~|~ (\varnothing, \varnothing, \varnothing) \\
  \text{borrow-letin:}~
    \dfrac
    {
      \begin{gathered}
        E[\Gamma'] \vdash t_1 ~|~ (L_1, B^\text{used}_1, B^\text{result}_1) \\
        E[\Gamma';\ldef{x^{B^\text{result}_1}}{t_1}{T}] \vdash t_2 ~|~ (L_2, B^\text{used}_2, B^\text{result}_2) \\
        L_1 \cap L_2 = \varnothing \\
        \text{$x$ is linear} \rightarrow x \in L_2 \\
        L_1 \cap B^\text{used}_2 = \varnothing
      \end{gathered}
    }{
      E[\Gamma'] \vdash \letin{x}{t_1:T}{t_2} ~|~ (L_1\cup L_2 - \{x\}, B^\text{used}_1\cup B^\text{used}_2 - \{x\}, B^\text{result}_2 - \{x\})
    } \\
  \text{borrow-match:}~
    \dfrac{
      \begin{gathered}
        E[\Gamma'] \vdash t_0 ~|~(L_0, B^\text{used}_0, B^\text{result}_0) \\
        B_{ij} = B^\text{result}_0 ~\text{filtered with the type of $x_{ij}$} \\
        \Gamma'_i = \lassum{x_{i1}^{B_{i1}}}{T_{i1}}; \ldots ; \lassum{x_{i\NM_{C_i}}^{B_{i\NM_{C_i}}}}{T_{i\NM_{C_i}}} \\
        E[\Gamma' ; \Gamma'_i] \vdash t_i ~|~(L_i, B^\text{used}_i, B^\text{result}_i) \\
        L^\text{M}_i = L_i \cap \{x_{i1},\ldots, x_{i\NM_{C_i}}\} \quad
        L^\text{F}_i = L_i - \{x_{i1},\ldots, x_{i\NM_{C_i}}\} \\
        L^\text{M}_i = \{ x_{ij} | 1 \leq j \leq \NM_{C_i} ~\wedge~ \text{$x_{ij}$ is linear} \} \quad
        L^\text{F}_1 = \cdots = L^\text{F}_h \quad
        L_0 \cap L^{F}_1 = \varnothing \\
        {B'}^\text{used}_i = B^\text{used}_1 - \{x_{i1},\ldots, x_{i\NM_{C_i}}\} \quad
        {B'}^\text{result}_i = B^\text{result}_1 - \{x_{i1},\ldots, x_{i\NM_{C_i}}\} \\
        B^\text{used} = {B'}^\text{used}_1 \cup \cdots \cup {B'}^\text{used}_h \quad
        B^\text{result} = {B'}^\text{result}_1 \cup \cdots \cup {B'}^\text{result}_h \quad
        L_0 \cap B^\text{used} = \varnothing \\
      \end{gathered}
    }{
      E[\Gamma'] \vdash \match{t_0}{C_i\: x_{i1}\ldots x_{i\NM_{C_i}}}{t_i}{i=1\ldots h} ~|~ (L_0 \cup L^\text{F}_1, B^\text{used}_0 \cup B^\text{used}, B^\text{result})
    } \\
  \text{borrow-var-app:}~
    \dfrac{
      \begin{gathered}
        \lassum{x_0^{B}}{T'} \in \Gamma' \quad
        \APP(\Gamma', B, x_1 \ldots x_n, T, L, B^\text{used}, B^\text{result})
      \end{gathered}
    }{
      E[\Gamma'] \vdash x_0\:x_1\ldots x_n : T ~|~ (L, B^\text{used}, B^\text{result})
    } \\
  \text{borrow-constant-app:}~
    \dfrac{
      \begin{gathered}
        \text{$c$ is not a borrow function} \quad
        \APP(\Gamma', \varnothing, x_1 \ldots x_n, T, L, B^\text{used}, B^\text{result})
      \end{gathered}
    }{
      E[\Gamma'] \vdash c\:x_1\ldots x_n : T ~|~ (L, B^\text{used}, B^\text{result})
    } \\
  \text{borrow-constructor-app:}~
    \dfrac{
      \APP(\Gamma', \varnothing, x_1 \ldots x_n, T, L, B^\text{used}, B^\text{result})
    }{
      E[\Gamma'] \vdash C\:x_1\ldots x_n : T ~|~ (L, B^\text{used}, B^\text{result})
    } \\
  \text{borrow-fix-app:}~
    \dfrac{
      \begin{gathered}
        E[\Gamma'] \vdash \fix{f_i}{t_i}{i=1\ldots h}{f_j} ~|~ B \quad
        \APP(\Gamma', B, x_1 \ldots x_n, T, L, B^\text{used}, B^\text{result})
      \end{gathered}
    }{
      E[\Gamma'] \vdash (\fix{f_i}{t_i}{i=1\ldots h}{f_j})\:x_1\ldots x_n : T ~|~ (L, B^\text{used}, B^\text{result})
    } \\
  \text{borrow-borrow:}~
    \dfrac{
      \begin{gathered}
        \text{$c$ is a borrow function} \\
        E[\Gamma'] \vdash c : T^\text{arg} \rightarrow T^\text{result} \quad
        \text{$T^\text{arg}$ is a linear type} \quad
        \text{$T^\text{result}$ is a borrow type} \\
        \text{$T^\text{result}$ does not contain function} \\
        \text{$\{T_1, \ldots, T_n\}$ is a set of borrow types contained in $T^\text{result}$} \\
        B = \{(T_1,x),\ldots,(T_n,x)\}
      \end{gathered}
    }{
      E[\Gamma'] \vdash c\:x ~|~ (\varnothing, B, B)
    } \\
  \text{borrow-fix-clo:}~
    \dfrac{
      E[\Gamma'] \vdash \fix{f_i}{t_i}{i=1\ldots h}{f_j} ~|~ B
    }{
      E[\Gamma'] \vdash \fix{f_i}{t_i}{i=1\ldots h}{f_j} ~|~ (\varnothing, B, B)
    } \\
  \text{borrow-abs-clo:}~
    \dfrac{
      E[\Gamma'] \vdash \lam{x}{t} ~|~ B
    }{
      E[\Gamma'] \vdash \lam{x}{t} ~|~ (\varnothing, B, B)
    } \\
\end{gather*}

\begin{gather*}
  \text{borrow-abs-fun:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is not an abstraction} \\
        \text{$t$ is not a fixpoint} \\
        E[\Gamma';\lassum{x_1^\varnothing}{T_1};\ldots;\lassum{x_n^\varnothing}{T_n}] \vdash t : T ~|~ (L,B^\text{used},B^\text{result}) \\
        \{ x_i | 1 \leq i \leq n \wedge \text{$x_i$ is linear} \} = L \\
        B' = (B^\text{used} - \{x_1,\ldots x_n\}) ~\text{filtered with the type of $T$} \\
      \end{gathered}
    }{
      E[\Gamma'] \vdash \lamTB{x_1}{T_1}\ldots\lamTB{x_n}{T_n}t ~|~ B'
    } \\
  \text{borrow-abs-fix:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is a fixpoint} \\
        E[\Gamma';\lassum{x_1^\varnothing}{T_1};\ldots;\lassum{x_n^\varnothing}{T_n}] \vdash t ~|~ B \\
        \forall 1 \leq i \leq n, \text{$x_i$ is not linear} \\
      \end{gathered}
    }{
      E[\Gamma'] \vdash \lamTB{x_1}{T_1}\ldots\lamTB{x_n}{T_n}t ~|~ B
    } \\
  \text{borrow-fix-fun:}~
    \dfrac{
      \begin{gathered}
        E[\Gamma';\lassum{f_1^\varnothing}{T_1};\ldots;\lassum{f_h^\varnothing}{T_h}] \vdash t_i ~|~ B_i \\
        B = B_1\cup \cdots \cup B_h
      \end{gathered}
    }{
      E[\Gamma'] \vdash \fixT{f_i}{T_i}{t_i}{i=1\ldots h}{f_j} ~|~ B
    } \\
\end{gather*}

\begin{align*}
  &\APP(\Gamma', B, x_1 \ldots x_n, T, L, B^\text{used}, B^\text{result}) \\
  &= 1 \leq n \\
  &~\wedge \forall 1 \leq i \leq n, \forall 1 \leq j \leq n, (i \neq j \rightarrow \neg (x_i = x_j \wedge \text{$x_i$ is linear})) \\
  &~\wedge L = \{ x_i | 1 \leq i \leq n \wedge \text{$x_i$ is linear} \} \\
  &~\wedge B^\text{used} = B \cup \{ B' | 1 \leq i \leq n \wedge \lassum{x_i^{B'}}{T'} \in \Gamma' \} \\
  &~\wedge B^\text{result} = B^\text{used} ~\text{filtered with the type $T$} \\
  &~\wedge B^\text{used} \cap L = \varnothing \\
\end{align*}

We mix borrow information and set of variables in set-operations.
Assume $L=\{x_1,\ldots,x_n\}$ and $B=\{(T_1,y_1),\ldots,(T_m,y_m)\}$.

\begin{align*}
  B \cap L = L \cap B &= \{(T_i,y_i) \in B ~|~ 1\leq i\leq m,~ y_i \in L \} \\
  B - L &= \{(T_i,y_i) \in B ~|~ 1\leq i\leq m,~ y_i \not\in L \}
\end{align*}

{\small Note:
\begin{itemize}
  \item borrow-fix-fun annotates $f_1^\varnothing \ldots f_n^\varnothing$.
    This is not correct because $f_1\ldots f_n$ may refer borrowed values via free variables in
    $\fixT{f_i}{T_i}{t_i}{i=1\ldots h}{f_j}$.
    However, it is harmless because corresponding linear value cannot be consumed in the fix-term.
\end{itemize}}

\subsection{C Variable Allocation}\label{sec:cvaralloc}

\begin{align*}
  x :&\ \mbox{\gallina{} variable} \\
  v :&\ \mbox{C variable} \\
  V =&\ \mathit{empty} ~|~ x \mapsto v ~|~ V;V
\end{align*}

\begin{itemize}
  \item $\cv{t}{x_1\ldots x_n}{V}$ is the variable mapping of the variables declared in $t$.
  \item $x_1\ldots x_n$ are arguments for $t$.
  \item $V$ is the variable mapping for variables declared outside.
\end{itemize}
\[
  \cv{t}{x_1\ldots x_n}{V} =
  \begin{cases}
    empty                                             & (t = x) \vee (t = c) \vee (t = C) \vee (t = T) \\
    \cv{u}{}{V; M}; M                                & (t = \lam{x}{u}) \wedge (n = 0) \quad \text{where}~M = x\mapsto v \\
    \cv{u}{x_2\ldots x_n}{V; M}; M                    & (t = \lam{x}{u}) \wedge (n > 0) \quad \text{where}~M = x\mapsto V(x_1) \\
    \cv{u}{x_0\:x_1\ldots x_n}V                        & t = u\:x_0 \\
    \cv{t_1}{}{V}; \cv{t_2}{x_1\ldots x_n}{V; M}; M    & t = \letin{x}{t_1}{t_2} \quad \text{where}~M = x\mapsto v \\
    \begin{aligned}[t]
      (&\cv{t_1}{x_1\ldots x_n}{V;M_1};\ldots; \\
       &\cv{t_h}{x_1\ldots x_n}{V;M_h}; \\
       &M_1;\ldots;M_h)
    \end{aligned} &                                   \begin{aligned}[t]
                                                        &t = \match{x}{C_i}{\lambda y_{i1}\ldots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\ldots h} \\
                                                        &\text{where}~M_i = y_{i1}\mapsto v_{i1}; \ldots; y_{i\NM_{C_i}}\mapsto v_{i\NM_{C_i}}
                                                      \end{aligned} \\
    \cv{t_1}{}{V;M}; \ldots; \cv{t_h}{}{V;M}; M &    \begin{aligned}[t]
                                                        &t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
                                                        &\text{where}~M = f_1\mapsto v_1;\ldots; f_h\mapsto v_h
                                                      \end{aligned}
  \end{cases}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$v, v_i, v_{ij}$ are fresh C variables}
  \end{aligned}
\]
{\small Note: \quad We consider \gallina{} variables unique.}

\section{C Code Generation}\label{sec:c-code-gen}
\subsection{The \gallina{} Subset For C Code Generation}\label{sec:gallinasubsetforcgen}
\begin{gather*}
  E[\Gamma] \vdashb x \qquad
  E[\Gamma] \vdashb c \qquad
  E[\Gamma] \vdashb C \\
  \dfrac{
    E[\Gamma] \vdashb t \quad
    E[\Gamma] \vdash x : T \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashb t\:x
  } \\
  \dfrac{
    E[\Gamma] \vdashb t \quad
    E[\Gamma;\ldef{x}{t}{T}] \vdashb u \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashb \letin{x}{t:T}{u}
  } \\
  \dfrac{
    \begin{gathered}
      E[\Gamma] \vdash x:T \quad
      \text{$T$ is a non-dependent inductive type with $p$ parameters:}~I\:u_1\ldots u_p \\
      E[] \vdash C_i\:u_1\ldots u_p: T_{i1} \rightarrow \dotsb \rightarrow T_{i\NM_{C_i}} \rightarrow T \quad
      \text{$T_{ij}$ are non-dependent inductive types} \\
      E[\Gamma;\lassum{y_{i1}}{T_{i1}};\ldots;\lassum{y_{i\NM_{C_i}}}{T_{i\NM_{C_i}}}] \vdashb t_i
    \end{gathered}
  }{
    E[\Gamma] \vdashb \match{x}{C_i}{\lambda y_{i1}\ldots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\ldots h}
  } \\
  \dfrac{
    E[\Gamma;\lassum{x}{T}] \vdashb t \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashb \lamT{x}{T}{t}
  } \\
  \dfrac{
    E[\Gamma] \vdashf \fix{f_i:T_i}{t_i}{i=1\ldots h}{f_j}
  }{
    E[\Gamma] \vdashb \fix{f_i:T_i}{t_i}{i=1\ldots h}{f_j}
  } \\
  \\
  \dfrac{
    E[\Gamma] \vdash t : T \quad
    \text{$T$ is a non-dependent inductive type} \quad
    E[\Gamma] \vdashb t
  }{
    E[\Gamma] \vdashf t
  } \\
  \dfrac{
    E[\Gamma;\lassum{x}{T}] \vdashf t \quad
    \text{$T$ is a non-dependent inductive type}
  }{
    E[\Gamma] \vdashf \lamT{x}{T}{t}
  } \\
  \dfrac{
    E[\Gamma;\lassum{f_1}{T_1};\ldots;\lassum{f_h}{T_h}] \vdashf t_i
  }{
    E[\Gamma] \vdashf \fix{f_i:T_i}{t_i}{i=1\ldots h}{f_j}
  }
\end{gather*}

\subsection{Detection of Inlinable Fixpoints}\label{sec:inlinable-fixpoint-detection}
We detect inlinable fixpoints.
``Inlinable fixpoint'' means a fixpoint, $\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_j}$,
which all application to $f_i$ is located at the tail positions of $f_1\ldots f_h$.
In this case, the continuation of the applications to $f_1\ldots f_h$
in $\letin{x}{(\fix{f_i/k_i}{t_i}{i=1\ldots h}{f_j})\;x_1\ldots x_n}{u}$
are always $\letin{x}{\Box}{u}$.
Thus, we can translate the tail positions of $f_1\ldots f_h$ to
(1) assignments to the arguments of $f_i$ and $\kwgoto{}\;f_i$ for application to $f_i$ and
(2) assignment to $x$ and $\kwgoto{}\;u$ otherwise.
This translation is equivalent to inlining a recursive function, which means generating a loop at a non-tail position.

$\TR{t}{n}$ is the first element of $\RNT{t}{n}$.
$(R,N,T) = \RNT{t}{n}$ classify variables in $t$ assuming that it is called with $n$ arguments as $t\:x_1\ldots x_n$:
\begin{align*}
  R &: \text{tail-recursive fixpoint bounded functions that do not need to be real functions} \\
  N &: \text{free variables at non-tail positions of $t$} \\
  T &: \text{free variables at tail positions of $t$}
\end{align*}
``tail position'' is extended to the function position of the application at a tail position. \\
$R$ distinguishes fixpoint bounded functions translatable without actual functions (but with \kwgoto{}) or not.
\[ \TR{t}{n} = R \quad \text{where}\quad (R,N,T) = \RNT{t}{n} \]
\begin{align*}
  &\RNT{t}{n} = \\
  &\begin{cases}
    (\varnothing, \varnothing, \{x\})             & t = x \\
    (\varnothing, \varnothing, \varnothing)         & (t = c) \vee (t = C) \\
    (R, N \cup \{x\}, T)         & t = u\:x \quad \text{where}\quad (R,N,T) = \RNT{u}{n+1} \\
    (R_1 \cup R_2, N_1 \cup T_1 \cup N_2 - \{x\}, T_2 - \{x\})        &
      \begin{aligned}[t]
        & t = \letin{x}{t_1}{t_2} \\
        & \text{where}\quad (R_1,N_1,T_1) = \RNT{t_1}{0} \quad (R_2,N_2,T_2) = \RNT{t_2}{n}
      \end{aligned} \\
    \bigl(\bigcup_{i=1}^h R_i, \bigcup_{i=1}^h N_i, \bigcup_{i=1}^h T_i \bigr)         &
      \begin{aligned}[t]
        & t = \match{x}{C_i}{t_i}{i=1\ldots h} \\
        & \text{where}~(R_i, N_i, T_i) = \RNT{t_i}{n+\NM_{C_i}}
      \end{aligned} \\
    (R, N-\{x\}, T - \{x\})                                           & (t = \lam{x}{u}) \wedge (n > 0) \quad \text{where}\quad  (R, N, T) = \RNT{u}{n-1} \\
    (R, (N \cup T) - \{x\}, \varnothing)                             & (t = \lam{x}{u}) \wedge (n = 0) \quad \text{where}\quad  (R, N, T) = \RNT{u}{\NA_u} \quad \text{(closure)} \\
    \begin{aligned}[t]
      \bigl( & \textstyle\bigcup_{i=1}^h R_i \cup \{f_1,\dotsc, f_h\}, \\
             & \textstyle\bigcup_{i=1}^h N_i - \{f_1,\dotsc, f_h\}, \\
             & \textstyle\bigcup_{i=1}^h T_i - \{f_1,\dotsc, f_h\} \bigr)
    \end{aligned} &
      \begin{aligned}[t]
        & (t = \fix{f_i}{t_i}{i=1\ldots h}{f_j}) \\
        & {} \wedge (n = \NA_t) \wedge \bigl(\textstyle\bigcup_{i=1}^h N_i \cap \{f_1,\dotsc, f_h\} = \varnothing\bigr) \\
        & \text{where}\quad (R_i, N_i, T_i) = \RNT{t_i}{\NA_{t_i}}
      \end{aligned} \\
    \begin{aligned}[t]
      \bigl( & \textstyle\bigcup_{i=1}^h R_i, \\
             & \textstyle\bigcup_{i=1}^h (N_i \cup T_i) - \{f_1,\dotsc, f_h\}, \\
             & \varnothing \bigr)
    \end{aligned} &
      \begin{aligned}[t]
        & (t = \fix{f_i}{t_i}{i=1\ldots h}{f_j}) \quad \text{(real function, maybe closure)} \\
        & {} \wedge \neg \bigl((n = \NA_t) \wedge \bigl(\textstyle\bigcup_{i=1}^h N_i \cap \{f_1,\dotsc, f_h\} = \varnothing\bigr)\bigr) \\
        & \text{where}\quad (R_i, N_i, T_i) = \RNT{t_i}{\NA_{t_i}}
      \end{aligned}
  \end{cases}
\end{align*}
{\small Note:
\begin{itemize}
  \item $\NA_t$ is the number of arguments of $t$: \quad $\NA_t=m$ if $t : T_1 \rightarrow \dotsb \rightarrow T_m \rightarrow T_0$ and $T_0$ is an inductive type.
  \item The variables in $t$ are unique.
    \codegen{} uses de Bruijn's indexes for $N$ and $T$;
    the variables renamed by \secref{sec:cvaralloc} for $R$.
  \item $x$ of $\match{x}{C_i}{t_i}{i=1\ldots h}$ is not counted because $x$ is not a function and does not affect the final result.
\end{itemize}}

\subsection{Top-Level Functions Detection}\label{sec:top-level-function-detection}
If a fixpoint needs recursive call in C, we need a real C function for it.
\codegen{} detects such fixpoints by simulating $A_K$ and $B_K$ in \secref{sec:AK} and \secref{sec:BK} to collect application of fixpoint-bounded functions.

\subsection{Outer-Variable}\label{sec:outer-variable}

\subsection{Translation to C for a Non-Tail Position}\label{sec:AK}
$\A{K}{t}{x_1\ldots x_n}$ generates C code for $t\:x_1\ldots x_n$ in a non-tail position.
The result expression is passed to $K$. \\
$K(e) = \dq{v = e\ttsemi}$ in simple situations.
\begin{align*}
  &\A{K}{x}{} = K(\dq{x}) \\
  &\A{K}{x}{x_1\ldots x_n} =
      \begin{aligned}[t] \ldq & {\passign(\fvarsd{x}, x_1 \ldots x_n)} \\ & \kwgoto\:\mathtt{entry\_}x\ttsemi \rdq \end{aligned}
    && \begin{aligned}[t] & (n > 0) \wedge \text{$x$ is bounded by a fixpoint} \wedge {} \\ & x \in \tr \end{aligned} \\
  &\A{K}{x}{x_1\ldots x_n} = K(\dq{x\ttparen{y_1\ttcomma\dotsc\ttcomma y_o\ttcomma x_1\ttcomma\dotsc\ttcomma  x_n}})
    && \begin{aligned}[t] & (n > 0) \wedge \text{$x$ is bounded by a fixpoint} \wedge {} \\ & x \not\in \tr \end{aligned} \\
  &\A{K}{c}{x_1\ldots x_n} = K(\dq{c\ttparen{x_1\ttcomma\dotsc\ttcomma x_n}})                                   && n \geq 0 \\
  &\A{K}{C}{x_1\ldots x_n} = K(\dq{C\ttparen{x_1\ttcomma\dotsc\ttcomma x_n}})                                   && n \geq 0 \\
  &\A{K}{t\:x_0}{x_1\ldots x_n} = \A{K}{t}{x_0\:x_1\ldots x_n} \\
  &\A{K}{\letin{x}{t_1}{t_2}}{x_1\ldots x_n} =
      \begin{aligned}[t] \ldq & \A{K'}{t_1}{} \\ & \A{K}{t_2}{x_1\ldots x_n} \rdq \end{aligned}
    && \text{where}\quad K'(e) = \dq{x\:\tteq\:e\ttsemi} \\
  &\A{K}{\lam{x}{t}}{x_1\:x_2\ldots x_n} = \A{K}{t}{x_2\ldots x_n}                                  && \text{($x$ and $x_1$ are mapped to the same C variable)} \\
  &\AbreakEq{K}{\match{x}{C_i}{\lambda y_{i1}\ldots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\ldots h}}{x_1\ldots x_n} && \text{where}\quad x : T \\
     & \quad\begin{alignedat}{2}
       \ldq & \kwswitch\:\ttparen{\mathit{swfunc}_T\ttparen{x}}\:\ttlbrace \\
            & \cdots \\
            & \mathit{caselabel}_{C_i}\ttcolon\quad
              \begin{aligned}[t]
              & y_{i1}\:\tteq\:\mathit{get\_member}_{C_i1}(x)\ttsemi \:\ldots\ttsemi \\
              & y_{i\NM_{C_i}}\:\tteq\:\mathit{get\_member}_{C_i\NM_{C_i}}(x)\ttsemi \\
              & \mathit{linear\_dealloc}_{T}(x)\ttsemi \\
              & {\A{K}{t_i}{x_1\ldots x_n}} \\
              & \kwbreak\ttsemi
              \end{aligned} \\
            & \cdots \\
            & \ttrbrace\rdq
       \end{alignedat} \\
  &\A{K}{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}{x_1\ldots x_n} =                   && f_j \in \tr \\
     & \quad\begin{alignedat}[t]{2}
       \ldq & \passign(\fvars{t_j}, x_1\ldots x_n) \\
            & {\genbodyat{K'}{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}} \\
            & \mathtt{exit\_}f_j\ttcolon \rdq
       \end{alignedat} &&
               \begin{alignedat}[t]{1}
                  & \text{where} \\
                  & K'(e) =
                    \begin{cases}
                    K(e) & \text{$K(e)$ contains \kwgoto}  \\
                    \begin{aligned}[t]
                      \ldq & K(e) \\
                           & \kwgoto\:\mathtt{exit\_}f_j\ttsemi \rdq
                    \end{aligned} & \text{otherwise}
                  \end{cases}
                \end{alignedat} \\
  &\A{K}{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}{x_1\ldots x_n} =                      && f_j \not\in \tr \\
     & \quad\begin{alignedat}[t]{2}
       \ldq & K(f_j\ttparen{y_1\ttcomma\dotsc\ttcomma y_o\ttcomma x_1\ttcomma\dotsc\ttcomma x_n})                  \\
            & \kwgoto\:\mathtt{skip\_}f_j\ttsemi                                    \\
            & {\genbodyan{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}}                          \\
            & \mathtt{skip\_}f_j\ttcolon \rdq
       \end{alignedat}
\end{align*}
{\small Note:
\begin{itemize}
  \item $\dq{\cdots}$ means a string.
    A string can contain characters in typewriter font and expressions starting in italic or roman font.
    The former is preserved as-is.
    The latter embeds the value of the expression (with name translation from \gallina{} to C).
  \item \gallina{} types, constants, and constructors have corresponding (user-configurable) C names and they are implicitly translated.
    \gallina{} variables are translated by the mapping defined in \secref{sec:cvaralloc}.
  \item $\tr = \TR{t}{n}$ where the translating function is defined as \kwDefinition~$c := t$ and $t$ is an $n$-arguments function.
  \item $\mathit{swfunc}_T, \mathit{caselabel}_{C_i}$, and $\mathit{get\_member}_{C_i j}$ are defined by a user to translate \kwmatch-expressions for the inductive type $T$.
  \item $\passign(y_1\ldots y_n, x_1\ldots x_n)$ is a parallel assignment. It is translated to a sequence of assignments to assign $x_1\ldots x_n$ into $y_1\ldots y_n$.  It may require temporary variables.
  \item $y_1,\dotsc,y_o$ are the outer variables of the fixpoint.
  \item We do not define $\A{K}{\lam{x}{t}}{}$ because we do not support closures yet.
  \item Actual \codegen{} generates $\genbodyan{}$ in a different position to avoid the label $\mathtt{skip\_}f_j$ and $\kwgoto\:\mathtt{skip\_}f_j\ttsemi$.
  \item $\mathit{linear\_dealloc}_{T}(x)$ is the deallocation function for the linear type $T$.  It is empty for unrestricted types.
\end{itemize}}

\subsection{Translation to C for a Tail Position}\label{sec:BK}
$\B{K}{t}{x_1\ldots x_n}$ generates C code for $t\:x_1\ldots x_n$ in a tail position.
The result expression is passed to $K$. \\
$K(e) = \dq{\kwCreturn\:e\ttsemi}$ in simple situations.
\begin{align*}
  &\B{K}{x}{} = K(\dq{x}) \\
  &\B{K}{x}{x_1\ldots x_n} = \begin{aligned}[t] \ldq & {\passign(\fvarsd{x}, x_1\ldots x_n)} \\ & \kwgoto\:\mathtt{entry\_}x\ttsemi \rdq \end{aligned}
    && (n > 0) \wedge \text{$x$ is bounded by a fixpoint} \\
  &\B{K}{c}{x_1\ldots x_n} = K(\dq{c\ttparen{x_1\ttcomma\dotsc\ttcomma x_n}})                                   && n \geq 0 \\
  &\B{K}{C}{x_1\ldots x_n} = K(\dq{C\ttparen{x_1\ttcomma\dotsc\ttcomma x_n}})                                   && n \geq 0 \\
  &\B{K}{t\:x_0}{x_1\ldots x_n} = \B{K}{t}{x_0\:x_1\ldots x_n} \\
  &\B{K}{\letin{x}{t_1}{t_2}}{x_1\ldots x_n} =
      \begin{aligned}[t] \ldq & \A{K'}{t_1}{} \\ & \B{K}{t_2}{x_1\ldots x_n} \rdq \end{aligned}
    && \text{where}\quad K'(e) = \dq{x\:\tteq\:e\ttsemi} \\
  &\B{K}{\lam{x}{t}}{x_1\:x_2\ldots x_n} = \B{K}{t}{x_2\ldots x_n}                                 && \text{($x$ and $x_1$ are mapped to the same C variable)} \\
  &\BbreakEq{K}{\match{x}{C_i}{\lambda y_{i1}\ldots\lamB{y_{i\NM_{C_i}}}t_i}{i=1\ldots h}}{x_1\ldots x_n} && \text{where}\quad x : T \\
     & \quad\begin{alignedat}{2}
       \ldq & \kwswitch\:\ttparen{\mathit{swfunc}_T\ttparen{x}}\:\ttlbrace \\
            & \cdots \\
            & \mathit{caselabel}_{C_i}\ttcolon\quad
              \begin{aligned}[t]
                & y_{i1}\:\tteq\:\mathit{get\_member}_{C_i1}(x)\ttsemi \:\ldots\ttsemi \\
                & y_{i\NM_{C_i}}\:\tteq\:\mathit{get\_member}_{C_i\NM_{C_i}}(x)\ttsemi \\
                & \mathit{linear\_dealloc}_{T}(x)\ttsemi \\
                & {\B{K}{t_i}{x_1\ldots x_n}}
              \end{aligned} \\
            & \cdots \\
            & \ttrbrace\rdq
     \end{alignedat} \\
  &\B{K}{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}{x_1\ldots x_n} =       \\
     & \quad\begin{alignedat}{2}
       \ldq & {\passign(\fvars{t_j}, x_1\ldots x_n)} \\
            & {\genbodyb{K}{\fix{f_i}{t_i}{i=1\ldots h}{f_j}}} \rdq
       \end{alignedat}
\end{align*}
{\small Note:
\begin{itemize}
  \item We do not define $\B{K}{\lam{x}{t}}{}$ because a tail position cannot be a function after the argument completion.
\end{itemize}}

\subsection{Auxiliary Functions for Translation to C}\label{sec:aux-function}
\[
  \fvars{t} =
  \begin{cases}
    \dq{x;\:\fvars{u}} & t = \lam{x}{u} \\
    \fvars{t_j}       & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
    \dq{}             & \text{otherwise}
  \end{cases}
\]
\[
  \fvarsd{f_i} = \fvars{t_i} \quad \text{for functions bounded by $\fix{f_i}{t_i}{i=1\ldots h}{f_j}$}
\]
\[
  \genbodyat{K}{t} =
  \begin{cases}
    \genbodyat{K}{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyat{K}{t_i}} & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
    \quad \text{for}~i=j, 1,\dotsc, (j-1), (j+1),\dotsc, h \\
    \A{K}{t}{}                            & \text{otherwise}
  \end{cases}
\]
\[
  \genbodyan{t} =
  \begin{cases}
    \genbodyan{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyan{t_i}} & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
    \quad \text{for}~i=1,\dotsc, h \\
    \B{K}{t}{}                            & \begin{aligned}[t]
                                            & \text{otherwise} \\
                                            & \text{where} \\
                                            & \quad t:T \\
                                            & \quad K(e) = \dq{\texttt{*($T$*)ret = $e$; \kwCreturn;}}
                                            \end{aligned}
  \end{cases}
\]
\[
  \genbodyb{K}{t} =
  \begin{cases}
    \genbodyb{K}{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyb{K}{t_i}} & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
    \quad \text{for}~i=j, 1,\dotsc, (j-1), (j+1),\dotsc, h \\
    \B{K}{t}{}                            & \text{otherwise}
  \end{cases}
\]
{\small Note:
\begin{itemize}
  \item $\fvarsop$ and $\fvarsop'$ returns a list of variables: $x_1;\ldots;x_n;$.  For simplicity, we omit ``$;$'' if not ambiguous.
  \item $\dq{g(i)}~\text{for}~i=j_1,\dotsc,j_n$ means $\dq{g(j_1)\:\ldots\:g(j_n)}$.
\end{itemize}}


\subsection{Translation for a Top-Level Function which is Translated to Multiple C Functions}\label{sec:genfunm}
$\genfunm{c}$ translates the function (constant) $c$ with one or more auxiliary functions.
We assume $c$ is defined as \kwDefinition~$c := t.$
The auxiliary functions $f_1 \ldots f_n$ are fixpoint bounded functions in $t$ which are invoked as functions.
We assume the types of them:
\begin{align*}
  c &: T_{01} \rightarrow \dotsb \rightarrow T_{0m_0} \rightarrow T_{00} \\
  f_i &: T_{i1} \rightarrow \dotsb \rightarrow T_{im_i} \rightarrow T_{i0} && i = 1\ldots n
\end{align*}
\[ \text{where} \quad \text{$T_{i0}$ are inductive types ($i=0\ldots n$)} \]
The formal arguments of $c$ are $x_{01}\ldots x_{0m_0} = \fvars{t}$ and
the formal arguments of $f_i$ are $x_{i1}\ldots x_{im_i} = \fvarsd{f_i}$.

$f_i$ invocation in C needs extra arguments, $y_{i1}\mathord{:}U_{i1} \ldots y_{io_i}\mathord{:}U_{io_i}$, addition to the actual arguments in \gallina{} application because the free variables of the fixpoint should also be passed.
If the free variables contain a function bounded by an outer fixpoint, the function itself is not passed but the free variables of the outer fixpoint are also passed.
We iterate it until no fixpoint functions.

\begin{alignat*}{2}
  \genfunm{c} &= \ldq && \enumentries{c}~\argstructdefs{c}~\forwarddecl{c}~\entryfunctions{c}~\bodyfunction{c} \rdq
\end{alignat*}
\[ \enumentries{c} = \dq{\kwenum\:\mathtt{enum\_func\_}c\:\ttbrace{ \mathtt{func\_}c\ttcomma \mathtt{func\_}f_1\ttcomma \dotsc\ttcomma \mathtt{func\_}f_n }\ttsemi} \]
\[ \argstructdefs{c} = \dq{\mainstructdef{c}\:\auxstructdef{c}{1} \ldots \auxstructdef{c}{n}} \]
\[ \mainstructdef{c} = \dq{\kwstruct\:\mathtt{arg\_}c\:\ttbrace{\:T_{01}\:\mathtt{arg}1\ttsemi \ldots\ttsemi\: T_{0m_0}\:\mathtt{arg}m_0\ttsemi\:}\ttsemi} \]
\[ \auxstructdef{c}{i} = \dq{\kwstruct\:\mathtt{arg\_}f_i\:\ttbrace{\:U_{i1}\:\mathtt{outer}1\ttsemi \ldots\ttsemi\: U_{io_i}\:\mathtt{outer}o_i\ttsemi\:T_{i1}\:\mathtt{arg}1\ttsemi \ldots\ttsemi\: T_{im_i}\:\mathtt{arg}m_i\ttsemi\:}\ttsemi} \]
\[ \forwarddecl{c} = \dq{\kwstatic\:\kwvoid\:\mathtt{body\_function\_}c\ttparen{\kwenum\:\mathtt{enum\_func\_}c\:\mathtt{g}\ttcomma \kwvoid\:\mathtt{\ttstar arg}\ttcomma \kwvoid\:\mathtt{\ttstar ret}}\ttsemi} \]
\[ \entryfunctions{c} = \dq{\mainfunction{c}\:\auxfunction{c}{1} \ldots \auxfunction{c}{n}} \]
\begin{alignat*}{2}
  \mainfunction{c} &= \ldq && \kwstatic\:T_{00}\:c\ttparen{T_{01}\:x_{01}\ttcomma\dotsc\ttcomma\, T_{0m_0}\:x_{0m_0}}\:\ttlbrace \\
  & && \quad \kwstruct\:\mathtt{arg\_}c\:\mathtt{arg}\:\tteq\:\ttbrace{ x_{01}\ttcomma\dotsc\ttcomma\, x_{0m_0} }\ttsemi\:T_{00}\:\mathtt{ret}\ttsemi \\
  & && \quad \mathtt{body\_function\_}c\ttparen{\mathtt{func\_}c\ttcomma \ttamp\mathtt{arg}\ttcomma \ttamp\mathtt{ret}}\ttsemi \kwCreturn\:\mathtt{ret}\ttsemi \\
  & && \ttrbrace \rdq
\end{alignat*}
\begin{alignat*}{2}
  \auxfunction{c}{i} &= \ldq && \kwstatic\:T_{i0}\:f_i\ttparen{U_{i1}\:y_{i1}\ttcomma\dotsc\ttcomma U_{io_i}\:y_{io_i}\ttcomma T_{i1}\:x_{i1}\ttcomma\dotsc\ttcomma T_{im_i}\:x_{im_i}}\:\ttlbrace \\
  & && \quad \kwstruct\:\mathtt{arg\_}f_i\:\mathtt{arg}\:\tteq\:\ttbrace{ y_{i1}\ttcomma\dotsc\ttcomma y_{io_i}\ttcomma x_{i1}\ttcomma\dotsc\ttcomma x_{im_i} }\ttsemi\:T_{i0}\:\mathtt{ret}\ttsemi\\
  & && \quad \mathtt{body\_function\_}c\ttparen{\mathtt{func\_}f_i\ttcomma \ttamp\mathtt{arg}\ttcomma \ttamp\mathtt{ret}}\ttsemi\:\kwCreturn\:\mathtt{ret}\ttsemi \\
  & && \ttrbrace \rdq
\end{alignat*}
\begin{alignat*}{2}
  \bodyfunction{c} &= \ldq
    && \kwstatic\:\kwvoid\:\mathtt{body\_function\_}c\ttparen{\kwenum\:\mathtt{enum\_func\_}c\:\mathtt{g}\ttcomma \kwvoid\:\ttstar\mathtt{arg}\ttcomma \kwvoid\:\ttstar\mathtt{ret}}\:\ttlbrace \\
  & && \quad \mathit{decls} \\
  & && \quad \kwswitch\:\ttparen{\mathtt{g}}\:\ttbrace{\:\auxcase{c}{1} \ldots \auxcase{c}{n}\:\maincase{c}\:} \\
  & && \quad {\genbodyb{K}{t}} \\
  & && \ttrbrace \rdq
\end{alignat*}
\begin{align*}
  \auxcase{c}{i} = \ldq & \kwcase\:\mathtt{func\_}f_i\ttcolon \\
  & y_{i1}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{outer}1\ttsemi \ldots\ttsemi\:y_{io_i}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{outer}o_i\ttsemi \\
  & x_{i1}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}1\ttsemi \ldots\ttsemi\:x_{im_i}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}m_i\ttsemi \\
  & \kwgoto\:\mathtt{entry\_}f_i\ttsemi \rdq
\end{align*}
\begin{align*}
  \maincase{c} = \ldq & \kwdefault\ttcolon\ttsemi \\
  & x_{01}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}c\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}1\ttsemi \ldots\ttsemi\:x_{0m_0}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}c\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}m_0\ttsemi \rdq
\end{align*}
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$\mathit{decls}$ is local variable declarations for variables used in $\genbodyb{K}{t}$.} \\
    & K(e) = \dq{\ttstar\ttparen{T_{00}\ttstar}\texttt{ret}\:\tteq\:e\ttsemi \kwCreturn\ttsemi}
  \end{aligned}
\]

\subsection{Translation for a Top-Level Function which is Translated to a Single C Function}\label{sec:genfuns}
$\genfuns{c}$ translates the function (constant) $c$ to a single C function.
\[
  \genfuns{c} = \dq{\kwstatic\:T_0\:c\ttparen{\fargsd{t}}\:\ttbrace{\:\mathit{decls}\:\genbodyb{K}{t}\:}}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$c$ is defined as \kwDefinition~$c : T_1 \rightarrow \dotsb \rightarrow T_n \rightarrow T_0 := t.$} \\
    & \text{$T_0$ is an inductive type} \\
    & \text{$\mathit{decls}$ is local variable declarations for variables used in $\genbodyb{K}{t}$ excluding $\fargs{t}$.} \\
    & K(e) = \dq{\kwCreturn\:e\ttsemi} \\
    & \fargs{t} =
      \begin{cases}
        \dq{T\:x\ttcomma\:\fargs{u}}      & t = \lamT{x}{T}{u} \\
        \fargs{t_j}       & t = \fix{f_i}{t_i}{i=1\ldots h}{f_j} \\
        \dq{}    & \text{otherwise}
      \end{cases} \\
    & \fargsd{t} = \fargs{t}~\text{without the trailing comma}
  \end{aligned}
\]

\subsection{Translation for Top-Level Function}\label{sec:genfun}
\[
  \genfun{c} =
  \begin{cases}
    \genfunm{c} & \text{$t$ needs multiple functions} \\
    \genfuns{c} & \text{otherwise}
  \end{cases}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$c$ is defined as \kwDefinition~$c := t.$}
  \end{aligned}
\]

\bibliographystyle{plain}
\bibliography{base}

\end{document}
\endinput
