\documentclass[a4paper,fleqn]{article}

\usepackage{fullpage}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd} % llbracket, rrbracket
%\usepackage{mathtools} % dcases
\usepackage{color}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{microtype}
\usepackage{balance}
\usepackage{mathtools}

\definecolor{myviolet}{rgb}{0.6,0.0,0.65}
\definecolor{myblue}{rgb}{0.1,0.0,0.8}
\definecolor{mygreen}{rgb}{0.1,0.5,0.0}
\definecolor{myred}{rgb}{0.8,0.0,0.0}

\lstdefinelanguage{coq}{
  keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,From,Require,Variable,Variables,Hypothesis,Let,Eval},
  keywordstyle=\color{myviolet}\ttfamily,
  morekeywords=[2]{match,with,end,Set,Prop,Type,fun,of,let,in,struct,if,is,then,else,as,return,fix,for,leta,letr,letn,letd,letp,nmatch,dmatch,app,rapp},
  keywordstyle=[2]\color{mygreen}\ttfamily,
  morekeywords=[3]{reflexivity},
  keywordstyle=[3]\color{myred}\ttfamily,
  morekeywords=[4]{CodeGen,GlobalInline,LocalInline,StaticArgs,Gen},
  keywordstyle=[4]\color{myblue}\ttfamily,
}

% The color of "in" is myviolet for
% Definition c := Eval ... in ...
\lstdefinelanguage{vernacular}{
  keywords=[1]{Check,Section,Definition,Defined,CoInductive,Coercion,Inductive,Extraction,Fixpoint,Parameter,Module,Import,Record,Structure,Axiom,Lemma,Theorem,Notation,Reserved,End,Proof,Goal,Qed,From,Require,Variable,Variables,Hypothesis,Let,Eval,in},
  keywordstyle=\color{myviolet}\ttfamily,
  morekeywords=[2]{match,with,end,Set,Prop,Type,fun,of,let,struct,if,is,then,else,as,return,fix,for,leta,letr,letn,letd,letp,nmatch,dmatch,app,rapp},
  keywordstyle=[2]\color{mygreen}\ttfamily,
  morekeywords=[3]{reflexivity},
  keywordstyle=[3]\color{myred}\ttfamily,
  morekeywords=[4]{CodeGen,GlobalInline,LocalInline,StaticArgs,Gen},
  keywordstyle=[4]\color{myblue}\ttfamily,
}

\lstdefinestyle{Cstyle} {language=C,basicstyle=\small\ttfamily}
\lstdefinestyle{OCamlstyle} {language=Caml,basicstyle=\small\ttfamily}
\lstdefinestyle{Vernacularstyle} {language=vernacular,basicstyle=\small\ttfamily}

\def\pipe{\char`\|}
\def\tilde{\char`\~}
\def\tiret{\char`\-}
\def\plus{\char`\+}
\def\myhat{\char`\^}
\def\mystar{\char`\*}
\def\mybs{\char`\\}
\def\placeholder{\char`\_}

\lstset{
  language=coq,
  columns=fullflexible,
  basicstyle=\small\ttfamily,
  identifierstyle=\color{black}\ttfamily,
  commentstyle=\color{myred}\ttfamily,
  morecomment=[n]{(*}{*)},
  morestring=[b][\ttfamily]",
  showstringspaces=false,
  keepspaces,
  literate=
  {->}{$\to$}1
  {forall}{$\forall$}1
  {\\}{\texttt{\mybs}}1
  {>>=}{{$\gg =$}}3
  {=>}{$\Rightarrow$}3
}

\def\coq{\textrm{Coq}}
\def\gallina{\textrm{Gallina}}
\def\ocaml{\textrm{OCaml}}
\def\haskell{\textrm{Haskell}}
\def\scheme{\textrm{Scheme}}
\def\ssreflect{\textrm{SSReflect}}
\def\oeuf{\textrm{\OE uf}}
\def\certicoq{\textrm{CertiCoq}}
\def\codegen{\textrm{Codegen}}

\newlength{\bnforlen}
\settowidth{\bnforlen}{$=$}
\newcommand{\bnfor}{\mathrel{\makebox[\bnforlen]{$|$}}}

\newcommand\eqconv{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily conv}}}{=}}}

\newcommand{\kwDefinition}{\mbox{\color{myviolet}\ttfamily Definition}}
\newcommand{\kwSection}{\mbox{\color{myviolet}\ttfamily Section}}

\newcommand{\kwlet}{\mbox{\color{mygreen}\ttfamily let}}
\newcommand{\kwin}{\mbox{\color{mygreen}\ttfamily in}}
\newcommand{\kwmatch}{\mbox{\color{mygreen}\ttfamily match}}
\newcommand{\kwas}{\mbox{\color{mygreen}\ttfamily as}}
\newcommand{\kwreturn}{\mbox{\color{mygreen}\ttfamily return}}
\newcommand{\kwwith}{\mbox{\color{mygreen}\ttfamily with}}
\newcommand{\kwend}{\mbox{\color{mygreen}\ttfamily end}}
\newcommand{\kwfix}{\mbox{\color{mygreen}\ttfamily fix}}
\newcommand{\kwfor}{\mbox{\color{mygreen}\ttfamily for}}
\newcommand{\kwrew}{\mbox{\color{mygreen}\ttfamily rew}}

\renewcommand{\_}{\underline{\phantom{x}}}

\newcommand{\lam}[2]{\lambda #1.\:#2}
\newcommand{\lamT}[3]{\lambda #1\mathord{:}#2.\:#3}
\newcommand{\lamB}[1]{\lambda #1.\:}
\newcommand{\lamTB}[2]{\lambda #1\mathord{:}#2.\:}
\newcommand{\lamM}[3]{\lambda \rep{#1}.\:#3}
\newcommand{\lamTM}[3]{\lambda \rep{#1\mathord{:}#2}.\:#3}

\newcommand{\gassum}[2]{(#1\mathord{:}#2)}
\newcommand{\glodef}[3]{(#1:=#2\mathord{:}#3)}
\newcommand{\glodefB}[2]{(#1:=#2)}
\newcommand{\lassum}[2]{(#1\mathord{:}#2)}
\newcommand{\ldef}[3]{(#1:=#2\mathord{:}#3)}
\newcommand{\ldefB}[2]{(#1:=#2)}

\newcommand{\prodT}[3]{\forall #1\mathord{:}#2.\:#3}

\newcommand{\letin}[3]{\kwlet\:#1:=#2\:\kwin\:#3}
\newcommand{\letinB}[2]{\kwlet\:#1:=#2\:\kwin}
\newcommand{\letinM}[3]{\kwlet\:\rep{#1:=#2}\:\kwin\:#3}

\newcommand{\omatch}[2]{\kwmatch\:#1\:\kwwith\:{#2}\:\kwend}
\newcommand{\match}[4]{\kwmatch\:#1\:\kwwith\:(#2 \Rightarrow #3)_{#4}\:\kwend}
\newcommand{\matchasinret}[7]{\kwmatch\:#1\:\kwas\:#2\:\kwin\:#3\:\kwreturn\:#4\:\kwwith\:(#5 \Rightarrow #6)_{#7}\:\kwend}

\newcommand{\ofix}[2]{\kwfix\:{#1}\:\kwfor\:{#2}}
\newcommand{\fix}[4]{\kwfix\:(#1 := #2)_{#3}\:\kwfor\:#4}
\newcommand{\fixT}[5]{\kwfix\:(#1:\!#2 := #3)_{#4}\:\kwfor\:#5}

\DeclareMathOperator{\NA}{NA} % number of arguments
\DeclareMathOperator{\NP}{NP} % number of parameters for the inductive type
\DeclareMathOperator{\NI}{NI} % number of indexes for the inductive type
\DeclareMathOperator{\NM}{NM} % number of members for the constructor

\DeclareMathOperator{\Arr}{Arr} % Arr(t) is arity of the inductive type t.
\newcommand{\arr}[1]{\Gamma_{\Arr(#1)}}

\DeclareMathOperator{\FV}{FV}
\DeclareMathOperator{\LC}{LC}
\DeclareMathOperator{\KV}{KV}
\DeclareMathOperator{\FIXFUNCS}{FIXFUNCS}
\DeclareMathOperator{\FIXK}{FIXK}
\DeclareMathOperator{\FIXFV}{FIXFV}
\DeclareMathOperator{\EXARGS}{EXARGS}

\newcommand{\tDL}{t^\mathrm{DL}}
\newcommand{\tD}{t^\mathrm{D}}
\newcommand{\tE}{t^\mathrm{E}}
\newcommand{\tL}{t^\mathrm{L}}
\newcommand{\tM}{t^\mathrm{M}}
\newcommand{\tF}{t^\mathrm{F}}
\newcommand{\tC}{t^\mathrm{C}}
\newcommand{\tA}{t^\mathrm{A}}

\newcommand{\HDL}{\mathrm{HEAD}^\mathrm{DL}}
\newcommand{\HD}{\mathrm{HEAD}^\mathrm{D}}
\newcommand{\HE}{\mathrm{HEAD}^\mathrm{E}}
\newcommand{\HL}{\mathrm{HEAD}^\mathrm{L}}
\newcommand{\HM}{\mathrm{HEAD}^\mathrm{M}}
\newcommand{\HF}{\mathrm{HEAD}^\mathrm{F}}
\newcommand{\HC}{\mathrm{HEAD}^\mathrm{C}}
\newcommand{\HA}{\mathrm{HEAD}^\mathrm{A}}

\newcommand{\TDL}{\mathrm{TAIL}^\mathrm{DL}}
\newcommand{\TD}{\mathrm{TAIL}^\mathrm{D}}
\newcommand{\TE}{\mathrm{TAIL}^\mathrm{E}}
\newcommand{\TL}{\mathrm{TAIL}^\mathrm{L}}
\newcommand{\TM}{\mathrm{TAIL}^\mathrm{M}}
\newcommand{\TF}{\mathrm{TAIL}^\mathrm{F}}
\newcommand{\TC}{\mathrm{TAIL}^\mathrm{C}}
\newcommand{\TA}{\mathrm{TAIL}^\mathrm{A}}

\newcommand{\HOLEH}{\square_\mathrm{H}}
\newcommand{\HOLET}{\square_\mathrm{T}}

\newcommand{\HEAD}{\mathrm{HEAD}}
\newcommand{\TAIL}{\mathrm{TAIL}}

\DeclareMathOperator{\merg}{merge}

\newcommand{\tbigcap}{{\textstyle\bigcap}}
\newcommand{\tbigcup}{{\textstyle\bigcup}}
\newcommand{\tbigvee}{{\textstyle\bigvee}}
\newcommand{\tbigwedge}{{\textstyle\bigwedge}}
\newcommand{\breakrule}{\\[0.5em]}

\newcommand{\BRA}[1]{\llbracket #1 \rrbracket}

\DeclareMathOperator{\genbody}{GENBODY}
\newcommand{\genbodyat}[2]{\genbody^\mathrm{AT}_{#1}\BRA{#2}}
\newcommand{\genbodyan}[1]{\genbody^\mathrm{AN}\BRA{#1}}
\newcommand{\genbodyb}[2]{\genbody^\mathrm{B}_{#1}\BRA{#2}}

\DeclareMathOperator{\genfunop}{GENFUN}
\newcommand{\genfun}[1]{\genfunop\BRA{#1}}
\newcommand{\genfuns}[1]{\genfunop^\mathrm{S}\BRA{#1}}
\newcommand{\genfunm}[1]{\genfunop^\mathrm{M}\BRA{#1}}

\newcommand{\enumentries}[1]{\mathrm{enum\_entries}\BRA{#1}}
\newcommand{\argstructdefs}[1]{\mathrm{arg\_structdefs}\BRA{#1}}
\newcommand{\mainstructdef}[1]{\mathrm{main\_structdef}\BRA{#1}}
\newcommand{\auxstructdef}[2]{\mathrm{aux\_structdef}\BRA{#1}_{#2}}
\newcommand{\forwarddecl}[1]{\mathrm{forward\_decl}\BRA{#1}}
\newcommand{\entryfunctions}[1]{\mathrm{entry\_functions}\BRA{#1}}
\newcommand{\mainfunction}[1]{\mathrm{main\_function}\BRA{#1}}
\newcommand{\auxfunction}[2]{\mathrm{aux\_function}\BRA{#1}_{#2}}
\newcommand{\bodyfunction}[1]{\mathrm{body\_function}\BRA{#1}}
\newcommand{\auxcase}[2]{\mathrm{aux\_case}\BRA{#1}_{#2}}
\newcommand{\maincase}[1]{\mathrm{main\_case}\BRA{#1}}

\DeclareMathOperator{\cvop}{CV}
\newcommand{\cv}[3]{\cvop\BRA{#1\,/\,#2}_{#3}}

\DeclareMathOperator{\TRop}{TR}
\newcommand{\TRFUN}[1]{\TRop_\text{FUN}\BRA{#1}}
\newcommand{\TREXP}[1]{\TRop_\text{EXP}\BRA{#1}}
\newcommand{\tr}{\mathit{TR}}

\DeclareMathOperator{\INLop}{INL}
\newcommand{\INL}[1]{\INLop\BRA{#1}}

\DeclareMathOperator{\RNTop}{IFIX}
\newcommand{\RNTFUN}[1]{\RNTop_\text{FUN}\BRA{#1}}
\newcommand{\RNTEXP}[1]{\RNTop_\text{EXP}\BRA{#1}}

\DeclareMathOperator{\MyH}{HEAD}
\DeclareMathOperator{\MyT}{TAIL}

\newcommand{\HFUN}[1]{\MyH_\text{FUN}\BRA{#1}}
\newcommand{\HEXP}[1]{\MyH_\text{EXP}\BRA{#1}}
\newcommand{\TFUN}[1]{\MyT_\text{FUN}\BRA{#1}}
\newcommand{\TEXP}[1]{\MyT_\text{EXP}\BRA{#1}}

\newcommand{\true}{\mathrm{T}}
\newcommand{\false}{\mathrm{F}}

\newcommand{\HigherOrderFixfunc}{\mathrm{HigherOrderFixfunc}}

\DeclareMathOperator{\APP}{APP}
\DeclareMathOperator{\components}{components}

\newcommand{\ldq}{\text{``}}
\newcommand{\rdq}{\text{''}}
\newcommand{\dq}[1]{\text{``}#1\text{''}}
\newcommand{\ttlparen}{\texttt{(}}
\newcommand{\ttrparen}{\texttt{)}}
\newcommand{\ttparen}[1]{\texttt{(}#1\texttt{)}}
\newcommand{\ttlbrace}{\texttt{\char '173}}
\newcommand{\ttrbrace}{\texttt{\char '175}}
\newcommand{\ttbrace}[1]{\ttlbrace#1\ttrbrace}
\newcommand{\tteq}{\texttt{=}}
\newcommand{\ttsemi}{\texttt{;}}
\newcommand{\ttcomma}{\texttt{,}}
\newcommand{\ttcolon}{\texttt{:}}
\newcommand{\ttstar}{\texttt{*}}
\newcommand{\ttamp}{\texttt{\&}}

\newcommand{\kwswitch}{\mbox{\color{myviolet}\ttfamily switch}}
\newcommand{\kwbreak}{\mbox{\color{myviolet}\ttfamily break}}
\newcommand{\kwgoto}{\mbox{\color{myviolet}\ttfamily goto}}
\newcommand{\kwstruct}{\mbox{\color{myviolet}\ttfamily struct}}
\newcommand{\kwvoid}{\mbox{\color{myviolet}\ttfamily void}}
\newcommand{\kwint}{\mbox{\color{myviolet}\ttfamily int}}
\newcommand{\kwCreturn}{\mbox{\color{myviolet}\ttfamily return}}
\newcommand{\kwcase}{\mbox{\color{myviolet}\ttfamily case}}
\newcommand{\kwdefault}{\mbox{\color{myviolet}\ttfamily default}}
\newcommand{\kwenum}{\mbox{\color{myviolet}\ttfamily enum}}
\newcommand{\kwstatic}{\mbox{\color{myviolet}\ttfamily static}}

\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\appref}[1]{Appendix~\ref{#1}}

\DeclareMathOperator{\passign}{passign}

\DeclareMathOperator{\fvarsop}{fvars}
\newcommand{\fvars}[1]{\fvarsop\BRA{#1}}
\newcommand{\fvarsd}[1]{\fvarsop'\BRA{#1}}

\DeclareMathOperator{\fargsop}{fargs}
\newcommand{\fargs}[1]{\fargsop\BRA{#1}}
\newcommand{\fargsd}[1]{\fargsop'\BRA{#1}}

\DeclareMathOperator{\Aop}{A}
\DeclareMathOperator{\Bop}{B}
\newcommand{\A}[2]{\Aop_{#1}\BRA{#2}}
\newcommand{\B}[2]{\Bop_{#1}\BRA{#2}}

\newcommand{\AbreakEq}[3]{\Aop_{#1}\llbracket \begin{aligned}[t] & #2 \\ & /\, #3 \rrbracket = \end{aligned}}
\newcommand{\BbreakEq}[3]{\Bop_{#1}\llbracket \begin{aligned}[t] & #2 \\ & /\, #3 \rrbracket = \end{aligned}}

\newcommand{\AbreakEqn}[2]{\Aop_{#1}\llbracket \begin{aligned}[t] & #2 \\ & \rrbracket = \end{aligned}}
\newcommand{\BbreakEqn}[2]{\Bop_{#1}\llbracket \begin{aligned}[t] & #2 \\ & \rrbracket = \end{aligned}}

\DeclareMathOperator{\Fop}{F}
\newcommand{\F}[1]{\Fop\BRA{#1}}
\DeclareMathOperator{\BRop}{BR}
\newcommand{\BR}[3]{\BRop\BRA{#1}_{#2,#3}}
\DeclareMathOperator{\Eop}{E}
\newcommand{\E}[3]{\Eop\BRA{#1\,/\,#2}_{#3}}

% based on the Coq reference manual, doc/common/macros.tex
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\WF}[2]{\ensuremath{{\mathcal{W\!F}}(#1)[#2]}}
\newcommand{\WFTWOLINES}[2]{\ensuremath{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WT}[4]{\ensuremath{#1[#2] \vdash #3 : #4}}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\substm}[3]{#1\{\overline{#2/#3}\}}
\newcommand{\substmu}[3]{#1\underline{\{\overline{#2/#3}\}}}
\newcommand{\substmi}[4]{#1\{\overline{#2/#3}^{#4}\}}

% taken from the Coq reference manual, doc/sphinx/refman-preamble.sty
\newcommand{\case}{\kw{case}}
\newcommand{\Fix}{\kw{Fix}}

\newcommand{\vdashb}{\vdash_{\textrm{b}}}
\newcommand{\vdashf}{\vdash_{\textrm{f}}}

\newcommand{\reltri}{\mathrel{\triangleright}}

\newcommand{\rep}[1]{\overline{#1}}
\newcommand{\repop}[2]{\overline{#1\underbracket[0.4pt][1pt]{#2}}}
\newcommand{\repopi}[3]{\overline{#1\underbracket[0.4pt][1pt]{#2}}^{#3}}
\newcommand{\repi}[2]{\overline{#1}^{#2}}

\title{codegen development note}

\begin{document}

\maketitle

\section{Notations}\label{sec:notations}

\subsection{Parenthesis}

We use parenthesis to represent grouping of syntax trees.
This is not restricted for expressions but for any syntax trees.
For example, we may use parenthesis as $\lam{(x{:}T)}{t}$ for $\lam{x{:}T}{t}$.
($x{:}T$ is not an expression.)

We don't include parenthesis in syntax definition in BNF.

\subsection{Repetition}

\begin{itemize}
  \item We use overline to represent repetition:
    $\repopi{x_i+y_i}{<}{i=a_1, \ldots, a_n}$ means $x_{a_1}+y_{a_1} < \ldots < x_{a_n}+y_{a_n}$.
  \item It consists body part ($x_i+y_i$), range part ($i=a_1, \ldots, a_n$), and operator part ($\underbracket[0.4pt][1pt]{<}$).
  %\item In many cases, we use integers as indices, but sometimes we use others, such as variable names.
  \item We may write the range part, $i=1\ldots n$, as $1\leq i \leq n$:
    $\repopi{x_i+y_i}{<}{1\leq i \leq n}$ means $x_1+y_1 < \ldots < x_n+y_n$.
  \item If the operator part ($\underbracket[0.4pt][1pt]{<}$) is just a punctuation to separate each term,
    we consider the punctuation can be added at first and/or last if appropriate for the context.
    $\repopi{x_i}{,}{i=1\ldots n}$ represents
    ``$x_1,\ldots ,x_n$'',
    ``$x_1,\ldots ,x_n,$'',
    ``$,x_1,\ldots ,x_n$'', or
    ``$,x_1,\ldots ,x_n,$''. \\
    Thus, $(\repopi{x_i}{,}{i=1\ldots m}\;\repopi{y_i}{,}{i=1\ldots n})$ can represent \\
    $(x_1,\ldots, x_m, y_1,\ldots, y_n)$ when $(0<m) \wedge (0<n)$, \\
    $(x_1,\ldots, x_m)$ when $(0<m)\wedge(n=0)$, \\
    $(y_1,\ldots, y_n)$ when $(m=0)\wedge(0<n)$, and \\
    $()$ when $m=n=0$.
  \item We may omit the operator part when the operator is just a punctuation to separate each term.
    We write $\repi{x_i+y_i}{i=1\ldots n}$ for $x_1+y_1, \ldots, x_n+y_n$ if comma is appropriate separator for the context.
    (Also, comma can be added at first and/or end as described above.)
  \item We may write the range part as only an index metavariable if the range is clear from the context: $\repi{x_i+y_i}{i}$.
  \item We may omit the index metavariable in the range part and the body part:
    $\repi{x+y}{1\ldots n}$ means $\repi{x_i+y_i}{i=1\ldots n}$.
  \item We may omit the range part ($i=1\ldots n$) and index of metavariables ($i$ of $x_i$ and $y_i$) when the metavariables are sequences of same length.
    We write $\repop{x+y}{<}$ for $x_1+y_1 < \ldots < x_n+y_n$ when $x$ and $y$ are $n$-element sequences.
  \item We omit both the operator and range part if appropriate.
    We write $\rep{x+y}$ for $x_1+y_1, \ldots, x_n+y_n$ if $x$ and $y$ are $n$-element sequences and comma is appropriate separator for the context.
    We use this form in most case.
  \item We use underline to distinguish metavariables which index is added by overline or not.
    We write $\rep{x+\underline{y}}$ for $x_1+y, \ldots, x_n+y$.
  \item We use nested overline to represent multi-dimensional indexes. \\
    $\omatch{t}{\rep{C\:\rep{x}\Rightarrow u}}$ means \\
    $\omatch{t}{C_1\:\rep{x_1}\Rightarrow u_1 \:|\: \ldots \:|\: C_n\:\rep{x_n}\Rightarrow u_n}$ and \\
    $\omatch{t}{C_1\: x_{11}\ldots x_{1m_1} \Rightarrow u_1
                \:|\: \ldots
                \:|\: C_n\: x_{n1}\ldots x_{nm_n} \Rightarrow u_n}$.
  \item Nested overline and underline can be combined. \\
    $\rep{\letinB{x}{\ofix{\underline{(\rep{f:=t})}}{f}}}$ means \\
    $\letinB{x_1}{\ofix{\rep{f:=t}}{f_1}} ~\ldots~
     \letinB{x_h}{\ofix{\rep{f:=t}}{f_h}}$ and \\
    $\letinB{x_1}{\ofix{(f_1:=t_1)\ldots(f_n:=t_n)}{f_1}} ~\ldots~
     \letinB{x_h}{\ofix{(f_1:=t_1)\ldots(f_n:=t_n)}{f_h}}$.

    Overlines and underlines must construct a nested structure.
    If an underline and an overline covers same range,
    we consider the underline covers the overline.
    For example,
    we consider $\rep{a \rep{\underline{b}} c}$ as
    $\rep{a \underline{(\rep{b})} c} = a_1 \rep{b} c_1 \ldots a_n \rep{b} c_n$.
    We don't consider it as
    $\rep{a \rep{(\underline{b})} c} = a_1 \rep{(\underline{b_1})} c_1 \ldots a_n \rep{(\underline{b_n})} c_n$.
    We cannot define how to repeat $\rep{(\underline{b})}$ because it has no variable without underline.

  \item This notation is based on \cite{steele2017s}.
\end{itemize}

\subsection{Number of Elements}

We use $|x|$ to represent the number of elements: $|x|=n$ if $x$ is an $n$-element sequence, $x_1, \ldots, x_n$.

\subsection{Number of Arguments}

\begin{itemize}
  \item $\NA_t$ is the number of arguments of $t$: \quad $\NA_t=m$ if $t : T_1 \rightarrow \dotsb \rightarrow T_m \rightarrow T_0$ and $T_0$ is not a function type.
  \item $\NP_I$ is the number of the parameters of the inductive type $I$: \\
    $\NP_I=p$ if $I$ is defined in an inductive definition $\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$.
  \item $\NI_I$ is the number of the indexes of the inductive type $I$ (the number of arguments without the parameters for the inductive type): \\
    $\NI_I=|\arr{I}|$ where
    $\arr{t}$ is the arity of the inductive type $t$.
    It means $(I : \forall (\Gamma_P; \arr{t}), S)$ is defined in $\Gamma_I$ of $\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$ in the global environment where
    $|\Gamma_P|$ = $p$ and $S$ is a sort.
  \item $\NM_C$ is the number of the members of the constructor $C$ (the number of arguments without the parameters for the inductive type): \\
    $\NM_C=|\Gamma|$ where
    $\Gamma$ is the non-parameter arguments of the constructor $C$.
    It means $(C : \forall (\Gamma_P; \Gamma), T)$ is defined in $\Gamma_C$ of $\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$ in the global environment where
    $|\Gamma_P|$ = $p$ and $T$ is an inductive type.
\end{itemize}

\subsection{Substitution}
$\subst{t}{x}{u}$ means a term in which variable $x$ in term $t$ is replaced by term $u$.
This notation is taken from the Coq reference manual~\cite{coqrefman8.12.0}.

We use $\substm{t}{x}{u}$ for parallel substituion.

\section{\gallina{}}\label{sec:gallina}
\subsection{\gallina{} Syntax}\label{sec:gallina-syntax}

\begin{align*}
  t &= x & \text{v-variable} \\
    &\bnfor f & \text{f-variable} \\
    &\bnfor c & \text{constant} \\
    &\bnfor C & \text{constructor} \\
    &\bnfor T & \text{type} \\
    &\bnfor \lamT{x}{T}{t}        & \text{abstraction} \\
    &\bnfor t\:u                  & \text{application} \\
    &\bnfor \letin{x}{t:T}{u}     & \text{let-in} \\
    &\bnfor \omatch{t}{\repop{C\:\rep{x{:}T}\Rightarrow u}{|}} & \text{conditional} \\
    &\bnfor \ofix{\repop{f/k{:}T:=t}{\kwwith}}{f_j} & \text{fixpoint}
\end{align*}
{\small Note:
\begin{itemize}
  \item $u, a, b$ represents a term as $t$. \\
    $v, w, y, z$ represent a v-variable as $x$. \\
    $g$ represent a f-variable as $f$. \\
    $U, V$ represents a type as $T$.
  \item We distinguish v-variables (such as $x$) and f-variables (such as $f$) in the syntax.
    V-variables are variables bounded by abstraction, let-in, and conditional.
    F-variables are variables bounded by fixpoint.
    They are treated differently in C code generation:
    V-variables has corresponding C variables but F-variables has no corresponding C variables.
  \item We write $(\cdots((t\:u_1)\:u_2)\cdots\:u_n)$ as $t\:u_1\ldots u_n$ or $t\:\rep{u}$.
  \item We write $\lamT{x_1}{T_1}{(\ldots (\lamT{x_n}{T_n}{u}) \ldots)}$ as $\lamTM{x}{T}{u}$.
  \item We write $\letin{x_1}{t_1{:}T_1}{(\ldots(\letin{x_n}{t_n{:}T_n}{u})\ldots)}$ as $\letinM{x}{t{:}T}{u}$.
  \item $k$ is an integer. \\ $k_i$ for fixpoint specify the decreasing argument for $f_i$.
  \item If it is unambiguous, we omit type annotations for the sake of simplicity.  We also omit $k_i$ in fixpoints if they are not used.
  \item We omitted the elimination predicate (\kwas-\kwin-\kwreturn{} clause of \kwmatch-expression) in the syntax.
  \item We omitted the dummy parameters (underscores between $C$ and $\rep{x{:}T}$) in conditionals.
  \item We consider inductive types and constructor types has no let-in in binders.
  \item We omitted the detail of the types.  Actual \gallina{} permits any \gallina{} term which evaluates to a type.
\end{itemize}}

% {\tiny
% We ignore Var, Meta, Evar because they are not used in complete program.
% Int and Float are considered as constants.
% Prod, Ind and Sort are considered as types.
% Cast is ignored because it can be eliminated immediately.
% CoFix is ignored because lazy-evaluation is not suitable to C.
% Proj is ignored because it is similar to \kwmatch.}

\subsection{Global Context and Local Context}

$E$ is a global environment which is a list of
global assumptions $\gassum{c}{T}$,
global definitions $\glodef{c}{t}{T}$, and
inductive definitions ($\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$).

$\Gamma$ is a local context which is a list of
local assumptions $\lassum{x}{T}$, $\lassum{f}{T}$ and
local definitions $\ldef{x}{t}{T}$.
The local assumptions $\lassum{x}{T}$ represent v-variables bounded by outer abstractions and conditionals.
The local assumptions $\lassum{f}{T}$ represent f-variables bounded by outer fixpoints.
The local definitions represent variables bounded by outer let-in.

\subsection{\gallina{} Conversion Rules}\label{sec:conversion-rules}

% based on sphinx/language/core/conversion.rst and doc/sphinx/language/core/inductive.rst
\begin{gather*}
  \text{beta:}~
    E[\Gamma] \vdash ((\lam{x}{t})\:u) \reltri \subst{t}{x}{u} \\
  \text{delta-local:}~
    \dfrac{(x:=t) \in \Gamma}{E[\Gamma] \vdash x \reltri t} \\
  \text{delta-global:}~
    \dfrac{(c:=t) \in E}{E[\Gamma] \vdash c \reltri t} \\
  \text{zeta:}~
    E[\Gamma] \vdash \letin{x}{t}{u} \reltri \subst{u}{x}{t} \\
  \text{iota-match:}~
    \dfrac
    {
      E[\Gamma] \vdash C_j\:\rep{a}\:\rep{b} : T \quad
      \text{$|a| = \NP_T$}
    }{
      E[\Gamma] \vdash
      \omatch{(C_j\:\rep{a}\:\rep{b})}{\rep{C\:\rep{x}\Rightarrow t}}
      \reltri
      (\lam{\rep{x_j}}{t_j})\:\rep{b}
    } \\
  \text{iota-fix:}~
    \dfrac{
      u_{k_j} = C\:\rep{a} \quad
      |u| = k_j
    }{
      E[\Gamma] \vdash\; (\ofix{\rep{f/k:=t}}{f_j})\:\rep{u} \reltri\; \substm{t_j}{f}{\ofix{\underline{(\rep{f/k:=t})}}{f}} \: \rep{u}
    } \\
  \text{eta expansion:}~
    \dfrac{\WTEG{t}{\prodT{x}{T}{U}}}{E[\Gamma] \vdash t \reltri \lamT{x}{T}{(t\:x)}}
\end{gather*}
{\small Note:
\begin{itemize}
  \item The rules shown here are reductions, except the eta expansion.
  \item Variables cannot conflict because \coq{} uses de Bruijn's indexes to represent variables.
  \item If it is unambiguous, we omit type annotations in these definitions for the sake of simplicity.
  \item Iota-match reduces $\kwmatch\:\mathtt{@cons\:nat\:1\:nil}\:\kwwith\:(\mathtt{nil} \Rightarrow t_1)\:|\:(\mathtt{cons}\:\mathtt{h}\:\mathtt{t} \Rightarrow t_2)\:\kwend$ to $(\lam{\mathtt{h}}{\lam{\mathtt{t}}{t_2}})\:\mathtt{1\:nil}$
    because \lstinline!list! has one parameter $(\NP_\mathtt{nat}=1)$ and \lstinline!cons! has two members $(\NM_\mathtt{cons}=2)$.
\end{itemize}}

\subsection{Equality of Terms}\label{sec:equality-of-terms}

\begin{itemize}
  \item $t \equiv u$ means that $t$ and $u$ are same term except names of bound variables
  \item $t \eqconv u$ means that $t$ and $u$ are convertible
  \item $t = u$ means that there is a proof term of $t = u$ (\lstinline!Coq.Init.Logic.eq!)
  \item $t \simeq u$ means extensional equality: $\forall \mathit{args}, t\ \mathit{args} = u\ \mathit{args}$ where $t\ \mathit{args}$ is not a function
\end{itemize}

\subsection{Free Variables}

$\FV(t)$ is the free variables of $t$.

\begin{align*}
  \FV(x) &= \{x\} \\
  \FV(f) &= \{f\} \\
  \FV(c) &= \varnothing \\
  \FV(C) &= \varnothing \\
  \FV(\lamT{x}{T}{t}) &= \FV(t) - \{x\} \\
  \FV(t\:u) &= \FV(t) \cup \FV(u) \\
  \FV(\letin{x}{t:T}{u}) &= \FV(t) \cup \FV(u) - \{x\} \\
  \FV(\omatch{t}{\rep{C\:\rep{x{:}T}\Rightarrow u}}) &= \FV(t) \cup \tbigcup_i (\FV(u_i) - \{\rep{x_i}\}) \\
  \FV(\ofix{\rep{f/k{:}T:=t}}{f_j}) &= \big(\tbigcup_i \FV(t_i)\big) - \{\rep{f}\}
\end{align*}
{\small Note:
\begin{itemize}
  \item We ommitted $\FV(T)$ here because it needs details of types.  It is defined as usual.
\end{itemize}}

\subsection{Syntactic Context}

We use syntactic context $K$.
$K$ is a single-hole context: a \gallina{} term with a subterm is sustituted with a hole, $[]$.
$K[u]$ is $K$ with the hole is substituted with $u$.

We call syntactic context just as context if it is not ambiguous.

\begin{align*}
  K &= [] \\
    &\bnfor \lamT{x}{T}{K} \\
    &\bnfor K\:t \\
    &\bnfor t\:K \\
    &\bnfor \letin{x}{K:T}{t} \\
    &\bnfor \letin{x}{t:T}{K} \\
    &\bnfor \omatch{K}{\rep{C\:\rep{x{:}T}\Rightarrow u}} \\
    &\bnfor \omatch{t}{\repi{(C_l\:\rep{x_l{:}T_l}\Rightarrow u_l)}{1\leq l < i} (C_i\:\rep{x_i{:}T_i}\Rightarrow K) \repi{(C_l\:\rep{x_l{:}T_l}\Rightarrow u_l)}{i < l \leq h}  } \\
    &\bnfor \ofix{\repi{(f_l/k_l{:}T_l:=t_l)}{1\leq l < i} (f_i/k_i{:}T_i:=K) \repi{(f_l/k_l{:}T_l:=t_l)}{i < l \leq h}}{f_j}
\end{align*}

\subsection{Local Context of Syntactic Context}

$\LC(K)$ is the local context of the hole of $K$.
\begin{align*}
  \LC([]) &= \text{empty} \\
  \LC(\lamT{x}{T}{K}) &= \lassum{x}{T};  \LC(K) \\
  \LC(K\:t) &= \LC(K) \\
  \LC(t\:K) &= \LC(K) \\
  \LC(\letin{x}{K:T}{t}) &= \LC(K) \\
  \LC(\letin{x}{t:T}{K}) &= \ldef{x}{t}{T}; \LC(K) \\
  \LC(\omatch{K}{\rep{C\:\rep{x{:}T}\Rightarrow u}}) &= \LC(K) \\
  \LC(\omatch{t}{\repi{(C_l\:\rep{x_l{:}T_l}\Rightarrow u_l)}{1\leq l < i} (C_i\:\rep{x_i{:}T_i}\Rightarrow K) \repi{(C_l\:\rep{x_l{:}T_l}\Rightarrow u_l)}{i < l \leq h}} &= \rep{\lassum{x_i}{T_i};} \LC(K) \\
  \LC(\ofix{\repi{(f_l/k_l{:}T_l:=t_l)}{1\leq l < i} (f_i/k_i{:}T_i:=K) \repi{(f_l/k_l{:}T_l:=t_l)}{i < l \leq h}}{f_j}) &= \rep{\lassum{f_i}{T_i};} \LC(K)
\end{align*}

$\KV(K)$ is the bound variables usable in the hole of the context $K$.
\[
  \KV(K) = \{\, x \;|\; (\exists T. \lassum{x}{T} \in \LC(K)) \} \cup
           \{\, f \;|\; (\exists T. \lassum{f}{T} \in \LC(K)) \} \cup
           \{\, x \;|\; (\exists t,T. \ldef{x}{t}{T} \in \LC(K)) \}
\]

\section{CodeGen}\label{sec:codegen}

\begin{itemize}
\item \gallina-to-\gallina{} Transformations
  \begin{itemize}
  \item Inlining
  \item Strip Cast
  \item Eta Expansion for Functions
  \item V-Normalization
  \item S-Normalization
  \item Type Normalization
  \item Static Argument Normalization
  \item Unused let-in Deletion
  \item Call Site Replacement
  \item Eta Reduction to Expose Fixpoint
  \item Argument Completion
  \item Unreachable Fixfunc Deletion
  \item Monomorphism Check
  \item Borrow Check
  \item C Variable Allocation
  \end{itemize}
\item C Code Generation
  \begin{itemize}
  \item C Code Generation
  \end{itemize}
\end{itemize}

\section{\gallina-to-\gallina{} Transformations}\label{sec:gallina-to-gallina-transformations}

We define transformations as a judgement $E[\Gamma] \vdash t \reltri u$.
This means a subterm $t$ is substituted to $u$ where
$E$ and $\Gamma$ are the global environment and the local context of them.

We also use $E[\Gamma] \vdash_K t \reltri u$ to represent transformations restricted with a syntactical context $K$.

$E[\Gamma] \vdash_K t \reltri u$ is similar to $E[\Gamma] \vdash K[t] \reltri K[u]$ but
$\Gamma$ is the local context of $t$ (not $K[t]$).

Also, we use $E[] \vdash_\$ t \reltri u$ which defines a tranformation of an entire term (not subterm).
(The local context is empty because an entire term has no local context.)

When we define a new constant in a transformation,
We use $E[\Gamma] \vdash t \reltri (E;\glodef{c}{a}{T})[\Gamma] \vdash u$.

\subsection{Inlining}\label{sec:inlining}

\codegen{} apply delta-global reductions to inline definitions.

Two command, \lstinline!CodeGen GlobalInline! and \lstinline!CodeGen LocalInline!, specifies
what definitions will be inlined.
\begin{lstlisting}
CodeGen GlobalInline QUALID...
CodeGen LocalInline QUALID : QUALID...
\end{lstlisting}

\lstinline[mathescape=true]!CodeGen GlobalInline $c_1\ldots c_n$! specifies
global constants $c_1\ldots c_n$ will be expanded.

\lstinline[mathescape=true]!CodeGen LocalInline $c_0$ : $c_1\ldots c_n$! specifies
global constants $c_1\ldots c_n$ will be expanded in $c_0$.

\subsection{Strip Cast}\label{sec:strip-cast}

\codegen{} removes cast expressions.
For example, \lstinline!(1 : nat) + 2! is transformed to \lstinline!1 + 2!.

Note that we ignore casts in this document except this section.
Even the \gallina{} syntax in \secref{sec:gallina-syntax} has no rule for casts.

\subsection{Eta Expansion for Functions}\label{sec:eta-expand-funcs}
We apply eta-expansion to functions of top-level functions, fix-bounded functions, and closure generating lambdas.
We consider explicit lambdas are closure generation.
This makes beta-var applicable for partial applications without worrying to expose computation.
(CIC~\cite{coqrefman8.12.0} uses lambdas for match-branches but our syntax uses no lambdas for them.
Thus match-branches doesn't trigger the eta expansion.)

\begin{gather*}
  \text{etaex-top:}~
    \dfrac{
      E[] \vdash t : \prodT{x}{T}{U} \quad
      \text{$t$ is neither an abstraction nor fixpoint} \quad
    }{
      E[] \vdash_\$ t \reltri \lamT{x}{T}{(t\:x)}
    } \breakrule
  \text{etaex-fix:}~
    \dfrac{
      \begin{aligned}
        & E[\Gamma] \vdash t_i : \prodT{x}{T}{U} \quad
          \text{$t_i$ is neither an abstraction nor fixpoint} \\
        & K = \ofix{\repi{(f_l:=t_l)}{1\leq l < i} (f_i:=[]) \repi{(f_l:=t_l)}{i < l \leq h}}{f_j}
      \end{aligned}
    }{
        E[\Gamma] \vdash_K t_i \reltri \lamT{x}{T}{(t_i\:x)}
    } \breakrule
  \text{etaex-abs:}~
    \dfrac{
      \begin{aligned}
        & E[\Gamma] \vdash t : \prodT{x}{T}{U} \quad
          \text{$t$ is neither an abstraction nor fixpoint} \\
        & K = \lam{y}{[]}
      \end{aligned}
    }{
      E[\Gamma] \vdash_K t \reltri \lamT{x}{T}{(t\:x)}
    }
\end{gather*}

This transformations makes a term in following syntax.
The entire term is represented as $\tDL$.
($\tD$ for functions and $\tE$ for non-function constants.)

\begin{align*}
  \tDL &= \tD \\
       &\bnfor \tE & \text{the type of $\tE$ is an inductive type} \\
  \tD &= \lamT{x}{T}{\tDL} \\
      &\bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j} \\
  \tE &= x \\
    &\bnfor f \\
    &\bnfor c \\
    &\bnfor C \\
    &\bnfor T \\
    &\bnfor \tE\:\tE \\
    &\bnfor \letin{x}{\tE:T}{\tE} \\
    &\bnfor \omatch{\tE}{\rep{C\:\rep{x}\Rightarrow \tE}} \\
    &\bnfor \tD \\
\end{align*}

The type of $\tE$ in $\tDL$ is an inductive type because
the eta expansions (etaex-fix and etaex-abs) transform the body of abstraction and fixpoint until its type is not function type.

\subsection{V-Normalization}\label{sec:v-normalization}
\subsubsection{V-Reductions}\label{sec:v-reductions}
\begin{gather*}
  \text{zeta-arg:}~
    \dfrac
    {
      E[\Gamma] \vdash u : U \quad
      \text{$t$ is not an application} \quad
      \text{$u$ is not a v-variable} \quad
      \text{$y$ is a fresh v-variable}
    }{
      E[\Gamma] \vdash
      t\:\rep{x}\:u\:\rep{a}
      \reltri
      \letin{y}{u:U}{t\:\rep{x}\:y\:\rep{a}}
    } \breakrule
  \text{zeta-item:}~
    \dfrac
    {
      E[\Gamma] \vdash u : U \quad
      \text{$u$ is not a v-variable} \quad
      \text{$y$ is a fresh v-variable}
    }{
      E[\Gamma] \vdash
        \omatch{u}{\rep{C\:\rep{x} \Rightarrow t}}
        \reltri
        \letin{y}{u:U}{\omatch{y}{\rep{C\:\rep{x} \Rightarrow t}}}
    }
\end{gather*}

\subsubsection{V-Normal Form}\label{sec:v-normal-form}
V-normal form restricts \gallina{} terms that (1) application arguments and (2) match items to variables.
\begin{align*}
  t &= x \bnfor f \bnfor c \bnfor C \bnfor T \bnfor \lamT{x}{T}{t} \bnfor \letin{x}{t:T}{u} \\
    &\bnfor \ofix{\rep{f/k{:}T:=t}}{f_j} \\
    &\bnfor t\:x                               & \leftarrow (1) \\
    &\bnfor \omatch{x}{\rep{C\:\rep{x} \Rightarrow t}} & \leftarrow (2)
\end{align*}

Since we apply V-reductions for a eta-expanded term,
the result term can be represented in following syntax.

\begin{align*}
  \tDL &= \tD \\
       &\bnfor \tE & \text{the type of $\tE$ is an inductive type} \\
  \tD &= \lamT{x}{T}{\tDL} \\
      &\bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j} \\
  \tE &= x \\
    &\bnfor f \\
    &\bnfor c \\
    &\bnfor C \\
    &\bnfor T \\
    &\bnfor \tE\:x & \leftarrow (1) \\
    &\bnfor \letin{x}{\tE:T}{\tE} \\
    &\bnfor \omatch{x}{\rep{C\:\rep{x}\Rightarrow \tE}} & \leftarrow (2) \\
    &\bnfor \tD \\
\end{align*}

\subsection{S-Normalization}\label{sec:s-normalization}

\subsubsection{S-Reductions}\label{sec:s-reductions}
\begin{gather*}
  \text{beta-var:}~
    E[\Gamma] \vdash (\lam{x}{t})\:y \reltri \subst{t}{x}{y} \breakrule
  \text{delta-vvar:}~
    \dfrac{(x:=y) \in \Gamma}{E[\Gamma] \vdash x \reltri y} \breakrule
  \text{delta-fvar:}~
    \dfrac{
      (x:=f) \in \Gamma \quad
      \text{$x$ occur at non-argument position}
    }{E[\Gamma] \vdash x \reltri f} \breakrule
  \text{delta-fun:}~
    \dfrac
    {
      \begin{gathered}
      0 \leq |x| \quad
      0 < |y| \quad
      (z := t\:\rep{x}) \in \Gamma \\
      \text{$t$ is one of v-variable, f-variable, constant, constructor, abstraction, or fixpoint}
      \end{gathered}
    }{
      E[\Gamma] \vdash z\:\rep{y}
                       \reltri
                       t\:\rep{x}\:\rep{y}
    } \breakrule
  \text{zeta-flat:}~
    E[\Gamma] \vdash \letin{y}{(\letin{x}{t_1}{t_2})}{t_0}
                       \reltri
                       \letin{x}{t_1}{(\letin{y}{t_2}{t_0})} \breakrule
  \text{zeta-app:}~
    E[\Gamma] \vdash
     (\letin{y}{t}{u})\:\rep{x}
     \reltri
     \letin{y}{t}{(u\:\rep{x})} \breakrule
  \text{iota-match-var:}~
    \dfrac
    {
      (v:=C_j\:\rep{y}\:\rep{z}:T) \in \Gamma \quad
      |y|=\NP_T
    }{
      E[\Gamma] \vdash
      \omatch{v}{\rep{C\:\rep{x}\Rightarrow t}}
      \reltri
      (\lam{\rep{x_j}}{t_j})\:\rep{z}
    } \breakrule
  \text{iota-fix-var:}~
    \dfrac
    {
      \begin{gathered}
        (x_{k_j} := C\:\rep{y}) \in \Gamma \quad
        \text{$\rep{z}$ are fresh v-variables} \\
        E[\Gamma] \vdash (\ofix{\rep{f/k:=t}}{f_j})\:\rep{x} : T \quad
        \text{$T$ is an inductive type}
      \end{gathered}
    }{
        E[\Gamma] \vdash\;
          (\ofix{\rep{f/k:=t}}{f_j})\:\rep{x}
          \reltri
          \letinM{z}{\ofix{\underline{(\rep{f/k:=t})}}{f}}{\substm{t_j}{f}{z}} \: \rep{x}
    } \breakrule
  \text{iota-fix-var':}~
    \dfrac
    {
      \begin{gathered}
        (x_{k_j} := C\:\rep{y}) \in \Gamma \quad
        \rep{(z := \ofix{\underline{(\rep{f/k:=t})}}{f}) \in \underline{\Gamma}} \\
        E[\Gamma] \vdash (\ofix{\rep{f/k:=t}}{f_j})\:\rep{x} : T \quad
        \text{$T$ is an inductive type}
      \end{gathered}
    }{
      E[\Gamma] \vdash
      (\ofix{\rep{f/k:=t}}{f_j})\:\rep{x}
      \reltri
      \substm{t_j}{f}{z} \:\rep{x}
    } \breakrule
  \text{match-app:}~
    \dfrac
    {
      E[\Gamma] \vdash z : T
    }{
      \begin{aligned}
        E[\Gamma] \vdash\; &
          \kwmatch\:x\:
          \kwas\:x'\:
          \kwin\:I\:\rep{y}\:
          \kwreturn\:{T \rightarrow P\:\rep{y}\:x'}
          \kwwith\:\rep{{C\: \rep{x}} \Rightarrow {t}}\:
          \kwend\:z \\
        \reltri\; &
          \kwmatch\:x\:
          \kwas\:x'\:
          \kwin\:I\:\rep{y}\:
          \kwreturn\:{P\:\rep{y}\:x'}
          \kwwith\:\rep{{C\: \rep{x}} \Rightarrow {t\:\underline{z}}}\:
          \kwend
      \end{aligned}
    }
\end{gather*}

{\small Note:
\begin{itemize}
  \item match-app is not convertible
  \item delta-fvar does not forbid at a match item position but it does not break V-normalization.
    It is because f-variable, which is always function type, cannot occur at match item, which must be inductive type.
\end{itemize}}

\subsubsection{S-Normal Form}\label{sec:s-normal-form}
S-reductions transform applications to restrict function positions.
\begin{itemize}
  \item beta-var removes an abstraction at the function position of an application.
  \item zeta-app removes a let-in at the function position of an application.
  \item match-app removes a conditional at the function position of an application.
\end{itemize}
Also, types cannot be a function.
We treat multi-arguments application as single application, application is not occur at a function position.
Thus, function position can be v-variable, f-variable, constant, construcor, or fixpoint in the S-normal form.

Also, zeta-flat removes a let-in at the binder term of a let-in.

\begin{align*}
  \tDL &= \tD \\
       &\bnfor \tL & \text{the type of $\tL$ is an inductive type} \\
  \tD &= \lamT{x}{T}{\tDL} \\
      &\bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j} \\
  \tL &= \letinM{x}{\tM:T}{\tM} \\
  \tM &= \omatch{x}{\rep{C\:\rep{x}\Rightarrow \tL}} \\
      &\bnfor \tE \\
  \tE &= x \bnfor f \bnfor c \bnfor C \bnfor T \\
    &\bnfor \tF\:\rep{x} & \text{$0 < |x|$} \\
    &\bnfor \tD \\
  \tF &= x \bnfor f \bnfor c \bnfor C \bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j}
\end{align*}

\subsection{Type Normalization}\label{sec:type-normalization}

We normalize type annotations in the term.

This transformation makes that types contain no variable bounded by let-ins
because such variables are redex of delta reduction.
Thus, this transformation makes Unused let-in Deletion (\secref{sec:let-in-deletion}) more effective.

\begin{align*}
  \tDL &= \tD \\
       &\bnfor \tL & \text{the type of $\tL$ is an inductive type} \\
  \tD &= \lamT{x}{\fbox{$T$}}{\tDL} & \leftarrow \\
      &\bnfor \ofix{\rep{f/k{:}\fbox{$T$}:=\tD}}{f_j} & \leftarrow \\
  \tL &= \letinM{x}{\tM:\fbox{$T$}}{\tM} & \leftarrow \\
  \tM &= \omatch{x}{\rep{C\:\rep{x}\Rightarrow \tL}} \\
      &\bnfor \tE \\
  \tE &= x \bnfor f \bnfor c \bnfor C \bnfor T \\
    &\bnfor \tF\:\rep{x} & \text{$0 < |x|$} \\
    &\bnfor \tD \\
  \tF &= x \bnfor f \bnfor c \bnfor C \bnfor \ofix{\rep{f/k{:}\fbox{$T$}:=\tD}}{f_j} & \leftarrow
\end{align*}

We also normalize types in \kwmatch-expressions to make less free variables.
\gallina{} internal representation of \kwmatch-expressions contains
parameters for the inductive type, return clause, and SProp inversion data.

\subsection{Static Argument Normalization}\label{sec:static-argument-normalization}

We normalize static arguments.
We assume the normalized static arguments have no free variables.

It makes the syntax as follows.

\begin{align*}
  \tDL &= \tD \\
       &\bnfor \tL & \text{the type of $\tL$ is an inductive type} \\
  \tD &= \lamT{x}{T}{\tDL} \\
      &\bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j} \\
  \tL &= \letinM{x}{\tM:T}{\tM} \\
  \tM &= \omatch{x}{\rep{C\:\rep{x}\Rightarrow \tL}} \\
      &\bnfor \tE \\
  \tE &= x \bnfor f \bnfor c \bnfor C \bnfor T \\
    &\bnfor \tF\:\rep{x} & \text{$0 < |x|$} \\
    &\bnfor \tC\:\rep{\tA} & \text{$0 < |\tA|$} \\
    &\bnfor \tD \\
  \tF &= x \bnfor f \bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j} \\
  \tC &= c \bnfor C \\
  \tA &= x \bnfor u & \text{$u$ is a static argument (normal \gallina{} term without FV)}
\end{align*}

The application in previous section, $\tF\:\rep{x}$, is changed to $\tC\:\rep{\tA}$ for constant and constructor applications.
(This is not V-normal form because $\tA$ can be non-variable.)

Static arguments are defined as follows by default.
\begin{itemize}
  \item non-monomorphic arguments for constant functions.
    (The non-monomorphic argument means an argument which type is a sort or a polymorphic function type.)
  \item parameters for constructors.
\end{itemize}
The static arguments can be customized with \lstinline!CodeGen StaticArgs! command.

This transformation makes that static arguments contain no variable bounded by let-ins
because such variables are redex of delta reduction.
Thus, this transformation makes Unused let-in Deletion (\secref{sec:let-in-deletion}) more effective.

\subsection{Unused let-in Deletion}\label{sec:let-in-deletion}

\begin{gather*}
  \text{zeta-del:}~
    \dfrac{
      \text{$x$ does not occur in $u$} \quad \text{$x$ is not linear} \quad \text{$\FV(t)$ does not contain linear variable}
    }{E[\Gamma] \vdash \letin{x}{t}{u}
                       \reltri
                       u
    }
\end{gather*}

\subsection{Call Site Replacement}\label{sec:call-site-replacement}

\begin{gather*}
  \text{replace:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is a constant or constructor} \\
        \text{$a_{|a|}$ is not a v-variable} \\
        \rep{a} = \merg_t(\rep{u}, \rep{x}) \\
        \text{$\rep{y}$ are fresh v-variables} \quad
        |x| = |y| \\
        \rep{b} = \merg_t(\rep{u}, \rep{y}) \\
        \text{$c$ is a fresh constant} \\
      \end{gathered}
    }{E[\Gamma] \vdash_K t\:\rep{a}\:\rep{z}
      \reltri
      (E;\glodefB{c}{\lam{\rep{y}}{t\:\rep{b}}})[\Gamma] \vdash c\:\rep{x}\:\rep{z}
    }
\end{gather*}

$K$ is a non-application context to restrict $t\:\rep{a}\:\rep{z}$ is not at a function position of an application.
($K = \$, (\lam{x}{[]})$, $(t\:[])$, $(\letin{x}{[]}{u})$, $(\letin{x}{t}{[]})$, or \ldots but NOT $([]\:u)$.)

$\merg_t(\rep{u}, \rep{x})$ represents a sequence of terms which two sequences of terms are merged according to the static arguments definition of $t$.
The first argument $\rep{u}$ specifies static arguments.
The second argument $\rep{x}$ specifies dynamic arguments.
For example, assuming the 1st and 4th arguments are static for $t$, $\merg_t((u_1, u_2), (x_1, x_2, x_3)) = (u_1, x_1, x_2, u_2, x_3)$.

This transformation removes non-variable arguments from applications.
Thus the result will be V-normal form again.

\begin{align*}
  \tDL &= \tD \\
       &\bnfor \tL & \text{the type of $\tL$ is an inductive type} \\
  \tD &= \lamT{x}{T}{\tDL} \\
      &\bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j} \\
  \tL &= \letinM{x}{\tM:T}{\tM} \\
  \tM &= \omatch{x}{\rep{C\:\rep{x}\Rightarrow \tL}} \\
      &\bnfor \tE \\
  \tE &= x \bnfor f \bnfor c \bnfor C \bnfor T \\
    &\bnfor \tF\:\rep{x} & \text{$0 < |x|$} \\
    &\bnfor \tD \\
  \tF &= x \bnfor f \bnfor c \bnfor C \bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j}
\end{align*}

\subsection{Eta Reduction to Expose Fixpoint}\label{sec:eta-reduction}

\begin{gather*}
  \text{etared-fix:}~
    \dfrac{
      E[\Gamma] \vdash t : \forall \rep{x{:}T}.\: U \quad
      \text{$\rep{x}$ does not occur in $t$} \quad
      \text{$t$ is a fixpoint}
    }{E[\Gamma] \vdash \lam{\rep{x{:}T}}{t\: \rep{x}}
                       \reltri
                       t
    }
\end{gather*}
{\small Note:
\begin{itemize}
  \item We require the types of arguments of $t$ as $\rep{T}$ to prevent this transfomation changes the type.
  \item The premise ``$t$ is a fixpoint'' guarantees the result is not partial application.
\end{itemize}}

\newcommand{\ttapp}{\texttt{app}}
\newcommand{\ttlist}{\texttt{list}}
\newcommand{\ttbool}{\texttt{bool}}
\newcommand{\ttA}{\texttt{A}}
\newcommand{\ttT}{\texttt{T}}
\newcommand{\ttl}{\texttt{l}}
\newcommand{\ttm}{\texttt{m}}

This transformation is intended to remove eta-redexes introduced by static arguments and eta expansion (\secref{sec:eta-expand-funcs}).
For example, assume the standard list concatenation function,
$\ttapp: \forall \ttA, \ttlist\:\ttA \rightarrow \ttlist\:\ttA \rightarrow \ttlist\:\ttA$,
is monomorphized to $\ttbool$.

\begin{align*}
  & \ttapp\:\ttbool \\
  \reltri_\textrm{inline}\; & (\lam{\ttA}{(\kwfix \ldots)})\:\ttbool \\
  \reltri_\textrm{eta-expansion}\; & \lam{\ttl}{\lam{\ttm}{(\lam{\ttA}{(\kwfix \ldots)})\:\ttbool\:\ttl\:\ttm}} \\
  \reltri_\textrm{V-normalization}\; & \lam{\ttl}{\lam{\ttm}{\letin{\ttT}{\ttbool}{(\lam{\ttA}{(\kwfix \ldots)})\:\ttT\:\ttl\:\ttm}}} \\
  \reltri_\textrm{S-normalization}\; & \lam{\ttl}{\lam{\ttm}{\letin{\ttT}{\ttbool}{(\kwfix \ldots)\:\ttl\:\ttm}}} \\
  \reltri_\textrm{Type-nomalization}\; & \lam{\ttl}{\lam{\ttm}{\letin{\ttT}{\ttbool}{(\kwfix \ldots)\:\ttl\:\ttm}}} & \textrm{(expand $\ttT$ in the \kwfix-term)} \\
  \reltri_\textrm{zeta-del}\; & \lam{\ttl}{\lam{\ttm}{(\kwfix \ldots)\:\ttl\:\ttm}} \\
  \reltri_\textrm{etared-fix}\; & (\kwfix \ldots) \\
\end{align*}

The code generator (\secref{sec:c-code-gen}) generates multiple C functions (\secref{sec:genfunm}) from the pre-eta-reduction term, $\lam{\ttl}{\lam{\ttm}{(\kwfix \ldots)\:\ttl\:\ttm}}$.
This eta-reduction avoid this.
The code generator generates single C function (\secref{sec:genfuns}) from post-eta-reduction term, $(\kwfix \ldots)$.

\subsection{Argument Completion}\label{sec:argcomp}
Argument completion removes partial applications by applying eta expansions.

\begin{gather*}
  \text{argcomp-papp:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is not an application} \\
        0 < |x| \\
        E[\Gamma] \vdash t\:\rep{x} : \forall \rep{y{:}T}, U \\
        \text{$U$ is an inductive type}
      \end{gathered}
    }{E[\Gamma] \vdash_K
        t\:\rep{x}
        \reltri
        \lam{\rep{y{:}T}}{t\:\rep{x}\:\rep{y}}
    } \breakrule
  \text{argcomp-fvar-cnst-cstr:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is a f-variable, constant, or constructor} \\
        E[\Gamma] \vdash t : \forall \rep{y{:}T}, U \\
        \text{$U$ is an inductive type}
      \end{gathered}
    }{E[\Gamma] \vdash_K
        t
        \reltri
        \lam{\rep{y{:}T}}{t\:\rep{y}}
    }
\end{gather*}

$K$ is a non-application context as in \secref{sec:call-site-replacement}.

This transformation makes the result of an application inductive type.
Also, constants and constructors are always fully applied to arguments.
F-variables cannot occur in $\tE$ because they cannot be a inductive type.

\begin{align*}
  \tDL &= \tD \\
       &\bnfor \tL & \text{the type of $\tL$ is an inductive type} \\
  \tD &= \lamT{x}{T}{\tDL} \\
      &\bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j} \\
  \tL &= \letinM{x}{\tM:T}{\tM} \\
  \tM &= \omatch{x}{\rep{C\:\rep{x}\Rightarrow \tL}} \\
      &\bnfor \tE \\
  \tE &= x \bnfor T \\
    &\bnfor c \bnfor C & \text{The type of $c$ and $C$ are inductive type} \\
    &\bnfor \tF\:\rep{x} & \text{$0 < |x|$, the type of $\tF\:\rep{x}$ is inductive type}  \\
    &\bnfor \tD \\
  \tF &= x \bnfor f \bnfor c \bnfor C \bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j}
\end{align*}

\subsection{Unreachable Fixfunc Deletion}\label{sec:unreachable-fixfunc-deletion}

\codegen{} deletes unreachable fix-bounded functions.

\subsection{Monomorphism Check}\label{sec:check-monomorphism}

We check the transformed term is a monomorphic term.

Although our transformations removes many rank-1 polymorphism,
it still possible to retain polymorphic term.
For example, our transformations don't remove polymorphic recursion unless
the recursion is completely unrolled.

This step checks
(1) all type annotations are inductive or function types without free variables, and
(2) types and sorts doesn't occur at expression.

\begin{align*}
  \tDL &= \tD \\
       &\bnfor \tL & \text{the type of $\tL$ is an inductive type} \\
  \tD &= \lamT{x}{T}{\tDL} \\
      &\bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j} \\
  \tL &= \letinM{x}{\tM:T}{\tM} \\
  \tM &= \omatch{x}{\rep{C\:\rep{x}\Rightarrow \tL}} \\
      &\bnfor \tE \\
  \tE &= x & \leftarrow \text{$T$ is removed} \\
    &\bnfor c \bnfor C & \text{The type of $c$ and $C$ are inductive type} \\
    &\bnfor \tF\:\rep{x} & \text{$0 < |x|$, the type of $\tF\:\rep{x}$ is inductive type}  \\
    &\bnfor \tD \\
  \tF &= x \bnfor f \bnfor c \bnfor C \bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j}
\end{align*}

\subsection{Borrow Check}\label{sec:borrow-check}

We define two judgements $E[\Gamma] \vdash t:T~|~B$ and $E[\Gamma] \vdash t:T~|~(L, B^\text{used}, B^\text{result})$ for borrow check.
We extend $\Gamma$ in this section.
$\Gamma$ is an annotated local context.
It is a list of $\lassum{x^B}{T}$, $\lassum{f}{T}$ and $\ldef{x^B}{t}{T}$.
They are same as local assumption and local definitions except that
the v-variable $x$ is annotated with a borrow information $B$.
(The f-variable $f$ is not-annotated.)
$B$ is a set of pair of borrow type and linear variable, such as $\{\rep{(T,x)}\}$.
$B^\text{used}$ and $B^\text{result}$ are also borrow information.
$L$ is a set of linear variables.
$T$ is the type of $t$.

We write $\Bop_\Gamma x$ to refer the borrow information for $x$ in $\Gamma$.
$\Bop_\Gamma x = B$ if $\Gamma$ contains $\lassum{x^B}{T}$ or $\ldef{x^B}{t}{T}$.

We omit $:T$ in a rule which does not use $T$.

The borrow information $B=\{\rep{(T,x)}\}$ represents a linear variable $x_i$ is used via borrow type $T_i$.
$\lassum{x^{\{(T',y)\}}}{T}\in \Gamma$ represents $x$ may contain a value of type $T'$ which is a (part of) content of the linear variable $y$.

$E[\Gamma] \vdash t~|~B$ means a function $t$ may use linear variables via borrow $B$.

$E[\Gamma] \vdash t~|~(L, B^\text{used}, B^\text{result})$ means an expression $t$
(1) consumes linear variables $L$,
(2) may use linear values via borrow $B^\text{used}$,
(3) result value may contain linear values via borrow $B^\text{result}$.

For example, assume linear list \lstinline!lseq!, borrow list \lstinline!bseq! which has constructors \lstinline!bnil! and \lstinline!bcons!,
borrow function \lstinline!borrow : lseq nat -> bseq nat!.
In a code fragment \\
\lstinline!let y := borrow x in match y with bnil => true | bcons h t => false end! contains variables
\lstinline!x : lseq nat!,
\lstinline!y : bseq nat!,
\lstinline!h : nat!, and
\lstinline!t : bseq nat!.
\texttt{y} and \texttt{t} contain a \texttt{bseq nat} value borrowed from \texttt{x}.
It is represented as
$\texttt{y}^{\{(\texttt{bseq nat},\texttt{x})\}}:\text{\texttt{bseq nat}}$ and
$\texttt{t}^{\{(\texttt{bseq nat},\texttt{x})\}}:\text{\texttt{bseq nat}}$.
\texttt{h} is annotated as $\texttt{h}^\varnothing$ which means \texttt{h} does not contain borrowed values.
The type of \texttt{h} is \texttt{nat}.
Since \texttt{nat} is not a borrow type, \texttt{h} lives even after \texttt{x} is consumed.

\begin{gather*}
  \text{borrow-lvar:}~
    \dfrac
    {
      \lassum{x^B}{T} \in \Gamma \quad \text{$x$ is linear}
    }{
      E[\Gamma] \vdash x ~|~ (\{x\}, B, B)
    } \breakrule
  \text{borrow-vvar:}~
    \dfrac
    {
      \lassum{x^B}{T} \in \Gamma \quad \text{$x$ is not linear}
    }{
      E[\Gamma] \vdash x ~|~ (\varnothing, B, B)
    } \breakrule
  \text{borrow-fvar:}~
    E[\Gamma] \vdash f ~|~ (\varnothing, \varnothing, \varnothing)
    \breakrule
  \text{borrow-constant:}~
    \dfrac
    {
      \text{$c$ is not a borrow function}
    }{
      E[\Gamma] \vdash c ~|~ (\varnothing, \varnothing, \varnothing)
    } \breakrule
  \text{borrow-constructor:}~
    E[\Gamma] \vdash C ~|~ (\varnothing, \varnothing, \varnothing) \breakrule
  \text{borrow-letin:}~
    \dfrac
    {
      \begin{gathered}
        E[\Gamma] \vdash t_1 ~|~ (L_1, B^\text{used}_1, B^\text{result}_1) \\
        E[\Gamma;\ldef{x^{B^\text{result}_1}}{t_1}{T}] \vdash t_2 ~|~ (L_2, B^\text{used}_2, B^\text{result}_2) \\
        L_1 \cap L_2 = \varnothing \\
        \text{$x$ is linear} \rightarrow x \in L_2 \\
        L_1 \cap B^\text{used}_2 = \varnothing
      \end{gathered}
    }{
      E[\Gamma] \vdash \letin{x}{t_1:T}{t_2} ~|~ (L_1\cup L_2 - \{x\}, B^\text{used}_1\cup B^\text{used}_2 - \{x\}, B^\text{result}_2 - \{x\})
    } \breakrule
  \text{borrow-match:}~
    \dfrac{
      \begin{gathered}
        E[\Gamma] \vdash y ~|~(L_\text{item}, B^\text{used}_\text{item}, B^\text{result}_\text{item}) \\
        B_{ij} = B^\text{result}_\text{item} \cap \components_E(T_{ij}) \\
        \rep{\Gamma' = \rep{\lassum{x^{B}}{T}}} \\
        \rep{\underline{E}[\underline{\Gamma} ; \Gamma'] \vdash t ~|~(L^\text{branch}, B^\text{used}, B^\text{result})} \\
        \rep{L^\text{branch} \cap \{\rep{x}\} = \{ z ~|~ z \in \{\rep{x}\} ~\wedge~ \text{$z$ is linear} \}} \\
        \rep{L^\text{branch'} = L^\text{branch} - \{\rep{x}\}} \quad
        \forall i, \forall j, \left(L^\text{branch'}_i = L^\text{branch'}_j\right) \quad
        L_\text{item} \cap L^\text{branch'}_1 = \varnothing \\
        B^\text{used}_\text{branches} = \tbigcup_i ({B^\text{used}_i - \{\rep{x_i}\}}) \quad
        B^\text{result}_\text{branches} = \tbigcup_i (B^\text{result}_i - \{\rep{x_i}\}) \quad
        L_\text{item} \cap B^\text{used}_\text{branches} = \varnothing \\
      \end{gathered}
    }{
      E[\Gamma] \vdash \omatch{y}{\rep{C\: \rep{x{:}T} \Rightarrow t}} ~|~ (L_\text{item} \cup L^\text{branch'}_1, B^\text{used}_\text{item} \cup B^\text{used}_\text{branches}, B^\text{result}_\text{branches})
    } \breakrule
  \text{borrow-vvar-app:}~
    \dfrac{
      \begin{gathered}
        \lassum{y^{B}}{T'} \in \Gamma \quad
        \APP(E, \Gamma, B, \rep{x}, T, L, B^\text{used}, B^\text{result})
      \end{gathered}
    }{
      E[\Gamma] \vdash y\:\rep{x} : T ~|~ (L, B^\text{used}, B^\text{result})
    } \breakrule
  \text{borrow-fvar-app:}~
    \dfrac{
      \begin{gathered}
        \lassum{f}{T'} \in \Gamma \quad
        \APP(E, \Gamma, \varnothing, \rep{x}, T, L, B^\text{used}, B^\text{result})
      \end{gathered}
    }{
      E[\Gamma] \vdash f\:\rep{x} : T ~|~ (L, B^\text{used}, B^\text{result})
    } \breakrule
  \text{borrow-constant-app:}~
    \dfrac{
      \begin{gathered}
        \text{$c$ is not a borrow function} \quad
        \APP(E, \Gamma, \varnothing, \rep{x}, T, L, B^\text{used}, B^\text{result})
      \end{gathered}
    }{
      E[\Gamma] \vdash c\:\rep{x} : T ~|~ (L, B^\text{used}, B^\text{result})
    } \breakrule
  \text{borrow-constructor-app:}~
    \dfrac{
      \APP(E, \Gamma, \varnothing, \rep{x}, T, L, B^\text{used}, B^\text{result})
    }{
      E[\Gamma] \vdash C\: \rep{x} : T ~|~ (L, B^\text{used}, B^\text{result})
    } \breakrule
  \text{borrow-fix-app:}~
    \dfrac{
      \begin{gathered}
        E[\Gamma] \vdash \ofix{\rep{f:=t}}{f_j} ~|~ B \quad
        \APP(E, \Gamma, B, \rep{x}, T, L, B^\text{used}, B^\text{result})
      \end{gathered}
    }{
      E[\Gamma] \vdash (\ofix{\rep{f:=t}}{f_j})\:\rep{x} : T ~|~ (L, B^\text{used}, B^\text{result})
    } \breakrule
  \text{borrow-borrow:}~
    \dfrac{
      \begin{gathered}
        \text{$c$ is a borrow function} \\
        E[\Gamma] \vdash c : T^\text{arg} \rightarrow T^\text{result} \quad
        \text{$T^\text{arg}$ is a linear type} \quad
        \text{$T^\text{result}$ is a borrow type} \\
        \text{$T^\text{result}$ does not contain function} \\
        \text{$\{\rep{T}\}$ is the set of borrow types contained in $T^\text{result}$} \\
        B = \{\rep{(T,\underline{x})}\}
      \end{gathered}
    }{
      E[\Gamma] \vdash c\:x ~|~ (\varnothing, B, B)
    }
\end{gather*}

\begin{gather*}
  \text{borrow-fix-clo:}~
    \dfrac{
      E[\Gamma] \vdash \ofix{\rep{f:=t}}{f_j} ~|~ B
    }{
      E[\Gamma] \vdash \ofix{\rep{f:=t}}{f_j} ~|~ (\varnothing, B, B)
    } \breakrule
  \text{borrow-abs-clo:}~
    \dfrac{
      E[\Gamma] \vdash \lam{x}{t} ~|~ B
    }{
      E[\Gamma] \vdash \lam{x}{t} ~|~ (\varnothing, B, B)
    } \breakrule
  \text{borrow-abs-fun:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is not an abstraction} \\
        \text{$t$ is not a fixpoint} \\
        E[\Gamma;\rep{\lassum{x^\varnothing}{T}}] \vdash t ~|~ (L,B^\text{used},B^\text{result}) \\
        \{ z | z \in \{\rep{x}\} \wedge \text{$z$ is linear} \} = L \\
        B' = (B^\text{used} - \{\rep{x}\}) \\
      \end{gathered}
    }{
      E[\Gamma] \vdash \lam{\rep{x{:}T}}{t} ~|~ B'
    } \breakrule
  \text{borrow-abs-fix:}~
    \dfrac{
      \begin{gathered}
        \text{$t$ is a fixpoint} \\
        E[\Gamma;\rep{\lassum{x^\varnothing}{T}}] \vdash t ~|~ B \\
        \forall z \in \{\rep{x}\},~ \text{$z$ is not linear} \\
      \end{gathered}
    }{
      E[\Gamma] \vdash \lam{\rep{x{:}T}}{t} ~|~ B
    } \breakrule
  \text{borrow-fix-fun:}~
    \dfrac{
      \begin{gathered}
        \rep{\underline{E[\Gamma;\rep{\lassum{f}{T}}]} \vdash t ~|~ B} \\
      \end{gathered}
    }{
      E[\Gamma] \vdash \ofix{\rep{f{:}T:=t}}{f_j} ~|~ {\tbigcup_i B_i}
    }
\end{gather*}

\begin{align*}
  &\APP(E, \Gamma, B^\text{func}, \rep{x}, T, L, B^\text{used}, B^\text{result}) \\
  &= 1 \leq |x| \\
  &~\wedge \forall i, \forall j, (i \neq j \rightarrow \neg (x_i = x_j \wedge \text{$x_i$ is linear})) \\
  &~\wedge L = \{ z | z \in \{\rep{x}\} ~\wedge~ \text{$z$ is linear} \} \\
  &~\wedge B^\text{used} = B^\text{func} \cup \tbigcup_i (\Bop_\Gamma x_i) \\
  &~\wedge B^\text{result} = B^\text{used} \cap \components_E(T) \\
  &~\wedge B^\text{used} \cap L = \varnothing \\
\end{align*}

We use a function $\components_E(T)$ to obtain the component types of a type $T$ under the global environment $E$.
It returns a set of types or $\top$.
$\top$ is a set which contains all types.
$\components_E(T)$ is defined as the minimum set which satisfy following equations.
\begin{align*}
  & \components_E(I\:\rep{t}) = \{I\:\rep{t}\} \cup \tbigcup_{(x{}:T) \in \Gamma_B} \components_E(T) \\
  & \begin{aligned}
    \quad \text{where}~
    & E[] \vdash I\:\rep{t} : S \\
    & \text{$S$ is a sort} \\
    & \text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C) \in E \\
    & \text{$p$ the is number of recursively uniform parameters of $\text{\sf Ind}\:[p]\:(\Gamma_I := \Gamma_C)$} \\
    & I \in \Gamma_I \\
    & |t| = p \\
    & (C:\forall \Gamma_P, \forall \Gamma_A, I\:\rep{u}) \in \Gamma_C \\
    & \subst{(I\:\rep{u})}{\Gamma_P}{\rep{t}} = I\:\rep{t} \\
    & \Gamma_B = \subst{\Gamma_A}{\Gamma_P}{\rep{t}}
    \end{aligned} \\
  & \components_E(\forall T, U) = \top \\
  & \components_E(S) = \top \\
  & \quad \text{where}~ \text{$S$ is a sort} \\
\end{align*}

We extend substitution for local contexts here.
$\subst{t}{\Gamma}{\rep{u}}$ represents the term $t$ which variables in $\Gamma$ are substituted with terms $\rep{u}$.
$\subst{\Gamma'}{\Gamma}{\rep{u}}$ represents the local context $\Gamma'$ which variables in $\Gamma$ are substituted with terms $\rep{u}$.
If $\Gamma$ contains a local definition, its variable is substituted with the corresponding definition.
($\epsilon$ is the empty local context. $\varepsilon$ is the empty list of terms.)
\begin{align*}
  \subst{t}{\epsilon}{\varepsilon} &= t \\
  \subst{t}{(\lassum{x}{T};\Gamma)}{(a\:\rep{u})} &= \subst{\subst{t}{x}{a}}{\subst{\Gamma}{x}{a}}{\rep{u}} \\
  \subst{t}{(\ldef{x}{a}{T};\Gamma)}{\rep{u}} &= \subst{\subst{t}{x}{a}}{\subst{\Gamma}{x}{a}}{\rep{u}} \\
  \subst{\epsilon}{\Gamma}{\rep{u}} &= \epsilon \\
  \subst{(\lassum{x}{T};\Gamma')}{\Gamma}{\rep{u}} &= \lassum{x}{\subst{T}{\Gamma}{\rep{u}}};\subst{\Gamma'}{\Gamma}{\rep{u}} \\
  \subst{(\ldef{x}{a}{T};\Gamma')}{\Gamma}{\rep{u}} &= \ldef{x}{\subst{a}{\Gamma}{\rep{u}}}{\subst{T}{\Gamma}{\rep{u}}};\subst{\Gamma'}{\Gamma}{\rep{u}}
\end{align*}

We mix borrow information and set of variables in set-operations.
Assume $L=\{x_1,\ldots,x_n\}$ and $B=\{(T_1,y_1),\ldots,(T_m,y_m)\}$.
\begin{align*}
  B \cap L = L \cap B &= \{(T_i,y_i) \in B ~|~ 1\leq i\leq m,~ y_i \in L \} \\
  B - L &= \{(T_i,y_i) \in B ~|~ 1\leq i\leq m,~ y_i \notin L \}
\end{align*}

We also mix borrow information and set of types (including $\top$) in set-operations.
\begin{align*}
  B \cap D = D \cap B &= \{(T_i,y_i) \in B ~|~ 1\leq i\leq m,~ T_i \in D \} & D = \{U_1, \ldots, U_n\} \\
  B \cap \top = \top \cap B &= B
\end{align*}

{\small Note:
\begin{itemize}
  \item We don't annotate f-variables.
    This is not correct because invoking $f_1\ldots f_n$ may refer borrowed values via free variables in
    $\ofix{\rep{f{:}T:=t}}{f_j}$.
    However, it is harmless because corresponding linear value cannot be consumed in the fix-term.
\end{itemize}}

\subsection{C Variable Allocation}\label{sec:cvaralloc}

We rename variables to be unique and approproate for C.

Since \gallina{} variables are represented by de Bruijn's indexes,
we only need to change variable names in binders:
(1) variable of abstraction,
(2) functions of fixpoint,
(3) variable of let-in, and
(4) variables of constructor members of conditional.

\begin{align*}
  \tDL &= \tD \\
       &\bnfor \tL & \text{the type of $\tL$ is an inductive type} \\
  \tD &= \lamT{\fbox{$x$}}{T}{\tDL} & \leftarrow (1) \\
      &\bnfor \ofix{\rep{\fbox{$f$}/k{:}T:=\tD}}{f_j} & \leftarrow (2) \\
  \tL &= \letinM{\fbox{$x$}}{\tM:T}{\tM} & \leftarrow (3) \\
  \tM &= \omatch{x}{\rep{C\:\rep{\fbox{$x$}}\Rightarrow \tL}} & \leftarrow (4) \\
      &\bnfor \tE \\
  \tE &= x \\
    &\bnfor c \bnfor C & \text{The type of $c$ and $C$ are inductive type} \\
    &\bnfor \tF\:\rep{x} & \text{$0 < |x|$, the type of $\tF\:\rep{x}$ is inductive type}  \\
    &\bnfor \tD \\
  \tF &= x \bnfor f \bnfor c \bnfor C \bnfor \ofix{\rep{\fbox{$f$}/k{:}T:=\tD}}{f_j} & \leftarrow (2)
\end{align*}

\section{C Code Generation}\label{sec:c-code-gen}
\subsection{The \gallina{} Subset for C Code Generation}\label{sec:gallinasubsetforcgen}

\begin{align*}
  \tDL &= \tD \\
       &\bnfor \tL & \text{the type of $\tL$ is an inductive type} \\
  \tD &= \lamT{x}{T}{\tDL} \\
      &\bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j} \\
  \tL &= \letinM{x}{\tM:T}{\tM} \\
  \tM &= \omatch{x}{\rep{C\:\rep{x}\Rightarrow \tL}} \\
      &\bnfor \tE \\
  \tE &= x \\
    &\bnfor c \bnfor C & \text{The type of $c$ and $C$ are inductive type} \\
    &\bnfor \tF\:\rep{x} & \text{$0 < |x|$, the type of $\tF\:\rep{x}$ is inductive type}  \\
    &\bnfor \tD \\
  \tF &= x \bnfor f \bnfor c \bnfor C \bnfor \ofix{\rep{f/k{:}T:=\tD}}{f_j}
\end{align*}

\subsection{Detection of Higher Order Fixfuncs}\label{sec:higher-order-fixfunc-detection}

We call the set of f-variables of higher order fixfuncs $\HigherOrderFixfunc$.

\subsection{Detection of Inlinable Fixpoints}\label{sec:inlinable-fixpoint-detection}
We detect inlinable fixpoints.
``Inlinable fixpoint'' means a fixpoint, $\ofix{\rep{f:=t}}{f_j}$,
which all applications of $\rep{f}$ are located at the tail positions of $\rep{f}$.
In this case, the continuation of the applications to $\rep{f}$
in $\letin{x}{(\ofix{\rep{f:=t}}{f_j})\;\rep{y}}{u}$
are always $\letin{x}{\Box}{u}$.
Thus, we can translate the tail positions of $\rep{f}$ to
(1) assignments to the arguments of $f_i$ and $\kwgoto{}\;f_i$ for application of $f_i$ and
(2) assignment to $x$ and $\kwgoto{}\;u$ otherwise.
This translation is equivalent to inlining a tail-recursive function, which means generating a loop at a non-tail position.

$\TRFUN{t}$ is the second component of $\RNTFUN{t}$.
It is a set of fixfuncs which are translatable without actual functions.

$\RNTFUN{t}$ and $\RNTEXP{t}$ are defined mutually recursive.
$\RNTFUN{t}$ is four-tuple.
$\RNTEXP{t}$ is three-tuple.
We introduce 7 functions to refer the components of them.
\begin{align*}
  \RNTFUN{t} &= (\INL{t}, \TRFUN{t}, \HFUN{t}, \TFUN{t}) \\
  \RNTEXP{t} &= (\TREXP{t}, \HEXP{t}, \TEXP{t})
\end{align*}

The components means as follows.
\begin{align*}
  \INL{t} &: \text{$t$ is inlinable or not ($\true$ or $\false$)} \\
  \TRFUN{t}, \TREXP{t} &: \text{set of tail-recursive fixfuncs in $t$} \\
  \HFUN{t}, \HFUN{t} &: \text{free f-variables at head positions of $t$} \\
  \TFUN{t}, \TFUN{t} &: \text{free f-variables at tail positions of $t$}
\end{align*}

$\RNTFUN{t}$ traverses abstractions and fixpoints ($\tD$ and $\tDL$).
$\RNTEXP{t}$ traverses other constructs ($\tL$, $\tM$, $\tE$, and $\tF$).

``tail position'' is extended to the function position of the application at a tail position. \\
$\TRop_\text{FUN}$ distinguishes fixpoint bounded functions translatable without actual functions (but with \kwgoto{}) or not.

\begin{align*}
  \RNTFUN{\lam{x}{t}} &= (\INL{t}, \TRFUN{t}, \HFUN{t}, \TFUN{t}) \\
  \RNTFUN{\ofix{\rep{f:=t}}{f_j}} &=
    \begin{cases}
      \begin{aligned}[t]
        \bigl(& \true, \\
              & \tbigcup_i \TRFUN{t_i} \cup \{\rep{f}\}, \\
              & \tbigcup_i \HFUN{t_i} - \{\rep{f}\}, \\
              & \tbigcup_i \TFUN{t_i} - \{\rep{f}\} \bigr)
      \end{aligned}
        & \begin{aligned}[t]
          & \bigl(\tbigcup_i \HFUN{t_i} \cap \{\rep{f}\} = \varnothing\bigr) \wedge {} \\
          & \bigl(\HigherOrderFixfunc \cap \{\rep{f}\} = \varnothing\bigr) \wedge {} \\
          & \forall i,~ \INL{t_i}
          \end{aligned} \\
      \begin{aligned}[t]
        \bigl(& \false, \\
              & \tbigcup_i \TRFUN{t_i}, \\
              & \tbigcup_i (\HFUN{t_i} \cup \TFUN{t_i}) - \{\rep{f}\}, \\
              & \varnothing \bigr)
      \end{aligned}
        & \text{otherwise}
    \end{cases} \\
  \RNTFUN{t} &= (\true, \TREXP{t}, \HEXP{t}, \TEXP{t}) \\
    & \text{if}~\text{$t$ is not abstraction nor fixpoint}
\end{align*}
\begin{align*}
  \RNTEXP{x\:\rep{y}} &= (\varnothing, \varnothing, \varnothing) \\
  \RNTEXP{f\:\rep{y}} &= (\varnothing, \varnothing, \{f\}) \\
  \RNTEXP{c\:\rep{y}} &= (\varnothing, \varnothing, \varnothing) \\
  \RNTEXP{C\:\rep{y}} &= (\varnothing, \varnothing, \varnothing) \\
  \RNTEXP{\letin{x}{t}{u}} &=
    ( \begin{aligned}[t]
      & \TREXP{t} \cup \TREXP{u}, \\
      & \HEXP{t} \cup \TEXP{t} \cup \HEXP{u}, \\
      & \TEXP{u})
      \end{aligned} \\
  \RNTEXP{\omatch{y}{\rep{C\:\rep{x}\Rightarrow t}}} &= \bigl(\tbigcup_i \TREXP{t_i}, \tbigcup_i \HEXP{t_i}, \tbigcup_i \TEXP{t_i} \bigr) \\
  \RNTEXP{t} &= (\TRFUN{t}, \HEXP{t} \cup \TEXP{t}, \varnothing) \\
    & \text{if}~(t = \lam{x}{u}) \vee (t = \ofix{\rep{f:=u}}{f_j}) \\
  \RNTEXP{t\:\rep{y}} &= (\TRFUN{t}, \HEXP{t}, \TEXP{t}) \\
    & \text{if}~(t = \ofix{\rep{f:=u}}{f_j}) \wedge (|y| > 0)
\end{align*}

{\small Note:
\begin{itemize}
  \item The variables in $t$ are unique.
    \codegen{} uses de Bruijn's indexes for $\MyH$ and $\MyT$;
    the variables renamed by \secref{sec:cvaralloc} for $\TRop$.
  \item $y$ of $\omatch{y}{\rep{C\:\rep{x}\Rightarrow t}}$ is not counted because $y$ is not a function and does not affect the final $\TRop$.
  \item $\INLop$ guarantees that consecutive fixpoints and abstractions ($\tD$, traversed by $\RNTop_\text{LF}$) synthesizes non-inlinableness:
    an outer fixpoint is not inlinable if an inner fixpoint is not-inlinable.
    This property holds in most case without $\INLop$ but an curious fixpoint (such as non-recursive fixpoint) can break this property.
    Thus we added $\INLop$.
\end{itemize}}

\subsection{Head Position and Tail Position}\label{sec:head-position-and-tail-position}

\begin{align*}
  \tDL_p &= \tD_p \\
       &\bnfor \tL_p \\
  \tD_p &= \lamT{x}{T}{\tDL_p} \\
      &\bnfor \ofix{\rep{f/k{:}T:=\tD_p}}{f_j} \\
  \tL_p &= \letinM{x}{\tM_\HEAD:T}{\tM_p} \\
  \tM_p &= \omatch{x}{\rep{C\:\rep{x}\Rightarrow \tL_p}} \\
    &\bnfor \tE_p \\
  \tE_p &= x \\
    &\bnfor c \bnfor C \\
    &\bnfor \tF_p\:\rep{x}  \\
    &\bnfor \tD_\TAIL \\
  \tF_p &= x \bnfor f \bnfor c \bnfor C \\
    &\bnfor \ofix{\rep{f/k{:}T:=\tD_p}}{f_j} & f_j \in \tr \\
    &\bnfor \ofix{\rep{f/k{:}T:=\tD_\TAIL}}{f_j} & f_j \notin \tr
\end{align*}

{\small Note:
\begin{itemize}
  \item $\tr = \TRFUN{t}$ where the translating function is defined as \kwDefinition~$c := t$.
\end{itemize}}

\subsection{Top-Level Functions Detection}\label{sec:top-level-function-detection}
If a fixpoint needs recursive call in C, we need a real C function for it.
\codegen{} detects such fixpoints by simulating $A_K$ and $B_K$ in \secref{sec:AK} and \secref{sec:BK} to collect application of fixpoint-bounded functions.

\subsection{Fix-lifting}\label{sec:fix-lifting}

We use lambda-lifting-like technique to translate fixpoint expressions without closures.

Consider following (artificial) example.

\begin{lstlisting}
Definition c x y :=
  fix f n :=
  match n with
  | O => x                  (* invocation of f needs x *)
  | S n' =>
    (fix g m :=
    match m with
    | O => y + f n'         (* invocation of g needs y and f *)
    | S m' => S (g m')
    end) n
  end.
\end{lstlisting}

\codegen{} translate a \gallina{} application to C function call (if \kwgoto{} is not usable).
In this scenario, \codegen{} generates C functions corresponding to internal functions \lstinline[style=Cstyle]!f! and \lstinline[style=Cstyle]!g!.
The application in \gallina{}, \lstinline!g m'!, is translated to \lstinline[style=Cstyle]!g(m')! in C.
But it does not work because \lstinline!g! needs \lstinline!y! but the global C function \lstinline[style=Cstyle]!g! does not know \lstinline!y!.
Also, \lstinline!g! needs \lstinline!f!.
Although there is the C function \lstinline!f!, \lstinline!f! needs \lstinline!x!.
Thus, \codegen{} need to add extra arguments as \lstinline[style=Cstyle]!g(x, y, m')! which is similar to lambda-lifting.
We call this translation, adding extra arguments for functions bounded by fixpoints, fix-lifting.

We define $\FIXFUNCS$, $\FIXFV$, $\EXARGS'$, and $\EXARGS$ for each definition \kwDefinition~$c := u$.

$\EXARGS(f)$ is the extra arguments for the fix-bounded function $f$ in the definition.

$\FIXFUNCS$ is the set of f-variables in $u$.

\[
  \FIXFUNCS = \bigcup_{K\left[\ofix{\rep{f:=t}}{f_j}\right] = u} \{\rep{f}\}
\]

$\FIXK(f)$ is the context of the fixpoint which bounds f-variable $f$.

\[
  \FIXK(f) = K \quad \text{where}~u = K[\ofix{\repi{(g_l:=t_l)}{1\leq l < i} (f:=t_i) \repi{(g_l:=t_l)}{i < l \leq h}}{g_j}]  \\
\]

$\FIXFV(f)$ is the set of free variables of the fixpoint which bounds f-variable $f$.
$\FIXFV(x)$ is also defined as empty set for v-variable $x$.

\begin{align*}
  \FIXFV(f) &= \FV(t) \quad \text{where}~u = \FIXK(x)[t] \\
  \FIXFV(x) &= \varnothing
\end{align*}

$\EXARGS'(f)$ is a set which satisfy the following conditions.
$\EXARGS'(f)$ is similar to $\FIXFV(f)$.
But if it contains a function bounded by an outer fixpoint, the free variable of the outer fixpoint are also contained.

\begin{align*}
  \EXARGS'(f) &\supseteq \FIXFV(f) \cup \bigcup_{t \in \FIXFV(f)} \EXARGS'(t) \\
  \EXARGS'(f) &\subseteq \KV(\FIXK(f)) \\
  \EXARGS'(x) &= \varnothing
\end{align*}

\codegen{} chooses the minimal set for $\EXARGS'(f)$ if a dedicated internal C function is generated for $f$.
But if $f$ is callable via $c$ like follows, \codegen{} generate a call to $c$ for $f$
to avoid generating the dedicated C function for \texttt{f}.
This means $\texttt{f}\:\texttt{y'}$ is translated to \lstinline[style=Cstyle]!c(x, y')!.
In this case, the arguments of the external C function for $c$ must corresponds to the type of $c$.
Thus \codegen{} chooses the maximal set (all bound variables) for $\EXARGS'(f)$.
(This means that \texttt{x} is passed even if \texttt{f} does not use \texttt{x}.)

\[
  \kwDefinition~\texttt{c} := \lam{\texttt{x}}{\ofix{\texttt{f}:=\lam{\texttt{y}}{\ldots \texttt{f}\:\texttt{y'} \ldots}}{\texttt{f}}}
\]

$\EXARGS(f)$ is defined as follows.
It is $\EXARGS'(f)$ except fix-bounded functions.

\[
  \EXARGS(f) = \EXARGS'(f) - \FIXFUNCS
\]

When $\EXARGS(f)$ is used in a context which the order matters,
we consider it is a list of variables from declared ouside to inside.
(used in \secref{sec:AK})

When $\EXARGS(f)$ is used in a context which require types,
we consider it is a set of pairs of variable and its type.
(used in \secref{sec:genfunm})

\subsection{Translation to C for a Non-Tail Position}\label{sec:AK}
$\A{K}{t}$ generates C code for $t$ in a non-tail position.
The result expression is passed to $K$. \\
$K(e) = \dq{v = e\ttsemi}$ in simple situations.
\begin{align*}
  &\A{K}{x} = K(\dq{x}) \\
  &\A{K}{f\:\rep{x}} =
      \begin{aligned}[t] \ldq & {\passign(\fvarsd{f}, \rep{x})} \\ & \kwgoto\:\mathtt{entry\_}f\ttsemi \rdq \end{aligned}
    && \begin{aligned}[t] & (|x| > 0) \wedge f \in \tr \end{aligned} \\
  &\A{K}{f\:\rep{x}} = K(\dq{f\ttparen{\rep{y}\ttcomma \rep{x}}})
    && \begin{aligned}[t] & (|x| > 0) \wedge f \notin \tr \quad \text{where} \quad \rep{y} = \EXARGS(f) \end{aligned} \\
      &\A{K}{c\:\rep{x}} = K(\dq{c\ttparen{\rep{x}}})                                   && |x| \geq 0 \\
  &\A{K}{C\:\rep{x}} = K(\dq{C\ttparen{\rep{x}}})                                   && |x| \geq 0 \\
  &\A{K}{\letin{x}{t_1}{t_2}} = \ldq \A{K'}{t_1}\; \A{K}{t_2} \rdq
    && \text{where}\quad K'(e) = \dq{x\:\tteq\:e\ttsemi} \\
  &\A{K}{\omatch{x}{\rep{C\:\rep{y}\Rightarrow t}}} && \text{where}\quad x : T \\
     & \quad\begin{alignedat}{2}
       \ldq & \kwswitch\:\ttparen{\mathit{swfunc}_T\ttparen{x}}\:\ttlbrace \\
            & \cdots \\
            & \mathit{caselabel}_{C_i}\ttcolon\quad
              \begin{aligned}[t]
              & \repi{y_{ij}\:\tteq\:\mathit{get\_member}_{C_i j}(x)\ttsemi}{j} \\
              & \mathit{linear\_dealloc}_{T}(x)\ttsemi \\
              & {\A{K}{t_i}} \\
              & \kwbreak\ttsemi
              \end{aligned} \\
            & \cdots \\
            & \ttrbrace\rdq
       \end{alignedat} \\
  &\A{K}{(\ofix{\rep{f:=t}}{f_j})\:\rep{x}} =                   && f_j \in \tr \\
     & \quad\begin{alignedat}[t]{2}
       \ldq & \passign(\fvars{t_j}, \rep{x}) \\
            & {\genbodyat{K'}{\ofix{\rep{f:=t}}{f_j}}} \\
            & \mathtt{exit\_}f_j\ttcolon \rdq
       \end{alignedat} &&
               \begin{alignedat}[t]{1}
                  & \text{where} \\
                  & K'(e) =
                    \begin{cases}
                    K(e) & \text{$K(e)$ contains \kwgoto}  \\
                    \begin{aligned}[t]
                      \ldq & K(e) \\
                           & \kwgoto\:\mathtt{exit\_}f_j\ttsemi \rdq
                    \end{aligned} & \text{otherwise}
                  \end{cases}
                \end{alignedat} \\
  &\A{K}{(\ofix{\rep{f:=t}}{f_j})\:\rep{x}} =                      && f_j \notin \tr \quad |x| > 0 \\
     & \quad\begin{alignedat}[t]{2}
       \ldq & K(f_j\ttparen{\rep{y}\ttcomma \rep{x}})                  \\
            & \kwgoto\:\mathtt{skip\_}f_j\ttsemi                                    \\
            & {\genbodyan{\ofix{\rep{f:=t}}{f_j}}}                          \\
            & \mathtt{skip\_}f_j\ttcolon \rdq
       \end{alignedat} &&
               \begin{alignedat}[t]{1}
                  & \text{where} \\
                  & \rep{y} = \EXARGS(f_j)
               \end{alignedat}
\end{align*}
{\small Note:
\begin{itemize}
  \item $\dq{\cdots}$ means a string.
    A string can contain characters in typewriter font and expressions starting in italic or roman font.
    The former is preserved as-is.
    The latter embeds the value of the expression (with name translation from \gallina{} to C).
  \item \gallina{} types, constants, and constructors have corresponding (user-configurable) C names and they are implicitly translated.
    \gallina{} variables are translated by the mapping defined in \secref{sec:cvaralloc}.
  \item $\tr = \TRFUN{t}$ where the translating function is defined as \kwDefinition~$c := t$.
  \item $\mathit{swfunc}_T, \mathit{caselabel}_{C_i}$, and $\mathit{get\_member}_{C_i j}$ are defined by a user to translate \kwmatch-expressions for the inductive type $T$.
  \item $\mathit{linear\_dealloc}_{T}(x)$ is the deallocation function for the linear type $T$.  It is empty for unrestricted types.
  \item $\passign(\rep{y}, \rep{x})$ is a parallel assignment. It is translated to a sequence of assignments to assign $x_1\ldots x_n$ into $y_1\ldots y_n$.  It may require temporary variables.
  \item We do not define $\A{K}{\lam{x}{t}}$ because we do not support closures yet.
  \item Actual \codegen{} generates $\genbodyan{}$ in a different position to avoid the label $\mathtt{skip\_}f_j$ and $\kwgoto\:\mathtt{skip\_}f_j\ttsemi$.
\end{itemize}}

\subsection{Translation to C for a Tail Position}\label{sec:BK}
$\B{K}{t}$ generates C code for $t$ in a tail position.
The result expression is passed to $K$. \\
$K(e) = \dq{\kwCreturn\:e\ttsemi}$ in simple situations.
\begin{align*}
  &\B{K}{x} = K(\dq{x}) \\
  &\B{K}{f\:\rep{x}} = \begin{aligned}[t] \ldq & {\passign(\fvarsd{f}, \rep{x})} \\ & \kwgoto\:\mathtt{entry\_}f\ttsemi \rdq \end{aligned}
    && |x| > 0 \\
  &\B{K}{c\:\rep{x}} = K(\dq{c\ttparen{\rep{x}}})                                   && |x| \geq 0 \\
  &\B{K}{C\:\rep{x}} = K(\dq{C\ttparen{\rep{x}}})                                   && |x| \geq 0 \\
  &\B{K}{\letin{x}{t_1}{t_2}} = \ldq \A{K'}{t_1}\; \B{K}{t_2} \rdq
    && \text{where}\quad K'(e) = \dq{x\:\tteq\:e\ttsemi} \\
  &\B{K}{\omatch{x}{\rep{C\:\rep{y}\Rightarrow t}}} = && \text{where}\quad x : T \\
     & \quad\begin{alignedat}{2}
       \ldq & \kwswitch\:\ttparen{\mathit{swfunc}_T\ttparen{x}}\:\ttlbrace \\
            & \cdots \\
            & \mathit{caselabel}_{C_i}\ttcolon\quad
              \begin{aligned}[t]
                & \repi{y_{ij}\:\tteq\:\mathit{get\_member}_{C_i j}(x)\ttsemi}{j} \\
                & \mathit{linear\_dealloc}_{T}(x)\ttsemi \\
                & {\B{K}{t_i}}
              \end{aligned} \\
            & \cdots \\
            & \ttrbrace\rdq
     \end{alignedat} \\
  &\B{K}{(\ofix{\rep{f:=t}}{f_j})\:\rep{x}} =       && |x| > 0 \\
     & \quad\begin{alignedat}{2}
       \ldq & {\passign(\fvars{t_j}, \rep{x})} \\
            & {\genbodyb{K}{\ofix{\rep{f:=t}}{f_j}}} \rdq
       \end{alignedat}
\end{align*}
{\small Note:
\begin{itemize}
  \item We do not define $\B{K}{\lam{x}{t}}$ because a tail position cannot be a function after the argument completion.
\end{itemize}}

\subsection{Auxiliary Functions for Translation to C}\label{sec:aux-function}
\[
  \fvars{t} =
  \begin{cases}
    \dq{x;\:\fvars{u}} & t = \lam{x}{u} \\
    \fvars{t_j}       & t = \ofix{\rep{f:=t}}{f_j} \\
    \dq{}             & \text{otherwise}
  \end{cases}
\]
\[
  \fvarsd{f_i} = \fvars{t_i} \quad \text{for functions bounded by $\ofix{\rep{f:=t}}{f_j}$}
\]
\[
  \genbodyat{K}{t} =
  \begin{cases}
    \genbodyat{K}{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyat{K}{t_i}} & t = \ofix{\rep{f:=t}}{f_j} \\
    \quad \text{for}~i=j, 1,\dotsc, (j-1), (j+1),\dotsc, |f| \\
    \A{K}{t}                            & \text{otherwise}
  \end{cases}
\]
\[
  \genbodyan{t} =
  \begin{cases}
    \genbodyan{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyan{t_i}} & t = \ofix{\rep{f:=t}}{f_j} \\
    \quad \text{for}~i=1,\dotsc, |f| \\
    \B{K}{t}                            & \begin{aligned}[t]
                                            & \text{otherwise} \\
                                            & \text{where} \\
                                            & \quad t:T \\
                                            & \quad K(e) = \dq{\texttt{*($T$*)ret = $e$; \kwCreturn;}}
                                            \end{aligned}
  \end{cases}
\]
\[
  \genbodyb{K}{t} =
  \begin{cases}
    \genbodyb{K}{u}                            & t = \lam{x}{u} \\
    \dq{\mathtt{entry\_}f_i\ttcolon\:\genbodyb{K}{t_i}} & t = \ofix{\rep{f:=t}}{f_j} \\
    \quad \text{for}~i=j, 1,\dotsc, (j-1), (j+1),\dotsc, |f| \\
    \B{K}{t}                            & \text{otherwise}
  \end{cases}
\]
{\small Note:
\begin{itemize}
  \item $\fvarsop$ and $\fvarsop'$ returns a list of variables: $x_1;\ldots;x_n;$.  For simplicity, we omit ``$;$'' if not ambiguous.
  \item $\dq{g(i)}~\text{for}~i=j_1,\dotsc,j_n$ means $\dq{g(j_1)\:\ldots\:g(j_n)}$.
\end{itemize}}


\subsection{Translation for a Top-Level Function which is Translated to Multiple C Functions}\label{sec:genfunm}
$\genfunm{c}$ translates the function (constant) $c$ with one or more auxiliary functions.
We assume $c$ is defined as \kwDefinition~$c := t.$
The auxiliary functions $f_1 \ldots f_n$ are fixpoint bounded functions in $t$ which are invoked as functions.
We assume the types of them:
\begin{align*}
  c &: T_{01} \rightarrow \dotsb \rightarrow T_{0m_0} \rightarrow T_{00} \\
  f_i &: T_{i1} \rightarrow \dotsb \rightarrow T_{im_i} \rightarrow T_{i0} && i = 1\ldots n
\end{align*}
\[ \text{where} \quad \text{$T_{i0}$ are inductive types ($i=0\ldots n$)} \]
The formal arguments of $c$ are $x_{01}\ldots x_{0m_0} = \fvars{t}$ and
the formal arguments of $f_i$ are $x_{i1}\ldots x_{im_i} = \fvarsd{f_i}$.

$f_i$ invocation in C needs extra arguments, $\EXARGS(f_i) = y_{i1}\mathord{:}U_{i1} \ldots y_{il_i}\mathord{:}U_{il_i}$, addition to the actual arguments in \gallina{} application because the free variables of the fixpoint should also be passed.
If the free variables contain a function bounded by an outer fixpoint, the function itself is not passed but the free variables of the outer fixpoint are also passed.
We iterate it until no fixpoint functions.

\begin{alignat*}{2}
  \genfunm{c} &= \ldq && \enumentries{c}~\argstructdefs{c}~\forwarddecl{c}~\entryfunctions{c}~\bodyfunction{c} \rdq
\end{alignat*}
\[ \enumentries{c} = \dq{\kwenum\:\mathtt{enum\_func\_}c\:\ttbrace{ \mathtt{func\_}c \repi{\ttcomma \mathtt{func\_}f_i}{i=1\ldots n} }\ttsemi} \]
\[ \argstructdefs{c} = \dq{\mainstructdef{c}\:\repi{\auxstructdef{c}{i}}{i=1\ldots n} } \]
\[ \mainstructdef{c} = \dq{\kwstruct\:\mathtt{arg\_}c\:\ttbrace{\:\repi{T_{0j}\:\mathtt{arg}j\ttsemi}{j=1\ldots m_0} \:}\ttsemi} \]
\[ \auxstructdef{c}{i} = \dq{\kwstruct\:\mathtt{arg\_}f_i\:\ttbrace{\:\repi{U_{ij}\:\mathtt{exarg}j\ttsemi}{j=1\ldots l_i}\:\repi{T_{ij}\:\mathtt{arg}j\ttsemi}{j=1\ldots m_i}\:}\ttsemi} \]
\[ \forwarddecl{c} = \dq{\kwstatic\:\kwvoid\:\mathtt{body\_function\_}c\ttparen{\kwenum\:\mathtt{enum\_func\_}c\:\mathtt{g}\ttcomma \kwvoid\:\mathtt{\ttstar arg}\ttcomma \kwvoid\:\mathtt{\ttstar ret}}\ttsemi} \]
\[ \entryfunctions{c} = \dq{\mainfunction{c}\:\repi{\auxfunction{c}{i}}{i=1\ldots n}} \]
\begin{alignat*}{2}
  \mainfunction{c} &= \ldq && \kwstatic\:T_{00}\:c\ttparen{\repopi{T_{0j}\:x_{0j}}{\ttcomma}{j=1\ldots m_0}}\:\ttlbrace \\
  & && \quad \kwstruct\:\mathtt{arg\_}c\:\mathtt{arg}\:\tteq\:\ttbrace{ \repopi{x_{0i}}{\ttcomma}{i=1\ldots m_0} }\ttsemi\:T_{00}\:\mathtt{ret}\ttsemi \\
  & && \quad \mathtt{body\_function\_}c\ttparen{\mathtt{func\_}c\ttcomma \ttamp\mathtt{arg}\ttcomma \ttamp\mathtt{ret}}\ttsemi \kwCreturn\:\mathtt{ret}\ttsemi \\
  & && \ttrbrace \rdq
\end{alignat*}
\begin{alignat*}{2}
  \auxfunction{c}{i} &= \ldq && \kwstatic\:T_{i0}\:f_i\ttparen{\repopi{U_{ij}\:y_{ij}}{\ttcomma}{j=1\ldots l_i}\; \repopi{T_{ij}\:x_{ij}}{\ttcomma}{j=1\ldots m_i}}\:\ttlbrace \\
  & && \quad \kwstruct\:\mathtt{arg\_}f_i\:\mathtt{arg}\:\tteq\:\ttbrace{ \repopi{y_{ij}}{\ttcomma}{j=1\ldots l_i}\; \repopi{x_{ij}}{\ttcomma}{j=1\ldots m_i} }\ttsemi\:T_{i0}\:\mathtt{ret}\ttsemi\\
  & && \quad \mathtt{body\_function\_}c\ttparen{\mathtt{func\_}f_i\ttcomma \ttamp\mathtt{arg}\ttcomma \ttamp\mathtt{ret}}\ttsemi\:\kwCreturn\:\mathtt{ret}\ttsemi \\
  & && \ttrbrace \rdq
\end{alignat*}
\begin{alignat*}{2}
  \bodyfunction{c} &= \ldq
    && \kwstatic\:\kwvoid\:\mathtt{body\_function\_}c\ttparen{\kwenum\:\mathtt{enum\_func\_}c\:\mathtt{g}\ttcomma \kwvoid\:\ttstar\mathtt{arg}\ttcomma \kwvoid\:\ttstar\mathtt{ret}}\:\ttlbrace \\
  & && \quad \mathit{decls} \\
  & && \quad \kwswitch\:\ttparen{\mathtt{g}}\:\ttbrace{\:\repi{\auxcase{c}{i}}{i=1\ldots n} \:\maincase{c}\:} \\
  & && \quad {\genbodyb{K}{t}} \\
  & && \ttrbrace \rdq
\end{alignat*}
\begin{align*}
  \auxcase{c}{i} = \ldq & \kwcase\:\mathtt{func\_}f_i\ttcolon \\
  & \repi{y_{ij}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{exarg}j\ttsemi}{j=1\ldots l_i} \\
  & \repi{x_{ij}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}f_i\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}j\ttsemi}{j=1\ldots m_i} \\
  & \kwgoto\:\mathtt{entry\_}f_i\ttsemi \rdq
\end{align*}
\begin{align*}
  \maincase{c} = \ldq & \kwdefault\ttcolon\ttsemi \\
  & \repi{x_{0j}\:\tteq\:\ttparen{\ttparen{\kwstruct\:\mathtt{arg\_}c\:\ttstar}\mathtt{arg}}\texttt{->}\mathtt{arg}j\ttsemi}{j=1\ldots m_0} \rdq
\end{align*}
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$\mathit{decls}$ is local variable declarations for variables used in $\genbodyb{K}{t}$.} \\
    & K(e) = \dq{\ttstar\ttparen{T_{00}\ttstar}\texttt{ret}\:\tteq\:e\ttsemi \kwCreturn\ttsemi}
  \end{aligned}
\]

\subsection{Translation for a Top-Level Function which is Translated to a Single C Function}\label{sec:genfuns}
$\genfuns{c}$ translates the function (constant) $c$ to a single C function.
\[
  \genfuns{c} = \dq{\kwstatic\:T_0\:c\ttparen{\fargsd{t}}\:\ttbrace{\:\mathit{decls}\:\genbodyb{K}{t}\:}}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$c$ is defined as \kwDefinition~$c : T_1 \rightarrow \dotsb \rightarrow T_n \rightarrow T_0 := t.$} \\
    & \text{$T_0$ is an inductive type} \\
    & \text{$\mathit{decls}$ is local variable declarations for variables used in $\genbodyb{K}{t}$ excluding $\fargs{t}$.} \\
    & K(e) = \dq{\kwCreturn\:e\ttsemi} \\
    & \fargs{t} =
      \begin{cases}
        \dq{T\:x\ttcomma\:\fargs{u}}      & t = \lamT{x}{T}{u} \\
        \fargs{t_j}       & t = \ofix{\rep{f:=t}}{f_j} \\
        \dq{}    & \text{otherwise}
      \end{cases} \\
    & \fargsd{t} = \fargs{t}~\text{without the trailing comma}
  \end{aligned}
\]

\subsection{Translation for Top-Level Function}\label{sec:genfun}
\[
  \genfun{c} =
  \begin{cases}
    \genfunm{c} & \text{$t$ needs multiple functions} \\
    \genfuns{c} & \text{otherwise}
  \end{cases}
\]
\[ \text{where} \quad
  \begin{aligned}[t]
    & \text{$c$ is defined as \kwDefinition~$c := t.$}
  \end{aligned}
\]

\section{Verification of \gallina-to-\gallina{} Transformations}\label{sec:verification-of-gallina-to-gallina-transformations}

\codegen{} verifies each step of the \gallina-to-\gallina{} transformations.

Most transformations in \codegen{} are convertible.
\codegen{} checks convertibility of such transformations.

There are two non-convertible transformations:

\begin{itemize}
  \item match-app in S-Reductions
  \item Unreachable Fixfunc Deletion
\end{itemize}

The verification for them is implemented in \verb!theories/verify.v!.

The match-app transformation moves arguments for function-returning match expression into
branches of the match expression as follows.
It transforms \lstinline!((if b then t else u) n)! to \lstinline!(if b then t n else u n)!.
The source definition \lstinline!f! is transformed and the result is defined as \lstinline!codegen_s0_f!.
The equality proof between them is defined as \lstinline!codegen_s0_f_proof!.

\begin{lstlisting}
From codegen Require Import codegen.

Definition f (b : bool) (n : nat) :=
  (if b then S else Nat.add n) n.
CodeGen Gen f.

Print codegen_s0_f.
(*
codegen_s0_f = fun (v1_b : bool) (v2_n : nat) => if v1_b then S v2_n else v2_n + v2_n
     : bool -> nat -> nat
*)

About codegen_s0_f_proof.
(* codegen_s0_f_proof : forall (b : bool) (n : nat), f b n = codegen_s0_f b n *)
\end{lstlisting}

The ``Unreachable Fixfunc Deletion'' drops unreachable functions from mutually-recursive fixpoints as follows.
The source definition \lstinline!f1! is defined as fixpoint which contains three functions: \lstinline!f1!, \lstinline!f2!, and \lstinline!f3!.
\lstinline!f1! calls \lstinline!f3!.
\lstinline!f2! calls \lstinline!f3!.
\lstinline!f3! calls \lstinline!f1!.
\lstinline!CodeGen Gen f1! drops \lstinline!f2! because \lstinline!f2! is not reachable from \lstinline!f1!.
The transformed term is defined as \lstinline!codegen_s0_f1! which doesn't contain \lstinline!f2!.
The equality of \lstinline!f1! and \lstinline!codegen_s0_f1! is proved as \lstinline!codegen_s0_f1_proof!.

\begin{lstlisting}
From codegen Require Import codegen.

Fixpoint f1 n := match n with 0 => 0 | S m => f3 m end
with f2 n := match n with 0 => 0 | S m => f3 m end
with f3 n := match n with 0 => 0 | S m => f1 m end.

Print f1.
(*
f1 =
fix f1 (n : nat) : nat :=
  match n with
  | 0 => 0
  | S m => f3 m
  end
with f2 (n : nat) : nat :=
  match n with
  | 0 => 0
  | S m => f3 m
  end
with f3 (n : nat) : nat :=
  match n with
  | 0 => 0
  | S m => f1 m
  end
for
f1
     : nat -> nat
*)

CodeGen Gen f1.

Print codegen_s0_f1.
(*
codegen_s0_f1 =
fix fixfunc1_f1 (v1_n : nat) : nat :=
  match v1_n with
  | 0 => 0
  | S v2_m => fixfunc2_f3 v2_m
  end
with fixfunc2_f3 (v3_n : nat) : nat :=
  match v3_n with
  | 0 => 0
  | S v4_m => fixfunc1_f1 v4_m
  end
for
fixfunc1_f1
     : nat -> nat
*)

About codegen_s0_f1_proof.
(* codegen_s0_f1_proof : forall n : nat, f1 n = codegen_s0_f1 n *)
\end{lstlisting}

%          reflexivity |
%          codegen_applyhyp |
%          codegen_matchapp |
%          codegen_fix |
%          codegen_letin |
%          codegen_apparg ]) ].

\begin{gather*}
  \text{intros:}~
    \dfrac{
      E[\Gamma; \mathit{vars}] \vdash p : t = t'
    }{
      E[\Gamma] \vdash \lam{\mathit{vars}}{p} : \forall \mathit{vars}, t = t'
    } \breakrule
\end{gather*}

\begin{gather*}
  \text{verify-refl:}~
    \dfrac{
      E[\Gamma] \vdash t \eqconv t'
    }{
      E[\Gamma] \vdash \mathsf{eq\_refl}~t : t = t'
    } \breakrule
\end{gather*}

\begin{gather*}
  \text{verify-applyhyp:}~
    \dfrac{
      (\mathit{IH} : t \simeq t') \in \Gamma
    }{
      E[\Gamma] \vdash \mathit{IH}\:\mathit{args} : t\ \mathit{args} = t'\ \mathit{args}
    } \breakrule
\end{gather*}

\begin{gather*}
  \text{verify-matchapp}:
    \dfrac{
      \rep{\underline{E[\Gamma]} \vdash p : \forall \mathit{cargs}, t\:\underline{\mathit{margs}} = t'\:\underline{\mathit{margs}'}}
    }{
      E[\Gamma] \vdash
        \begin{aligned}[t]
          & \kwmatch\:x\:\kwas\:x'\:\kwreturn \\
          & \quad
              \begin{aligned}
                & \kwmatch\:x'\:\kwwith\:\rep{C\:\mathit{cargs} \Rightarrow t}\:\kwend\:\mathit{margs} = \\
                & \kwmatch\:x'\:\kwwith\:\rep{C\:\mathit{cargs} \Rightarrow t'}\:\kwend\:\mathit{margs}'
              \end{aligned} \\
          & \kwwith\:\rep{C\:\mathit{cargs} \Rightarrow p\:\mathit{cargs}}\:\kwend \\
          & : \quad
              \begin{aligned}[t]
                & \kwmatch\:x\:\kwwith\:\rep{C\:\mathit{cargs} \Rightarrow t}\:\kwend\:\mathit{margs} = \\
                & \kwmatch\:x\:\kwwith\:\rep{C\:\mathit{cargs} \Rightarrow t'}\:\kwend\:\mathit{margs}'
              \end{aligned}
        \end{aligned}
    } \\
    \quad \mbox{Note:}~
      \begin{minipage}[t]{0.8\columnwidth}
        Since \codegen{} moves arguments for a \kwmatch-expression into the branches, $\mathit{margs}'$ is empty in general.
      \end{minipage}
\end{gather*}

\begin{gather*}
  \text{verify-fix}:
    \dfrac{
      \begin{aligned}
        & \forall i \in \{1\ldots h'\}, f_{\sigma(i)} = f'_i \qquad \mbox{(function name equality)} \\
        & \forall i \in \{1\ldots h'\}, k_{\sigma(i)} = k'_i \qquad \mbox{(decreasing argument position equality)} \\
        & \forall i \in \{1\ldots h'\}, \FV(t_{\sigma(i)}) \cap (\{\rep{f}\} \backslash \{\rep{f'}\}) = \varnothing \\
        & \forall i \in \{1\ldots h'\}, E[\Gamma]; \repi{\mathit{IH}\!_j : F_{\sigma(j)} \simeq F'_j}{j=1\ldots h'} \vdash p_i : \substm{t_{\sigma(i)}}{f}{F} \simeq \substm{t'_{i}}{f'}{F'}
      \end{aligned}
    }{
      \begin{aligned}
        & (\kwfix\:\repi{\mathit{IH}\!_j / k'_j : (F_{\sigma(j)} \simeq F'_j) := q_j}{j=1\ldots h'}\:\kwfor\:\mathit{IH}\!_{s'})\:\mathit{fargs} \\
        & : F_s\:\mathit{fargs} = F'_{s'}\:\mathit{fargs}
      \end{aligned}
    } \\
    \quad \mbox{where} \quad
      \begin{aligned}[t]
        & F_{i} := \kwfix\:\repi{f/k:=t}{j=1\ldots h}\:\kwfor\:{f_i} \\
        & F'_{i} := \kwfix\:\repi{f'/k':=t'}{j=1\ldots h'}\:\kwfor\:{f'_i} \\
        & \sigma : \{1\ldots h'\} \to \{1\ldots h\} \ \mbox{injective} \\
        & s := \sigma(s') \qquad \mbox{(start function index)} \\
        & \mbox{$\mathit{fargs}$ is arguments for the fixpoints (sequence of terms)} \\
        & q_j :=
          \begin{aligned}[t]
            & \lambda x_1 \ldots x_{\NA_{F'_j}} . \\
            & \kwlet\:H := p_{j}\:\kwin \\
            & \kwmatch\:x_{k'_j}\:\kwas\:y\:\kwreturn \\
            & \quad F_{\sigma(j)}\:x_1 \ldots x_{k'_j-1}\:y\:x_{k'_j+1} \ldots x_{\NA_{F'_j}} = F'_{j}\:x_1 \ldots x_{k'_j-1}\:y\:x_{k'_j+1} \ldots x_{\NA_{F'_j}} \\
            & \kwwith \\
            & \rep{|\:C\:\mathit{cargs} \Rightarrow \underline{H\:x_1 \ldots x_{k'_j-1}}\:(C\:\underline{\mathit{params}_j}\:\mathit{cargs})\:\underline{x_{k'_j+1} \ldots x_{\NA_{F'_j}}}} \\
            & \kwend
          \end{aligned} \\
        & \mbox{$\mathit{params}_j$ is the inductive type parameters of the decreasing argument of $f'_j$} \\
        & \mbox{$\mathit{cargs}$ is variables for the members of constructors}
      \end{aligned} \\
    \quad \mbox{Note:}~
      \begin{minipage}[t]{0.8\columnwidth}
        This verify-fix rule proves the transformation of fixpoints: $F_{s}$ to $F'_{s'}$.
        The transformation may drops functions in $F_{s}$ unreachable from $f_s$.
        The unreachable functions are $\{\rep{f}\} \backslash \{\rep{f'}\}$ because we assume the fixpoints uses same function names for corresponding functions.
        The correspondence of functions in the fixpoints is represented with $\sigma$.
        This rule builds a proof term ($\kwfix\ldots\kwfor\:\mathit{IH}\!_{s'}$) for extensional equality of fixpoints ($F_{s} \simeq F'_{s'}$) from extensional equality proofs of iota-fix reduced forms ($p_i$).
        The \kwmatch-expression in $q_j$ makes the equality iota-fix reducible by destructing the decreasing argument.
        The let-in expression to bind $H$ prevents copy of the proof term $p_j$ for each constructors.
      \end{minipage}
    \breakrule
\end{gather*}

\begin{gather*}
  \text{verify-letin-generic:}~
    \dfrac{
      \begin{aligned}
        & x'~\mathrm{fresh} \\
        & E[\Gamma] \vdash p : t \simeq t' \\
        & E[\Gamma; \ldefB{x}{t}; \ldefB{x'}{t'}; (H : x \simeq x')] \vdash q : u\:\mathit{args} = \subst{u'}{x}{x'}\:\mathit{args}'
      \end{aligned}
    }{
      E[\Gamma] \vdash
        \begin{aligned}[t]
          ( & \kwlet\: x := t \:\kwin \\
            & \kwlet\: x' := t' \:\kwin \\
            & \lam{(H : x \simeq x')}{q})\: p \\
        :\: & (\kwlet\: x := t \:\kwin\: u)\:\mathit{args} = (\kwlet\: x := t' \:\kwin\: u')\:\mathit{args}'
        \end{aligned}
    } \\
    \quad \mbox{Note:}~
      \begin{minipage}[t]{0.8\columnwidth}
        We use verify-letin-generic only when $t \not\equiv t'$.
        We prefer verify-letin-simple over verify-letin-generic for smaller proof terms.
      \end{minipage}
    \breakrule
\end{gather*}

\begin{gather*}
  \text{verify-letin-simple:}~
    \dfrac{
      \begin{aligned}
        & t \equiv t' \\
        & E[\Gamma; \ldefB{x}{t}] \vdash q : u\:\mathit{args} = u'\:\mathit{args}'
      \end{aligned}
    }{
      E[\Gamma] \vdash
        \begin{aligned}[t]
          ( & \kwlet\: x := t \:\kwin\: q) \\
          :\: & (\kwlet\: x := t \:\kwin\: u)\:\mathit{args} = (\kwlet\: x := t' \:\kwin\: u')\:\mathit{args}'
        \end{aligned}
    } \breakrule
\end{gather*}

\begin{gather*}
  \text{verify-apparg}:
    \dfrac{
      \begin{aligned}
        & \mbox{$t$ and $t'$ are not applications} \\
        & E[\Gamma] \vdash x \not\equiv x' \\
        & E[\Gamma] \vdash p : x = x' \\
        & E[\Gamma] \vdash q : t\: \mathit{hargs}\: x\: \mathit{targs} = t'\: \mathit{hargs}\: x\: \mathit{targs}'
      \end{aligned}
    }{
      \kwrew\: p\: \kwin\: q : t\: \mathit{hargs}\: x\: \mathit{targs} = t'\: \mathit{hargs}\: x'\: \mathit{targs}'
    } \\
    \quad \mbox{where} \quad \kwrew\: p\: \kwin\: q := \mathsf{eq\_ind}\: x\: (\lam{y}{t\: \mathit{hargs}\: x\: \mathit{targs} = t'\: \mathit{hargs}\: y\: \mathit{targs}'})\: q\: x'\: p \\
    \quad \mbox{Note:}~
      \begin{minipage}[t]{0.8\columnwidth}
        When $x$ and $x'$ are function arguments for higher order functoins $t$ and $t'$, $p$ is an equality of functions.
        It needs functional extensionality to convert extensional equality in $\Gamma$ (see the explanation for funext-fun).
      \end{minipage}
\end{gather*}

\begin{gather*}
  \text{funext-ind}:
    \dfrac{
      \begin{aligned}
        & \mbox{$t$ and $t'$ are not functions} \\
        & E[\Gamma] \vdash p : t \simeq t' \\
      \end{aligned}
    }{
      p : t = t'
    }
\end{gather*}

\begin{gather*}
  \text{funext-fun}:
    \dfrac{
      \begin{aligned}
        & \mbox{$t$ and $t'$ are functions} \\
        & E[\Gamma] \vdash p : \forall x, t\:x = t'\:x\\
      \end{aligned}
    }{
      p : \mathsf{functional\_extensionality}\:t\:t'\:p : t = t'
    } \\
    \quad \mbox{Note:}~
      \begin{minipage}[t]{0.8\columnwidth}
        $\mathsf{functional\_extensionality}$ is an axiom provided by \coq{} standard library.
      \end{minipage}
\end{gather*}

The axiom, $\mathsf{functional\_extensionality}$, is required when different functions are bounded with let-in and they are used as an argument for an application.
The verify-letin-generic rule introduces $x_1 \simeq x_2$ which is not usable for $\mathsf{eq\_ind}$ which require $x_1 = x_2$.

The reason \codegen{} uses the axiom, functional extensionality, is to reduce the time required for verification.
In the future, we may register a congruence lemma for each higher-order function and use it instead of the axioms.

The reason \codegen{} uses the axiom,functional extensionality, is to automate the verification process.
In the future, we may introduce the ability to register a congruence lemma for each higher-order function and use it instead of the axioms.

The axiom also solves a problem with an inductive type that contains a function.
The equality (Coq.Init.Logic.eq, $t = t'$) and extensional equality ($\forall \mathit{args}, t\:\mathit{args}=t'\:\mathit{args}$) are not suitable for such type.
Currently \codegen{} uses the former equality for inductive types even if they contains function.
But it requires the axiom to prove equality of a constructor application, $C\:x = C\:x'$ where $x$ and $x'$ are functions with extensional equality.
We can define new equality type for the type but it is tedious.

\bibliographystyle{plain}
\bibliography{base}

\end{document}
\endinput
